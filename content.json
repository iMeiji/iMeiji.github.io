{"meta":{"title":"这是个标题","subtitle":"这是个子标题","description":"描述一下","author":"iMeiji","url":"https://imeiji.github.io"},"pages":[{"title":"","date":"2015-12-26T03:17:03.000Z","updated":"2017-01-09T07:42:18.000Z","comments":false,"path":"categories/index.html","permalink":"https://imeiji.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Android 开发艺术探索 - 第三章笔记","slug":"Android 开发艺术探索 - 第三章笔记","date":"2018-08-09T16:15:15.000Z","updated":"2018-08-11T09:10:51.000Z","comments":true,"path":"2018/08/10/Android 开发艺术探索 - 第三章笔记/","link":"","permalink":"https://imeiji.github.io/2018/08/10/Android 开发艺术探索 - 第三章笔记/","excerpt":"","text":"3.1 View 基础知识3.1.1 什么是 ViewView 是 Android 中所有控件的基类，View 是一种界面层的控件的一种抽象，它代表了一个控件（如：Button、TextView）。除了 View 还有 ViewGroup，可以理解为控件组，它内部包含了许多个控件，即一组 View。在 Android 设计中，ViewGroup 也继承了 View，这就意味 View 本身就可以是单个控件也可以是多个控件组成的一组控件，通过这种关系就形成了 View 树，这和 Web 前端中的 DOM 树的概念是相识的。 3.1.2 View 的位置参数View 的位置主要由它的四个定点来决定，分别对应于 View 的四个属性：top、left、right、bottom。在 Android 中，x 轴和 y 轴的正方向分别为右和下。 View的位置坐标和父容器的关系.png 根据 View 的宽高和坐标的关系，得出： width = right - leftheight = bottom - top 解释部分参数： // View 的四个属性left = getLeft();right = getRight();top = getTop();bottom = getBottom();// x、y 是 View 左上角的坐标x = getX(); y = getY();// View 左上角相对于父容器的偏移量translationX = getTranslationX()translationY = getTranslationY()// 换算关系y = top + translationY 3.1.3 MotionEvent 和 TouchSlop MotionEvent 在手指接触屏幕后所产生的一系列事件中，典型的事件类型有如下几种： ACTION_DOWM 手指刚接触屏幕 ACTION_MOVE 手指在屏幕上移动 ACTION_UP 手指从屏幕上松开的一瞬间 正常情况下，一次手指触摸屏幕的行为会触发一系列点击事件，考虑如下几种形况： 点击屏幕后离开松开，事件序列为 DOWN -&gt; UP 点击屏幕滑动一会儿再松开，事件序列为 DOWN -&gt; MOVE -&gt; …. &gt; MOVE -&gt; UP TouchSlop TouchSlop 是系统所能识别出的被认为是滑动的最小距离。当手指在屏幕上滑动，如果两次滑动之间的距离小于这个常量，那么系统就不认为你是在进行滑动操作。 通过以下方式获取这个常量： ViewConfiguration.get(getContext()).getScaledTouchSlop(); 3.1.4 VelocityTracker、GestureDetector 和 Scroller VelocityTracker 速度追踪，用于追踪手指在滑动过程中的速度，包括水平和竖直方向的速度。速度的计算公式如下： 速度 = （终点位置 - 起点位置）/ 时间段 使用方式： // 首先在 View 的 onTouchEvent 方法中追踪当前单击事件的速度VelocityTracker vt = VelocityTracker.obtain();vt.addMovement(event);// 计算速度vt.computeCurrentVelocity(1000);// 获取速度getXVelocity()；getYVelocity()// 重置和回收vt.clear();vt.recycler(); GestureDetector 手势检测，用于辅助检测用户的单击、滑动、长按、双击等行为。如果只是监听滑动相关的，建议自己在 onTouchEvent 中实现，如果想要监听双击这种行为，那么就用 GestureDetecort。 使用方式： GestureDetector mGes = new GestureDetector(this);// 接管目标 View 的 onTouchEvent 方法boolean consume = mGes.onTouchEvent(event);return consume; Scroller 弹性滑动对象，用于实现View的弹性滑动。Scroller本身无法让View弹性滑动，它需要和 View 的computeScroll 方法配合使用才能共同完成这个功能。 使用方式： Scroller mScroller = new Scroller(getContext()); // 缓慢滑动到指定位置，1000 ms private void smoothScrollTo(int destX, int destY) &#123; int scrollX = getScrollX(); int delta = destX - scrollX; mScroller.startScroll(scrollX, 0, delta, 0, 1000); invalidate(); &#125; @Override public void computeScroll() &#123; if (scroller.computeScrollOffset()) &#123; scrollTo(mScroller.getCurrX(),mScroller.getCurrY()); postInvalidate(); &#125; &#125; 3.2 View 的滑动通过三种方式可以实现 View 的滑动 第一种是通过 View 本身提供的 scrollTo/scrollBy 方法来实现滑动 第二种是通过动画给 View 施加平移效果来实现滑动 通过改变 View 的 LayoutParams 使得 View 重新布局从而实现滑动 3.2.1 使用 scrollTo/scrollByscrollTo 和 scrollBy 方法只能改变 view 内容的位置而不能改变 view 在布局中的位置。 scrollBy 是基于当前位置的相对滑动，而 scrollTo 是基于所传参数的绝对滑动。通过 View 的 getScrollX 和 getScrollY 方法可以得到滑动的距离。 3.2.2 使用动画使用动画来移动 View 主要是操作view的 translationX 和 translationY 属性，既可以使用传统的 View 动画，也可以使用属性动画。 3.2.3 改变布局参数通过改变 LayoutParams 的方式去实现 View 的滑动是一种灵活的方法。 3.2.4 各种滑动方式的对比 scrollTo/scrollBy：操作简单，适合对 View 内容的滑动 动画：操作简单，主要适用于没有交互的 View 和实现复杂的动画效果 改变布局参数：操作稍微复杂，适用于有交互的 View 3.4 View 的事件分发机制3.4.1 事件分发机制的三个重要方法 public boolean dispatchTouchEvent(MotionEvent ev) 用来进行事件的分发。如果事件能够传递给当前的 View，那么此方法一定会被调用，返回结果受当前 View 的onTouchEvent 和下级 View 的 dispatchTouchEvent 方法的影响，表示是否消耗当前事件。 public boolean onInterceptTouchEvent(MotionEvent event) 在上述方法内部调用，用来判断是否拦截某个事件，如果当前 View 拦截了某个事件，那么在同一个事件序列当中，此方法不会被再次调用，返回结果表示是否拦截当前事件。 public boolean onTouchEvent(MotionEvent event) 在 dispatchTouchEvent 方法中调用，用来处理点击事件，返回结果表示是否消耗当前的事件，如果不消耗，则在同一个事件序列中，当前 View 无法再次接受到事件。 这三个方法的关系可以用如下伪代码表示： public boolean dispatchTouchEvent(MotionEvent event)&#123; boolean consume = false; if(onInterceptTouchEvent(ev)) &#123; consume = onTouchEvent(ev); &#125; else &#123; consume = child.dispatchTouchEvent(ev); &#125; return consume;&#125; 我们可以大致了解点击事件的传递规则：对于一个根 ViewGroup 来说，点击事件产生后，首先会传递给它，这时它的 dispatchTouchEvent 会被调用，如果这个 ViewGroup 的 onInterceptTouchEvent 方法返回 true 就表示它要拦截当前事件，接着事件就会交给这个 ViewGroup 处理，即它的 onTouchEvent 方法就会被调用；如果这个 ViewGroup 的 onInterceptTouchEvent 方法返回 false 就表示它不拦截当前事件，这时当前事件就会继续传递给它的子元素，接着子元素的 dispatchTouchEvent 方法就会被调用，如此反复直到事件被最终处理。 OnTouchListener 的优先级比 onTouchEvent 要高 如果给一个 View 设置了 OnTouchListener，那么 OnTouchListener 中的 onTouch 方法会被回调。这时事件如何处理还要看 onTouch 的返回值，如果返回 false，那么当前 View 的 onTouchEvent 方法会被调用；如果返回 true，那么 onTouchEvent 方法将不会被调用。 在 onTouchEvent 方法中，如果当前 View 设置了 OnClickListener，那么它的 onClick 方法会被调用，所以 OnClickListener 的优先级最低。 当点击一个事件产生后，它的传递过程遵循如顺序，Activity -&gt; Window -&gt; View 如果一个 View 的 onTouchEvent 方法返回 false，那么它的父容器的 onTouchEvent 方法将会被调用，依次类推，如果所有的元素都不处理这个事件，那么这个事件将会最终传递给 Activity 处理（调用 Activity 的onTouchEvent 方法） 关于事件传递的机制，给出一些结论： 同一个事件序列是以 down 事件开始，中间含有数量不定的 move 事件，最终以 up 事件结束 正常情况下，一个事件序列只能被一个 View 拦截且消耗。一旦一个元素拦截了某次事件，那么同一个事件序列内的所有事件都会直接交给它处理，因此同一个事件序列中的事件不能分别由两个View同时处理，但是通过特殊手段可以做到，比如一个 View 将本该自己处理的事件通过 onTouchEvent 强行传递给其他 View 处理 某个 View 一旦开始处理事件，如果它不消耗 ACTION_DOWN 事件，那么同一事件序列的其他事情都不会再交给它来处理，并且事件将重新交给它的父容器去处理（调用父容器的 onTouchEvent 方法）；如果它消耗 ACTION_DOWN 事件，但是不消耗其他类型事件，那么这个点击事件会消失，父容器的 onTouchEvent 方法不会被调用，当前 View 依然可以收到后续的事件，但是这些事件最后都会传递给 Activity 处理。 ViewGroup 默认不拦截任何事件。Android 源码中 ViewGroup 的 onInterceptTouchEvent 方法默认返回false，View 没有 onInterceptTouchEvent 方法，一旦有点击事件传递给它，那么它的 onTouchEvent 方法就会调用。 View 的 onTouchEvent 默认都会消耗事件（返回true），除非它是不可点击的（clickable 和 longClickable 同时为 false）。View 的 longClickable 属性默认都为 false，clickable 要分情况，比如 Button 的 clickable 属性默认为 true，而 TextView 的 clickable 属性默认为 false。 View 的 enable 属性不影响 onTouchEvent 的默认返回值，哪怕一个 View 是 disable 状态的，只要它的 clickable 或者 longClickable 有一个为 true，那么它的 onTouchEvent 就返回 true 事件传递过程总是先传递给父元素，然后再由父元素分发给子 View，通过requestDisallowInterceptTouchEvent 方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN 事件除外，即当面对 ACTION_DOWN 事件时，ViewGroup 总是会调用自己的onInterceptTouchEvent 方法来询问自己是否要拦截事件。 3.5 View 的滑动冲突3.5.1 常见的滑动冲突场景 外部滑动方向与内部滑动方向不一致，比如 ViewPager 中包含 ListView 外部滑动方向与内部滑动方向一致 上面两种情况的嵌套 3.5.2 滑动冲突的处理规则可以根据滑动距离和水平方向形成的夹角；或者根据水平和竖直方向滑动的距离差；或者两个方向上的速度差等。 3.5.3 滑动冲突的解决方式 外部拦截法 点击事件都经过父容器的拦截处理，如果父容器需要此事件就拦截，如果不需要此事件就不拦截，该方法需要重写父容器的 onInterceptTouchEvent 方法，在内部做相应的拦截即可，伪代码如下： public boolean onInterceptTouchEvent(MotionEvent event) &#123; boolean intercepted = false; int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; intercepted = false; break; &#125; case MotionEvent.ACTION_MOVE: &#123; int deltaX = x - mLastXIntercept; int deltaY = y - mLastYIntercept; if (父容器需要拦截当前点击事件的条件，例如：Math.abs(deltaX) &gt; Math.abs(deltaY))&#123; intercepted = true; &#125; else&#123; intercepted = false; &#125; break; &#125; case MotionEvent.ACTION_UP: &#123; intercepted = false; break; &#125; default: break; &#125; mLastXIntercept = x; mLastYIntercept = y; return intercepted;&#125; 内部拦截法 父容器不拦截任何事件，所有的事件都传递给子元素，如果子元素需要此事件就直接消耗掉，否则就由父容器进行处理，这种方法和 Android 中的事件分发机制不一样，需要配合 requestDisallowInterceptTouchEvent 方法才能正常工作。 public boolean dispatchTouchEvent(MotionEvent event) &#123; int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123;] getParent().requestDisallowInterceptTouchEvent(true); break; &#125; case MotionEvent.ACTION_MOVE: &#123; int deltaX = x - mLastX; int deltaY = y - mLastY; if (当前view需要拦截当前点击事件的条件，例如：Math.abs(deltaX) &gt; Math.abs(deltaY))&#123; getParent().requestDisallowInterceptTouchEvent(false); &#125; break; &#125; case MotionEvent.ACTION_UP: &#123; break; &#125; default: break; &#125; mLastX = x; mLastY = y; return super.dispatchTouchEvent(event);&#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://imeiji.github.io/categories/Android/"}],"tags":[]},{"title":"Android 开发艺术探索 - 第二章笔记","slug":"Android 开发艺术探索 - 第二章笔记","date":"2018-07-31T16:15:15.000Z","updated":"2018-08-04T10:25:35.000Z","comments":true,"path":"2018/08/01/Android 开发艺术探索 - 第二章笔记/","link":"","permalink":"https://imeiji.github.io/2018/08/01/Android 开发艺术探索 - 第二章笔记/","excerpt":"","text":"2.1 Android IPC 简介 线程是 CPU 调度的最小单元，同时线程是一种有限的系统资源。而进程一般指一个执行单元，在 PC 和移动设备上指一个程序或者一个应用。一个进程可以包含多个线程 Windows 上可以通过剪贴板、管道和油槽等来进行进程间通信；Linux 上可以通过命名管道、共享内存、信号量等来进行进程间通讯；Android 上可以通过 Binder、Socket 实现进程间通讯 2.2 Android 中的多进程模式2.2.1 开启多进程模式在 Android 中使用多进程的方法，那就是给四大组件（Activity、Service、Receiver、ContentProvider）在 AndroidMenifest 中指定 android:process 属性。其实还有另一种非常规的多进程方法，那就是通过 JNI 在 native 层去 fork 一个新的进程。 实例： // 包名为 com.example.application&lt;service android:name=&quot;.service.MyRemoteService&quot; android:process=&quot;:remote&quot; /&gt;&lt;service android:name=&quot;.service.MyRemoteServiceII&quot; android:process=&quot;com.example.application.remote&quot; /&gt; 当 MyRemoteService 启动时，系统会为它创建一个单独的进程 ”com.example.application:remote“； 当 MyRemoteServiceII 启动时，系统会为它创建一个单独的进程 ”com.example.application.remote“； 没有指定 process 属性的，那么它运行在默认进程中，默认进程就是包名。 ”:“ 的含义是指要在当前的进程名前面附加上当前的包名，这是一种简写。其次，进程名以 ”:“ 开头的进程属于当前应用的私有进程，其他应用的组件不可以和它跑在同一个进程中，而进程名不以 ”:“ 开头的进程属于全局进程，其他应用通过 shareUID 方式可以和它跑在同一个进程中。 2.2.2 多进程模式的运行机制一般来说，使用多进程会造成如下几方面的问题： 静态成员和单例模式完全失效 线程同步机制完全失效 SharedPreferences 的可靠性下降 Application 会多次创建 第一、二个问题是类似的，既然都不在同一块内存了，那么不管是锁对象还是锁全局类都无法保证线程同步，因为不同进程锁的不是用一个对象。第三个问题因为 SharedPreferences 底层是通过读/写 XML 文件来实现，并发读/写都有可能出现问题。第四个问题，运行在不同进程中的组件是属于两个不同的虚拟机和 Application 的。 2.3 IPC 基础概念介绍2.3.1 Serializable 接口Serializable 是 Java 所提供的一个序列化接口，它是一个空接口，为对象提供标准的序列化和反序列化操作。使用 Serializable 只需要在类的声明中指定 serialVersionUID 。 private static final long serialVersionUID = 233333333333333L 这个 serialVersionUID 是用来辅助序列化和反序列化过程的，原则上序列化后的数据中的 serialVersionUID 只有和当前类的 serialVersionUID 相同才能够正常地被反序列化。 默认实现 Serializable 不会自动创建 serialVersionUID 属性，我们可以开启警告，这样按下代码补全就自动生成 serialVersionUID 。 Serializable_setting.png 以下两点需要特别注意： 静态成员变量不属于类对象，所以不会参与序列化过程 用 transient 关键字标记的成员变量不会参与序列化过程 2.3.2 Parcelable 接口Parcelable 也是一个接口，只要实现了这个接口，一个类的对象就可以实现序列化并可以通过 Intent 和 Binder 传递。Android Studio 支持一键自动生成 Parcelable 代码，所以不用怕麻烦。 Parcelable.png Serializable 和 Parcelable 如何选取？ Serializable 是 Java 中的序列化接口，其使用起来非常简单但是开销很大，整个过程需要大量 I/O 操作。一般在保存数据到 SD 卡或者网络传输时建议使用 Serializable 即可，虽然效率差一些，好在使用方便。 而 Parcelable 是 Android 中的序列化方式，更适合在 Android 平台上，缺点是使用起来稍微麻烦，但是它的效率很高。而在运行时数据传递时建议使用 Parcelable，比如 Intent，Bundle 等。 2.3.3 Binder直观来说，Binder 是 Android 中的一个类，它实现了 IBinder 接口。从 IPC 角度来说，Binder 是 Android 中的一种跨进程通讯方式；从 Android Framework 角度来说，Binder 是 ServiceManager 连接各种 Manager（ActivityManager、WindowManager，等等）和相应 ManagerService 的桥梁；从 Android 应用层来说，Binder 是客户端和服务端进行通讯的媒介。 下面讲几个重要的方法： asInterface // 用于将服务端的 Binder 对象转换成客户端所需的 AIDL 接口对象public static com.meiji.IMyAidlInterface asInterface(android.os.IBinder obj) &#123; // 客户端和服务端位于同一进程，返回服务端的 Stub 对象本身 android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.meiji.IMyAidlInterface))) &#123; return ((com.meiji.IMyAidlInterface) iin); &#125; // 返回封装后的 Stub.Proxy 对象 return new com.meiji.IMyAidlInterface.Stub.Proxy(obj);&#125; onTransact @Overridepublic boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123;// 服务端通过 code 确定客户端请求的目标方法 switch (code) &#123; case TRANSACTION_basicTypes: &#123; data.enforceInterface(DESCRIPTOR); int _arg0; // 从 data 中取出参数 _arg0 = data.readInt(); // 然后执行目标方法 this.basicTypes(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5); // 执行完毕后，向 reply 中写入返回值 reply.writeNoException(); reply.writeInt(_result); return true; &#125; &#125; return super.onTransact(code, data, reply, flags);&#125; Proxy#toUpperCase // 这个方法是我们在 AIDL 文件里定义的接口实现方法，当客户端调用此方法@Overridepublic String toUpperCase(java.lang.String aString) throws android.os.RemoteException &#123; // 创建输入型 Parcel 对象 _data android.os.Parcel _data = android.os.Parcel.obtain(); // 创建输出型 Parcel 对象 _reply android.os.Parcel _reply = android.os.Parcel.obtain(); java.lang.String _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); // 把参数信息写入 _data 中 _data.writeString(aString); // 调用 transact 发起 RPC（远程调用过程），同时挂起当前线程，然后服务端 onTransact 被调用 mRemote.transact(Stub.TRANSACTION_toUpperCase, _data, _reply, 0); _reply.readException(); // 写入服务端 onTransact 返回的数据 _result = _reply.readString(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; // 最后返回 _reply 中的数据 return _result;&#125; 注意几点： 当客户端发起远程请求时，由于当前线程会被挂起直至服务端进程返回数据，所以如果一个远程方法时很耗时的，那么不能再 UI 线程中发起远程请求 由于服务端的 Binder 方法运行在 Binder 的线程池中，所以 Binder 方法不管是否耗时都应该采用同步的方式去实现，因为它已经运行在一个线程中了 通过 Binder 的 linkToDeath 方法可以给 Binder 设置一个死亡代理，当 Binder 死亡时 ，我们就会收到通知，这个时候可以重新发起连接请求从而恢复连接 Binder 的工作机制： Binder工作机制.png 2.4 Android 中的 IPC 方式2.4.1 使用 Bundle四大组件中的三大组件（Activity、Service、Receiver）都支持在 Intent 中传递 Bundle 数据 2.4.2 使用文件共享两个进程通过读/写同一个文件来交换数据，Android 系统允许并发读/写文件。使用 ObjectOutputStream 、ObjectInputStream 序列化一个对象到文件系统中同时从另一个进程中恢复这个对象。 SharedPreferences 也属于文件共享的一类，当面对高并发的读/写访问，SharedPreferences 有很大几率会丢失数据。 综上所示，文件共享方式适合在对数据同步要求不高的进程之间进行通讯，并且要妥协处理并发读/写的问题。 2.4.3 使用 MessengerMessenger 可以翻译为信使，通过它可以在不同进程中传递 Message 对象，在 Message 中放入我们需要传递的数据，就可以轻松地实现数据的进程间传递。Messenger 是一种轻量级的 IPC 方案，它的底层实现是 AIDL 。 Messenger工作机制.png 2.4.4 使用 AIDLMessenger 的作用主要是为了传递消息，很多时候我们可能需要跨进程调用服务端的方法，这种情形用 Mess anger 就无法做大了，但是可以使用 AIDL 来实现跨进程的方法调用。 AIDL 大致流程：首先创建一个 Service 和一个 AIDL 接口，接着创建一个类继承 AIDL 接口中的 Stub 类并实现 Stub 中的抽象方法，在 Service 的 onBind 方法中返回这个类的对象，然后客户端就可以绑定服务端 Service，建立连接后就可以访问远程服务端的方法了。 另外，由于服务端的方法（Stub 中的抽象方法）本身运行在服务端的 Binder 线程池中，所以服务端方法本身就可以执行大量耗时操作，这个时候切记不要再服务端方法中开线程去进行异步任务，除非你明确知道自己在干什么，否则不建议这么做。 2.4.5 使用 ContentProvider和 Messenger 一样，ContentProvider 的底层实现同样也是 Binder，它是 Android 中提供的专门用于不同应用间进行数据共享的方式。系统预置了许多 ContentProvider，比如通讯录信息、日程表信息等。 ContentProvider 中有六个抽象方法：onCreate、query、update、insert、delete、getType，除了 onCreate 由系统回调并运行在主线程里，其他五个方法均由外界回调并运行在 Binder 线程池中。 2.5 Binder 连接池随着项目越来越大，AIDL 数量的增加，我们不能无限制地增加 Service，应该将所有的 AIDL 放在同一个 Service 中去管理。在这种模式下，服务端提供一个 queryBinder 接口，这个接口能够根据不同业务返回相应的 Binder 对象给客户端，客户端就可以进行远程方法调用了。 Binder连接池的工作原理.png 2.6 选用合适的 IPC 方式 IPC优缺点和适用场景.png","categories":[{"name":"Android","slug":"Android","permalink":"https://imeiji.github.io/categories/Android/"}],"tags":[]},{"title":"Android 开发艺术探索 - 第一章笔记","slug":"Android 开发艺术探索 - 第一章笔记","date":"2018-07-23T14:28:15.000Z","updated":"2018-07-24T13:20:18.000Z","comments":true,"path":"2018/07/23/Android 开发艺术探索 - 第一章笔记/","link":"","permalink":"https://imeiji.github.io/2018/07/23/Android 开发艺术探索 - 第一章笔记/","excerpt":"","text":"1.1 Activity 的生命周期全面分析 onStart 和 onResume 的区别是 onStart 此时 Activity 已经可见，但是还没有出现在前台，无法和用户交互。onResume 的时候 Activity 在前台，获取到焦点能与用户交互。 新 Activity 是透明主题时，旧 Activity 不会走 onStop Activity 切换时，旧 Activity 的 onPause 会先执行，然后才会启动新的 Activity Activity 在异常情况下被回收时，onSaveInstanceState 方法会被回调，回调时机是在onStop 之前，当 Activity 被重新创建的时候，onRestoreInstanceState 方法会被回调，时序在 onStart 之后 当 Activity 被销毁并重新创建后，可恢复的位置可以选择 onRestoreInstanceState 和 onCreate ，二者的区别是 onRestoreInstanceState 一旦被调用，其参数 Bundle savedInstanceState 一定是有值的，我们不用额外判断是否为空；但是在 onCreate 里必须判断是否为空，官方推荐采用 onRestoreInstanceState 去恢复数据 1.2 Activity 的 LaunchMode standard 系统默认。每次启动会重新创建新的实例，谁启动了这个Activity，这个Activity 就在谁的栈里 singleTop 栈顶复用模式。如果新的 Activity 已经位于任务栈的栈顶，那么此Activity不会被重新创建，该 Activity 的 onNewIntent 方法会被回调，onCreate 和 onStart 并不会被调用 singleTask 栈内复用模式。只要该 Activity 在一个栈中存在，都不会重新创建，onNewIntent 会被回调。如果不存在，系统会先寻找是否存在需要的栈，如果不存在该栈，就创建一个任务栈，然后把这个 Activity 放进去；如果存在，就会创建到已经存在的这个栈中 singleInstance 单实例模式。具有此种模式的 Activity 只能单独存在于一个任务栈 什么是任务栈？ 默认情况下所有 Activity 所需的任务栈的名字为应用的包名，可以为每个 Activity 都单独在 AndroidManifest 指定 TaskAffinity 属性。当 TaskAffinity 和 singleTask 启动模式配对使用的时候，待启动的 Activity 会运行在名字和 TaskAffinity 相同的任务栈中 Activity 的 Flags FLAG_ACTIVITY_NEW_TASK 它与 launchMode=”singleTask” 具有相同的行为。实际上，并不是完全相同！很少单独使用 FLAG_ACTIVITY_NEW_TASK，通常与 FLAG_ACTIVITY_CLEAR_TASK 或 FLAG_ACTIVITY_CLEAR_TOP 联合使用。在相互跳转的两个 Activity的 android:taskAffinity 相同的情况下 ，单独使用 FLAG_ACTIVITY_NEW_TASK 不会产生任何效果 FLAG_ACTIVITY_SINGLE_TOP 它与 launchMode=”singleTop” 具有相同的行为 FLAG_ACTIVITY_CLEAR_TOP 当它启动时，在同一个任务栈中所有位于它上面的 Activity 都要出栈。FLAG_ACTIVITY_CLEAR_TOP 和 FLAG_ACTIVITY_NEW_TASK 两者同时使用，就能达到和 launchMode=”singleTask” 一样的效果 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS 具有这个标记的 Activity 不会出现在历史 Activity 的列表中，他等同于在 XML 中指定 Activity 的属性 android:excludeFromRecents=’true’ FLAG_ACTIVITY_CLEAR_TASK 使用 FLAG_ACTIVITY_CLEAR_TASK 时，通常会包含 FLAG_ACTIVITY_NEW_TASK 。这样做的目的是启动 Activity 时，清除之前已经存在的 Activity 实例所在的 task ；这自然也就清除了之前存在的 Activity 实例 通过 AndroidManifest 指定启动模式和通过在 Intent 中设置标志位来指定启动模式，二者的区别是什么？ 优先级。当同时使用 launchMode 和上面的 FLAG_ACTIVITY_NEW_TASK 等标签时，以FLAG_ACTIVITY_NEW_TASK 为标准。也就是说，代码的优先级比 manifest 中配置文件的优先级更高 限定范围。在 manifest 中无法配置 FLAG_ACTIVITY_CLEAR_TOP 等标识，在 Intent 中无法指定 singleInstance 模式 1.3 IntentFilter 的匹配规则 action 匹配规则：要求 Intent 中的 action 存在且必须和过滤规则中的其中一个相同，区分大小写 category 匹配规则：系统会默认加上一个 android.intent.category.DEAFAULT ，所以Intent 中可以不存在 category ，但如果存在就必须匹配其中一个 data 匹配规则：data 由两部分组成，mimeType 和 URI。mimeType 指媒体类型，比如 image/jpeg、video/*，可以表示图片、文本、视频等不同的媒体格式，而 URI 中包含的数据就比较多了，下面是 URI 的结构： &lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;] 这里再给几个实际的例子就好理解了 content://com.example.project:200/folder/subfolder/etchttps://www.google.com:443/search/info 要求 Intent 中必须含有 data 数据。如果没有指定 URI，URI 的默认值为 content 和file（schema） 判断是否有 Activity 匹配我们的隐式 Intent： 采用 PackageManager 的 resolveActivity 方法或者 Intent 的 resolveActivity 方法，果它们找不到匹配的 Activity 就会返回 null。另外，PackageManager 还提供了queryIntentActivities 方法，这个方法和 resolveActivity 方法不同的是：它不是返回最佳匹配的 Activity 信息而是返回所有成功匹配的 Activity 信息 public abstract List&lt;ResolveInfo&gt;queryIntentActivities(Intent intent,int fladgs);public abstract ResolveInfo resolveActivity(Intent intent,int flags);","categories":[{"name":"Android","slug":"Android","permalink":"https://imeiji.github.io/categories/Android/"}],"tags":[]},{"title":"谈谈 Android 压缩和加载大图片","slug":"谈谈 Android 压缩和加载大图片","date":"2018-07-08T13:28:15.000Z","updated":"2018-07-08T13:31:20.000Z","comments":true,"path":"2018/07/08/谈谈 Android 压缩和加载大图片/","link":"","permalink":"https://imeiji.github.io/2018/07/08/谈谈 Android 压缩和加载大图片/","excerpt":"","text":"引言目前手机摄像头像素越来越高，拍个照动不动就 5-10 M，图片体积过大导致程序很可能直接 OOM，所以压缩和加载大图片要特殊处理。微信官方有一条关于图片流量的数据，根据原图质量压缩至50-200K/张 。朋友圈的图片是强制压缩，我们只能给朋友发照片的时候选择发送原图。 wechat.png 为什么会 OOM 通常情况下，移动设备的内存资源是有限的，Android 系统会根据手机的屏幕大小和密度，为每个程序设置一个最大内存限制，应用程序消耗的内存不能超过这个最大内存限制，否则就会出现 OOM 现象。当然，这个内存限制是跟手机配置相关联的，可以通过 ActivityManager.getLargeMemoryClass 读取 图片的操作会消耗大量的内存，特别是细节丰富的图片，例如照片。以 Galaxy Nexus 相机为例子，它拍摄一张 2592x1936 像素的照片，如果使用的位图配置是 ARGB_8888 (默认从 Android 2.3 开始)，那么这张照片加载到内存，大约会消耗 19MB 的内存（2592 x 1936 x 4字节），仅仅是图片消耗内存的数值可能已经超过了某些设备的内存限制 Android 的 UI 经常会一次加载多张图片，例如，ListView、GridView、ViewPager 等等 压缩图片首先，在 Android 设备中，图片有如下三种存在形式： 在硬盘上时，图片展现的方式是 File 在网络传输时，图片展现的方式是 Stream 在内存中，图片展现的方式是 Stream 或 Bitmap 因此，我们既要压缩图片 File 大小（减轻服务器存储压力），又要压缩图片 Pixel（避免 OOM） Android 中有两种压缩图片的方法： 质量压缩（不改变图片的尺寸） 质量压缩一般可用于上传大图前的处理，这样就可以节省一定的流量。所谓的质量压缩，它其实只能实现对 File 的影响。缺点：照片失真、耗时 尺寸压缩（相当于是像素上的压缩） 尺寸压缩一般可用于生成缩略图通过缩放图片像素来减少图片占用内存大小 那么问题来了，拿到一张超大图片是先进行质量压缩，还是尺寸压缩呢？ 质量压缩Bitmap.compress(CompressFormat format, int quality, OutputStream stream) 这个方法有三个参数，是布尔类型的返回值 CompressFormat 指定的 Bitmap 被压缩成的图片格式，只支持 JPEG，PNG，WEBP 三种 quality 图片压缩质量的控制，范围为 0~100，0 表示压缩后体积最小，但是质量也是最差，100 表示压缩后体积最大，但是质量也是最好的（个人认为相当于未压缩，注意某些特殊情况压缩后体积反而增大），有些格式，例如 PNG，它是无损的，所以会忽略这个值。 OutputStream 压缩后的数据会写入这个字节流中 返回值表示返回的字节流是否可以使用BitmapFactory.decodeStream()解码成 Bitmap，至于返回值是怎么得到的，因为是 Native 的代码，没法找到逻辑。 压缩过程如下，通过依次减少图片质量，将图片大小控制在限制值范围内 /** * 压缩图片 * * @param bitmap 被压缩的图片 * @param sizeLimit 大小限制 * @return 压缩后的图片 */private Bitmap compressBitmap(Bitmap bitmap, long sizeLimit) &#123; ByteArrayOutputStream baos = new ByteArrayOutputStream(); int quality = 100; bitmap.compress(Bitmap.CompressFormat.JPEG, quality, baos); // 循环判断压缩后图片是否超过限制大小，注意控制 quality 不能小于 0 ，我这里设置为 10 while(baos.toByteArray().length / 1024 &gt; sizeLimit &amp;&amp; quality &gt;= 10) &#123; // 清空baos baos.reset(); bitmap.compress(Bitmap.CompressFormat.JPEG, quality, baos); quality -= 10; &#125; Bitmap newBitmap = BitmapFactory.decodeStream(new ByteArrayInputStream(baos.toByteArray()), null, null); return newBitmap;&#125; 小结，质量压缩通过不断较少 quality 来限制文件大小，假如图片特别大，当执行ByteArrayOutputStream.toByteArray() 这行时很可能 OOM，消耗的内存超过最大内存限制，所以质量压缩不能先执行。 OOM.png 尺寸压缩Android 中的 BitmapFactory 类提供了一些解码方法，decodeByteArray()、decodeFile()、decodeResource()等等，根据不通的图片源选择不同的解码方法加载图片创建出 Bitmap。这些方法中都会传入一个BitmapFactory.Options 实例化对象，通过这个对象，可以更改一些加载图片的设置。由于这些解码方法用于解码加载图片，会占用内存构建 Bitmap，因此很容易导致 OOM 的异常。如果将 options.inJustDecodeBounds 设置为 true，在解码过程中就不会申请内存去创建 Bitmap，返回的是一个空的 Bitmap，但是可以获取图片的一些属性，例如图片宽高，图片类型等等。 BitmapFactory.Options options = new BitmapFactory.Options();options.inJustDecodeBounds = true; // 设置为true，不将图片解码到内存中BitmapFactory.decodeResource(getResources(), R.id.myimage, options);int imageHeight = options.outHeight; // 图片高度int imageWidth = options.outWidth; // 图片宽度String imageType = options.outMimeType; // 图片类型 我们知道图片的大小之后，就可以决定是否将完整的图片加载到内存或者加载压缩版的图片到内存。可以基于以下几点做出决定： 估计完整图片加载到内存中所使用内存 可分配给加载图片的内存 用于显示图片的控件的大小 当前设备的屏幕大小和密度 例如，如果显示图片的控件大小为 128x96 像素，就没有必要将一个 1024x768 像素的图片加载到内存中。 设置options.inSampleSize的数值，来控制压缩图片程度。例如，将options.inSampleSize设置为 4，将一个 2048x1536 像素的图片解码加载到内存后产生的 Bitmap 大约为 512x384 像素，如果使用的位图配置是ARGB_8888，那么仅仅需要 0.75M（512 384 4 / 1024 / 1024） 就加载了缩小版的图片到内存，而加载完整的图片需要 12M（2048 1536 4 / 1024 / 1024）。 也就是说，如果我们设置inSampleSize == 2，解码出来的位图的宽高是原图的 1/2，图片所占用内存缩小了1/4（1/2 * 1/2）。如果inSampleSize设置的值小于等1，都会当做inSampleSize == 1来解码加载图片。 于是我们可以在加载图片的时候，根据控件的大小（显示到屏幕上的大小）来计算出压缩版图片的inSampleSize值。计算恰当的inSampleSize是尺寸压缩最重要的参数，网上有很多种算法，这里罗列几种 Android 源码计算方式 public static int computeSizeByAndroid(BitmapFactory.Options options, int minSideLength, int maxNumOfPixels) &#123; int initialSize = computeInitialSampleSize(options, minSideLength, maxNumOfPixels); int roundedSize; if (initialSize &lt;= 8) &#123; roundedSize = 1; while (roundedSize &lt; initialSize) &#123; roundedSize &lt;&lt;= 1; &#125; &#125; else &#123; roundedSize = (initialSize + 7) / 8 * 8; &#125; return roundedSize; &#125; private static int computeInitialSampleSize(BitmapFactory.Options options, int minSideLength, int maxNumOfPixels) &#123; double w = options.outWidth; double h = options.outHeight; int lowerBound = (maxNumOfPixels == -1) ? 1 : (int) Math.ceil(Math.sqrt(w * h / maxNumOfPixels)); int upperBound = (minSideLength == -1) ? 128 : (int) Math.min(Math.floor(w / minSideLength), Math.floor(h / minSideLength)); if (upperBound &lt; lowerBound) &#123; // return the larger one when there is no overlapping zone. return lowerBound; &#125; if ((maxNumOfPixels == -1) &amp;&amp; (minSideLength == -1)) &#123; return 1; &#125; else if (minSideLength == -1) &#123; return lowerBound; &#125; else &#123; return upperBound; &#125; &#125; 使用方法如下，其中 tagWidth 和 tagHeight 为压缩后的长宽 BitmapFactory.Options options = new BitmapFactory.Options();options.inJustDecodeBounds = true;options.inSampleSize = computeSampleSize(options, -1, tagWidth * tagHeight); 常规算法 public static int computeSize(int srcWidth, int srcHeight, int tagWidth, int tagHeight) &#123; int sampleSize = 1; if (srcHeight &gt; tagHeight &amp;&amp; srcWidth &gt; tagWidth) &#123; sampleSize = srcWidth / tagWidth; &#125; else if (srcHeight &lt; tagHeight &amp;&amp; srcWidth &gt; tagWidth) &#123; sampleSize = srcHeight / tagHeight; &#125; return sampleSize; &#125; 其中，srcWidth 和 srcHeight 为原图片大小，tagWidth 和 tagHeight 为压缩后的长宽 鲁班算法，据说接近微信压缩算法 public static int computeSizeByLuban(int srcWidth, int srcHeight) &#123; int sampleSize; srcWidth = srcWidth % 2 == 1 ? srcWidth + 1 : srcWidth; srcHeight = srcHeight % 2 == 1 ? srcHeight + 1 : srcHeight; srcWidth = srcWidth &gt; srcHeight ? srcHeight : srcWidth; srcHeight = srcWidth &gt; srcHeight ? srcWidth : srcHeight; double scale = ((double) srcWidth / srcHeight); if (scale &lt;= 1 &amp;&amp; scale &gt; 0.5625) &#123; if (srcHeight &lt; 1664) &#123; sampleSize = 1; &#125; else if (srcHeight &gt;= 1664 &amp;&amp; srcHeight &lt; 4990) &#123; sampleSize = 2; &#125; else if (srcHeight &gt;= 4990 &amp;&amp; srcHeight &lt; 10240) &#123; sampleSize = 4; &#125; else &#123; sampleSize = srcHeight / 1280 == 0 ? 1 : srcHeight / 1280; &#125; &#125; else if (scale &lt;= 0.5625 &amp;&amp; scale &gt; 0.5) &#123; sampleSize = srcHeight / 1280 == 0 ? 1 : srcHeight / 1280; &#125; else &#123; sampleSize = (int) Math.ceil(srcHeight / (1280.0 / scale)); &#125; return sampleSize; &#125; OK，得到 inSampleSize 值后，就可以根据这个值来加载压缩版的图片了 public static Bitmap decodeSampledBitmapFromResource(Resources res, int resId, int reqWidth, int reqHeight) &#123; // 先将inJustDecodeBounds设置为true来获取图片的长宽属性 final BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; BitmapFactory.decodeResource(res, resId, options); // 计算inSampleSize options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight); // 加载压缩版图片 options.inJustDecodeBounds = false; // 根据具体情况选择具体的解码方法 return BitmapFactory.decodeResource(res, resId, options);&#125; 小结，尺寸压缩的首先要获取原图的长宽值，设置options.inJustDecodeBounds = true仅获取 Bitmap 基本信息，接着计算 inSampleSize 值，最后通过 BitmapFactory 解码完成 执行顺序回到上面那个问题，拿到一张超大图片是先进行质量压缩，还是尺寸压缩呢？ 答案是先尺寸压缩，后质量压缩，因为尺寸压缩可以设置options.inJustDecodeBounds = true仅获取 Bitmap 基本信息，几乎不占用应用程序的运行内存，最终代码如下 /** * 图片压缩，先尺寸压缩，后质量压缩 * * @param srcImage 原图片文件 * @param tagImage 压缩后的文件 * @param byteSize 压缩后的文件大小 单位 byte * @param tagWidth 压缩后的图片宽度 * @param tagHeight 压缩后的图片高度 * @return 压缩后的文件 * @throws IOException */ public static File compress(File srcImage, File tagImage, long byteSize, int tagWidth, int tagHeight) throws IOException &#123; BitmapFactory.Options options = new BitmapFactory.Options(); // 仅获取基本 Bitmap 信息 options.inJustDecodeBounds = true; BitmapFactory.decodeFile(srcImage.getAbsolutePath(), options); // 原图片的宽高 int srcWidth = options.outWidth; int srcHeight = options.outHeight; // 若不指定压缩后的图片宽高，采用鲁班算法 if (tagHeight == 0 || tagWidth == 0) &#123; options.inSampleSize = computeSizeByLuban(srcWidth, srcHeight); &#125; else &#123; // 定压缩后的图片宽高，采用Android算法 options.inSampleSize = computeSizeByAndroid(options, -1, tagWidth * tagHeight); &#125; options.inJustDecodeBounds = false; // 尺寸压缩后的 Bitmap Bitmap tagBitmap = BitmapFactory.decodeFile(srcImage.getAbsolutePath(), options); // 定义字节流 ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); int quality = 100; // 若不指定压缩后的文件大小，不压缩 if (byteSize == 0) &#123; tagBitmap.compress(Bitmap.CompressFormat.JPEG, quality, byteArrayOutputStream); &#125; else &#123; // 开始质量压缩 tagBitmap.compress(Bitmap.CompressFormat.JPEG, quality, byteArrayOutputStream); long dataSize = byteArrayOutputStream.toByteArray().length; // 文件过大，压缩质量从 60 开始 if (dataSize / byteSize &gt;= 5) &#123; quality = 60; &#125; // 质量低于 30 不压缩（压缩出来的效果太渣） while (quality &gt; 30 &amp;&amp; dataSize &gt; byteSize) &#123; quality = (int) (quality * 0.85); byteArrayOutputStream.reset(); tagBitmap.compress(Bitmap.CompressFormat.JPEG, quality, byteArrayOutputStream); dataSize = byteArrayOutputStream.toByteArray().length; &#125; &#125; // Bitmap 回收 tagBitmap.recycle(); // 输出文件 FileOutputStream fileOutputStream = new FileOutputStream(tagImage); fileOutputStream.write(byteArrayOutputStream.toByteArray()); fileOutputStream.flush(); fileOutputStream.close(); byteArrayOutputStream.close(); return tagImage; &#125; 小结，压缩图片主要分为质量压缩和尺寸压缩，质量压缩用于减少 File 文件的体积大小，尺寸压缩用于生成缩略图，降低像素来减少图片占用内存大小（后面会讲到拒绝压缩像素加载高清图）。 加载图片首先要知道 Bitmap 所占内存大小计算方式： 图片长度 x 图片宽度 x 一个像素点占用的字节数 图片的长宽我们在上面已经讲到通过尺寸压缩的方式来降低，那么接下来就如何改变一个像素点占用的字节数 降低像素点字节在 Bitmap 中有一个 Config 的属性，这个属性是用来描述每个像素被储存的大小。目前常用的 Config 有四个值：ALPHA_8、RGB_565、ARGB_4444、ARGB_8888。 config.png 其中，A 代表透明度；R 代表红色；G 代表绿色；B 代表蓝色。 ALPHA_8 表示 8 位 Alpha 位图，即 A=8，一个像素点占用 1 个字节,它没有颜色，只有透明度 ARGB_4444表示 16 位 ARGB 位图，即 A=4，R=4，G=4，B=4，一个像素点占 4+4+4+4=16 位，2 个字节 ARGB_8888表示 32 位 ARGB 位图，即 A=8，R=8，G=8，B=8，一个像素点占 8+8+8+8=32 位，4 个字节 RGB_565表示 16 位 RGB 位图，即 R=5，G=6，B=5，它没有透明度，一个像素点占 5+6+5=16 位，2个字节 有什么区别呢？最简单的，当一个颜色表现形式越多，那么画面整体的色彩就会更丰富，图片质量就会越高，当然，图片占用的储存空间也越大。Android 默认采用 ARGB_8888 ，那么我们在加载图片的时候使用 RGB_565 就能降低一半图片占用内存 BitmapFactory.Options options = new BitmapFactory.Options();options.inPreferredConfig = Bitmap.Config.RGB_565;imageView.setImageBitmap(BitmapFactory.decodeFile(tagFile.absolutePath, options)); 局部加载对于图片加载还有种情况，就是单个图片非常巨大，并且还不允许压缩。比如显示：世界地图、清明上河图、微博长图等。 那么对于这种需求，该如何做呢？ 首先不压缩，按照原图尺寸加载，那么屏幕肯定是不够大的，并且考虑到内存的情况，不可能一次性整图加载到内存中，所以肯定是局部加载，那么就需要用到一个类：BitmapRegionDecoder 至于 BitmapRegionDecoder 是啥，本文不打算讲，感兴趣的去看看鸿洋的文章 这里我直接推荐 2个 开源库，拿来就用 https://github.com/LuckyJayce/LargeImage https://github.com/davemorrissey/subsampling-scale-image-view 具体用法看看 example ，本文也不打算讲 最后图片的处理，时刻都需要注意，因为机型配置的不同，以及现场设备内存使用的情况，都有可能导致 OOM 的现象，上述提到了压缩方法，基本适用与大部分图片压缩情况。当然如果对图片画质显示有要求，使用局部加载方法。 参考： https://developer.android.com/reference/android/graphics/Bitmap https://www.jianshu.com/p/0f56f35068e2 https://blog.csdn.net/HarryWeasley/article/details/51955467 https://blog.csdn.net/lmj623565791/article/details/49300989 https://github.com/LuckyJayce/LargeImage https://github.com/davemorrissey/subsampling-scale-image-view https://github.com/Curzibn/Luban","categories":[{"name":"Android","slug":"Android","permalink":"https://imeiji.github.io/categories/Android/"}],"tags":[]},{"title":"搭建 IDEA license server 服务器","slug":"IntelliJ IDEA license server服务器搭建","date":"2018-03-24T12:30:34.000Z","updated":"2018-03-24T14:13:31.000Z","comments":true,"path":"2018/03/24/IntelliJ IDEA license server服务器搭建/","link":"","permalink":"https://imeiji.github.io/2018/03/24/IntelliJ IDEA license server服务器搭建/","excerpt":"","text":"前言若资金允许，请点击 https://www.jetbrains.com/idea/buy/ 购买正版 搭建 方法一：使用 nginx 反代 server &#123; location /idea/ &#123; proxy_pass http://idea.lanyus.com/; &#125;&#125; 然后使用 https://yourdomain.com/idea/ 即可 方法二：使用反代软件 项目地址 ： https://github.com/ilanyu/ReverseProxy 下载对应系统的二进制文件，下面以 linux-amd64 为例 wget https://github.com/ilanyu/ReverseProxy/releases/download/v1.2/ReverseProxy_linux_amd64chmod a+x ReverseProxy_linux_amd64./ReverseProxy_linux_amd64 -l &quot;0.0.0.0:8888&quot; -r http://idea.lanyus.com/ 然后使用 http://yourdomain.com:8888 即可 方法三：使用破解补丁 http://idea.lanyus.com/ 激活网址上面地址失效了可以换个试试 http://xidea.online/http://idea.singee77.com/http://idea.lanyus.com/","categories":[{"name":"VPS","slug":"VPS","permalink":"https://imeiji.github.io/categories/VPS/"}],"tags":[]},{"title":"Android NDK 入门 - 玩转 CMake","slug":"Android NDK 入门 - 玩转 CMake","date":"2018-03-17T12:30:34.000Z","updated":"2018-03-17T12:36:16.000Z","comments":true,"path":"2018/03/17/Android NDK 入门 - 玩转 CMake/","link":"","permalink":"https://imeiji.github.io/2018/03/17/Android NDK 入门 - 玩转 CMake/","excerpt":"","text":"前言在上一篇文章 Android NDK 入门 - 初探 CMake 中，学习了如何在 AS 中使用 CMake 来开发 NDK，而编写 CMakeLists.txt 构建脚本是其中一个重要的环节，今天我们就来一起学习 CMakeLists.txt 的一些应用，介绍它在下面四种场景的用法： CMakeLists.txt 文件解析 使用 Android NDK 的 API 编写 so 库 使用 so 库 CMakeLists.txt 文件解析把常用的语法说明下，关于 CMake 的语法，可以查看 官方的 API 说明 cmake_minimum_required(VERSION3.4.1)指定 CMake 最低版本 add_library(native-lib SHARED src/main/cpp/native-lib.cpp)用于向 CMake 添加依赖源文件或库，指令需传入三个参数（函数库名称、库类型、依赖源文件相对路径） 函数库名称：生成函数库的名称，决定了最终生成的共享库的名字，例如我们将共享库的名字定义为 native-lib ，那么最终生成的 so 文件将在前面加上 lib 前缀即 libnative-lib.so 或 libnative-lib.a ，但是我们在代码中加载该共享库的时候，仍然应当使用 native-lib ，也就是像下面这样 static &#123; System.loadLibrary(“native-lib”);&#125; 库类型：动态库为 SHARED ，静态库为 STATIC，我们可以指定根据源文件编译出来的是静态库还是共享库，这里简单提一下两者的区别： 静态库：以.a结尾。静态库在程序链接的时候使用，链接器会将程序中使用到函数的代码从库文件中拷贝到应用程序中。一旦链接完成，在执行程序的时候就不需要静态库了。 共享库：以.so结尾。在程序的链接时候并不像静态库那样在拷贝使用函数的代码，而只是作些标记。然后在程序开始启动运行的时候，动态地加载所需模块。 依赖源文件相对路径，依赖的 c/cpp 文件（相对路径），如果我们有多个源文件，那么就在后面添加文件的路径即可。 find_library(log-lib log) 用于定位 NDK 中的库 ，需传入两个参数(path变量、ndk 库名称) ，具体有哪些 API 查看官网 path变量：设置 path 变量的名称，这里为 NDK 中的日志库，文件位于 $NDK/platforms/android-&lt;level&gt;/&lt;abi&gt;/usr/lib ndk 库名称：指定 cmake 查询库的名称，即在 ndk 开发包中查询 liblog.so 函数库，将其路径赋值给 log-lib target_link_libraries(native-lib source1 source2 ... sourceN) 要将预构建库关联到您自己的原生库，需传入至少两个参数(指定目标库、链接的库) 指定目标库：与上面 add_library 指定的函数库名一致 链接的库：可链接 add_library ，find_library 中的库，其中 find_library 的库要填写变量 ${log-lib} include_directories(src/main/cpp/include/) 为了确保 CMake 可以在编译时定位您的标头文件，填写头文件路径 ​ 使用 Android NDK 的 API在 Android 系统当中，预制了一些标准的 NDK 库，这些库函数的目的就是让开发者能够在原生方法中实现之前在 Java 层开发的一些功能，我们可以通过 NDK 库 查找所需要的 API 。 因为这些库已经预制在系统当中了，所以如果我们要调用这些库中的函数，那么不需要将其打包到 APK 当中，所需要做的就是向 CMake 提供希望使用的库名称，并将其关联到自己的原生库，最后在原生代码中引入相应的头文件，调用方法就可以了。 下面，我们再来创建一个新项目（Including C++ support），研究 NDK 的 API。 Snipaste_2018-03-17_14-13-23.png 创建项目后，打开 CMakeLists.txt ，看到引用了 NDK 的 log 库，并链接到 native-lib Snipaste_2018-03-17_14-21-21.png 既然引用了 log 库，那我们就在 native-lib 里调用 log 库 在 MainActivity 里定义 native 接口，按 ALT+ENTER 自动生成 C 函数 public native void printByJNI(String tag, String content); 编写 printByJNI 函数 最后在 Activity 里调用 printByJNI(TAG, &quot;onCreate()&quot;); ，查看结果。本来打算再引用个 NDK 的 API，但代码很复杂 ，倒不如自己写个简单的 so 库，再玩玩 CMakeLists 的配置 。 编写 so 库观察上面的 log 库，发现引入一个 so 库需要 libxxx.so 文件和 .h 文件。OK，编写一个简单的计算器 so 库。 在 cpp 目录下创建 calc-lib ，注意要同时生成 .cpp 和 .h 文件 Snipaste_2018-03-17_14-57-20.png 在 cpp 目录下创建 include 文件夹，把 .h 文件放进去 Snipaste_2018-03-17_15-32-42.png 编写 calc-lib.h 头文件，定义方法 #ifndef CMAKEDEMO2_CALC_LIB_H#define CMAKEDEMO2_CALC_LIB_Hint add(int x, int y);int sub(int x, int y);#endif 编写 calc-lib.cpp 文件，实现方法 #include \"include/calc-lib.h\"int add(int x, int y) &#123; return x + y;&#125;int sub(int x, int y) &#123; return x - y;&#125; 编写完 calc-lib 库后，要修改 CMakeLists ，然后我们再通过 JNI 测试下我们的库是否能用 Snipaste_2018-03-17_15-39-06.png 1. add_library 增加一个库，这个上面已经说过2. include_directories 为了确保 CMake 可以在编译时定位您的标头文件3. target_link_libraries 我们想通过 native-lib 调用 calc-lib，所以链接，注意可以同时链接多个库 每次修改 CMakeLists 都需要执行 Refresh Linked C++ Project 和 Clean Project，等待 gradle 刷新完 Snipaste_2018-03-17_17-01-11.png 编写 Java 接口，然后生成 JNI 函数，再调用我们的 calc-lib 库，基本上就这样。 Snipaste_2018-03-17_15-50-04.png 最后启动 App，查看结果。 使用 so 库经过上面的折腾，我们实现了在同个 App 内调用我们编写的 so 库，那怎么让别人使用我们的 so 库，同时不公开代码呢（主要实现代码在 calc-lib.cpp 内） 继续折腾，把 so 库提取出来，导入到项目 ，然后删除 calc-lib.cpp，最后通过 native-lib 调用。 Build APK 后，在 app/build/intermediates/cmake 下会生成 so 库，我们把 libcalc-lib.so 拷贝出来 Snipaste_2018-03-17_16-21-13.png 在 app/src/main/ 下创建 jniLibs 文件夹，把 so 库复制进去 Snipaste_2018-03-17_16-25-47.png 删除 app/src/main/cpp/calc-lib.cpp Snipaste_2018-03-17_17-06-32.png 修改 CMakeLists 1. add_library 通过 IMPORTANT 标志告知 CMake 只希望将库导入到项目中2. set_target_properties $&#123;CMAKE_SOURCE_DIR&#125;表示的是 CMakeLists.txt 所在的路径，我们指定第三方 so 所在路径时，应当以这个常量为起点。 按理来说，我们应当为每种 ABI 接口提供单独的软件包，那么，我们就可以在 jinLibs 下建立多个文件夹，每个文件夹对应一种 ABI 接口类型，之后再通过 $&#123;ANDROID_ABI&#125; 来泛化这一层目录的结构，这样将有助于充分利用特定的CPU架构 执行 Refresh Linked C++ Project 和 Clean Project，等待 gradle 刷新完，最后启动 App，查看结果。 小结这篇文章简单的解释 CMakeLists 文件的配置，如何导入 Android NDK 的 API，如何链接 so 库到 JNI，如何编写和使用 so 库，接下来会继续学习 ndk-build 的方式开发 Android NDK，对比两种方式。 参考： https://www.jianshu.com/p/843cf09a1db2","categories":[{"name":"Android","slug":"Android","permalink":"https://imeiji.github.io/categories/Android/"}],"tags":[]},{"title":"Android Studio 配置 javah 和 ndk-build 快捷编译","slug":"Android Studio 配置 javah 和 ndk-build 快捷编译","date":"2018-03-16T12:30:34.000Z","updated":"2018-03-16T12:33:17.000Z","comments":true,"path":"2018/03/16/Android Studio 配置 javah 和 ndk-build 快捷编译/","link":"","permalink":"https://imeiji.github.io/2018/03/16/Android Studio 配置 javah 和 ndk-build 快捷编译/","excerpt":"","text":"前言在开发 Android NDK 的时候，如果你是用 ndk-build 的方式，当在 Java 文件定义完 native 接口，按 ALT + ENTER 并不支持自动生成 cpp 文件，而手写 cpp 又非常容易写错，所以很有必要借助 javah 自动生成 .h 头文件。然而敲打 javah 命令也不是这么简单（设置 classpath，设置输出路径 等等。。。） 配置在强大的 Android Studio 中 setting 中可以添加一些 extend tool 方便开发，今天就说下怎么配置 javah 和 ndk-build ，实现一键生成 .h 头文件，一键编译 so 库 setting 中选择 extend tool Snipaste_2018-03-16_17-34-47.png javah 配置​ Snipaste_2018-03-16_17-35-56.png Program : $JDKPath$\\bin\\javah.exe 这里配置的是 javah.exe 的路径（基本一致）$JDKPath$ 可以从右侧按钮（insert macro）中选择 Parametes : $FileClass$ 这里指的是要编译 .h 文件的 java 类 （注意这里只填写了 FileClass ，其他参数没有导入那么自定义的一些 model ，或者 Android.jar 中的类是不支持的，可以先生成 h 然后手动输入特殊的参数。 比如 Bitmap ，在 native 方法中先不传这个参数，当生成 h 文件后，手动添加一个 jobject 的参数） Working : $ModuleFileDir$\\src\\main\\java 工作路径，也是 .h 生成的路径 ndk-build 配置​ Snipaste_2018-03-16_17-36-10.png Program : C:\\Users\\xxx\\AppData\\Local\\Android\\Sdk\\ndk-bundle\\ndk-build.cmd 这里配置的是 ndk 下的 ndk-build.cmd 的路径，在你本地的 ndk-bundle 下 Parametes : 这里不需要参数 Working : $ModuleFileDir$\\src\\main 工作路径 测试Javah : 选中要生成 .h 的文件，右键 -&gt; javah 就会看到有.h文件生成 ndk-build : 选中 jni 文件夹，然后点击 右键 -&gt; ndk-build 会在 main 下生成一个 obj 目录，里面会生成 libxxx.so","categories":[{"name":"Android","slug":"Android","permalink":"https://imeiji.github.io/categories/Android/"}],"tags":[]},{"title":"Android NDK 入门 - 初探 CMake","slug":"Android NDK 入门 - 初探 CMake","date":"2018-03-15T13:16:34.000Z","updated":"2018-03-15T13:10:28.000Z","comments":true,"path":"2018/03/15/Android NDK 入门 - 初探 CMake/","link":"","permalink":"https://imeiji.github.io/2018/03/15/Android NDK 入门 - 初探 CMake/","excerpt":"","text":"概念 NDK Native Development Kit（NDK）是一系列工具的集合。它提供了一系列的工具，帮助开发者快速开发 C/C++ 的动态库，并能自动将 so 和 Java 一起打包成 apk JNI Java Native Interface（JNI）标准是 Java 平台的一部分，JNI 是 Java 语言提供的 Java 和 C/C++ 相互沟通的机制，Java可以通过 JNI 调用 C/C++ 代码，C/C++ 的代码也可以调用 Java 代码，JNI 是属于 Java 的，与 Android 无直接关系 JNI 与 NDK 的关系 NDK 可以为我们生成了 C/C++ 的动态链接库，JNI 是 Java 和 C/C++ 沟通的接口，两者与 Android 没有半毛钱关系，只因为安卓是 Java 程序语言开发，然后通过 JNI 又能与 C/C++ 沟通，所以我们可以使用 NDK+JNI 来实现 Java+C 的开发方式 为什么要NDK开发 NDK开发具有以下优点： 项目需要调用底层的一些 C/C++ 的一些东西（Java无法直接访问到操作系统底层（如系统硬件等）），或者已经在 C/C++ 环境下实现了功能代码（大部分现存的开源库都是用 C/C++ 代码编写的。），直接使用即可。NDK开发常用于驱动开发、无线热点共享、数学运算、实时渲染的游戏、音视频处理、文件压缩、人脸识别、图片处理等。 为了效率更加高效些。将要求高性能的应用逻辑使用 C/C++ 开发，从而提高应用程序的执行效率。但是 C/C++ 代码虽然是高效的，在 Java 与 C/C++ 相互调用时却增大了开销； 基于安全性的考虑。防止代码被反编译，为了安全起见，使用 C/C++ 语言来编写重要的部分以增大系统的安全性，最后生成 so 库（用过第三方库的应该都不陌生）便于给人提供方便。（任何有效的代码混淆对于会 smail 语法反编译你 apk 是分分钟的事，即使你加壳也不能幸免高手的攻击） 便于移植。用 C/C++ 写得库可以方便在其他的嵌入式平台上再次使用。 开发方式在Eclipse的时代，我们进行NDK的开发一般需要通过手动执行NDK脚本生成*.so文件，再将.so文件放到对应的目录之后，之后再进行打包。 而如果使用的是Android Studio进行NDK开发，在2.2的版本以后，我们可以不需要手动地运行NDK脚本来生成*.so文件，而是将这一过程作为Gradle构建过程的依赖项，事先编写好编译的脚本文件，然后在build.gradle中指定编译脚本文件的路径就可以一次性完成生成原生库并打包成APK的过程。 目前这种AS + Gradle的NDK开发方式又可以分为三种：ndk-build、CMake和Experimental Gradle： ndk-build：和上面谈到的传统方式相比，它们两个的目录结构相同，Gradle脚本其实最终还是依赖于Android.mk文件，对于使用传统方式的项目来说，比较容易过度。 CMake：Gradle脚本依赖的是CMakeLists.txt文件。 Experimental Gradle：需要引入实验性的gradle插件，全部的配置都可以通过build.gradle来完成，不再需要编写Android.mk或者CMakeLists.txt，可能坑比较多，对于旧的项目来说过度困难。 目前，Android Studio已经将CMake作为默认的NDK实现方式，并且官网上对于NDK的介绍也是基于CMake，声称要永久支持。按照官方的教程使用下来，感觉这种方式有几点好处： 不需要再去通过javah根据java文件生成头文件，并根据头文件生成的函数声明编写cpp文件 当在Java文件中定义完native接口，可以在cpp文件中自动生成对应的native函数，所需要做的只是补全函数体中的内容 不需要手动执行ndk-build命令得到so，再将so拷贝到对应的目录 在编写cpp文件的过程中，可以有提示了 CMakeLists.txt要比Android.mk更加容易理解 搭建 NDK 环境在新建项目之前，我们需要通过SDK Manager安装一些必要的组件： NDK CMake LLDB image_2018-03-15_14-52-36.png 创建支持 C/C++ 的新项目在安装完必要的组件之后，我们创建一个全新的工程，这里需要记得勾选include C++ Support选项： Snipaste_2018-03-15_14-56-05.png 接下来一路Next，在最后一步我们会看见如下的几个选项，它们的含义为： C++ Standard：选择C++的标准，Toolchain Default表示使用默认的CMake配置，这里我们选择默认。 Excptions Support：如果您希望启用对C++异常处理的支持，请选中此复选框。如果启用此复选框，Android Studio会将-fexceptions标志添加到模块级 build.gradle文件的cppFlags中，Gradle会将其传递到CMake。 Runtime Type information Support：如果您希望支持RTTI，请选中此复选框。如果启用此复选框，Android Studio会将-frtti标志添加到模块级 build.gradle文件的cppFlags中，Gradle会将其传递到CMake Snipaste_2018-03-15_14-57-56.png 在新建工程完毕之后，我们得到的工程的结构如下图所示： Snipaste_2018-03-15_15-03-32.png 与传统的工程相比，它有如下几点区别： (1) cpp 文件夹 用于存放C/C++的源文件，在磁盘上对应于app/src/main/cpp文件夹，当新建工程时，它会生成一个native-lib.cpp的事例文件，其内容如下： Snipaste_2018-03-15_15-21-52.png (2) 增加 CMakeList.txt 脚本 构建脚本，在磁盘上对应于app/目录下的txt文件，其内容为如下图所示，这里面涉及到的CMake语法包括下面四种，关于CMake的语法，可以查看 官方的 API 说明 cmake_minimum_required add_library find_library target_link_libraries # 设置最低版本cmake_minimum_required(VERSION 3.4.1)# 添加库add_library( # 库名 native-lib # 设置 SHARED or STATIC SHARED # 库文件 src/main/cpp/native-lib.cpp )find_library( # Sets the name of the path variable. log-lib # Specifies the name of the NDK library that # you want CMake to locate. log )target_link_libraries( # Specifies the target library. native-lib # Links the target library to the log library # included in the NDK. $&#123;log-lib&#125; ) (3) build.gradle 脚本 与传统的项目相比，该模块所对应的build.gradle需要在里面指定CMakeList.txt所在的路径，也就是下面externalNativeBuild对应的选项。 Snipaste_2018-03-15_15-07-09.png (4) 打印字符串 在MainActivity中，我们加载原生库，并调用原生库中的方法获取了一个字符串展示在界面上： Snipaste_2018-03-15_15-22-17.png (5) 运行结果 最后，我们运行一下这个工程，会得到下面的结果： Snipaste_2018-03-15_15-25-59.png 通过查看 app/build/cmake/debug 路径和 APK Analyzer 工具，我们可以看到在APK当中，增加了libnative-lib.so文件： Snipaste_2018-03-15_15-30-24.png 原理下面，我们来解释一下这一过程： 首先，在构建时，通过build.gradle中path所指定的路径，找到CMakeList.txt，解析其中的内容。 按照脚本中的命令，将src/main/cpp/native-lib.cpp编译到共享的对象库中，并将其命名为libnative-lib.so，随后打包到APK中。 当应用运行时，首先会执行MainActivity的static代码块的内容，使用System.loadLibrary()加载原生库。 在onCreate()函数中，调用原生库的函数得到字符串并展示。 小结当通过CMake来对应用程序增加C/C++的支持时，对于应用程序的开发者，只需要关注以下三个方面： C/C++源文件 CMakeLists.txt脚本 在模块级别的build.gradle中通过externalNativeBuild/cmake进行配置 向现有项目添加 C/C++ 代码 如果您希望向现有项目添加原生代码，请执行以下步骤： 创建新的原生源文件 在 app/src/ 目录下新建个文件夹，为目录输入一个名称（例如 cpp）并点击 OK， 右键点击您刚刚创建的目录，然后选择 New &gt; C/C++ Source File，为您的源文件输入一个名称，例如 calc-lib，从 Type 下拉菜单中，为您的源文件选择文件扩展名，例如 .cpp，点击 OK 完成。 ​ 创建 CMake 构建脚本 在app根目录下新建一个CMakeLists.txt文件 cmake_minimum_required(VERSION 3.4.1)# 库名 库类型 源文件add_library(calc-lib SHARED src/main/cpp/calc-lib.cpp)# 为了确保 CMake 可以在编译时定位您的标头文件include_directories(src/main/cpp/) 将 Gradle 关联到您的原生库 之后，我们需要让Gradle脚本确定CMakeLists.txt所在的位置，我们可以在CMakeLists.txt上点击右键，之后选择Link C++ Project with Gradle： 那么在该模块下的 build.gradle 就会新增下面这句，在这步完成之后，我们选择 Build -&gt; Clean Project android &#123; ... externalNativeBuild &#123; cmake &#123; path &apos;CMakeLists.txt&apos; &#125; &#125;&#125; 等 Gradle 刷新完毕，cpp 文件夹会变蓝色 编写代码 MainActivity.java public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ··· Log.d(TAG, &quot;onCreate: &quot; + sum(1, 2)); &#125; static &#123; System.loadLibrary(&quot;calc-lib&quot;); &#125; public native int sum(int x, int y);&#125; 我们定义 native 接口的地方，多出了一个选项，它可以帮助我们直接在对应的 C++ 文件中生成函数的定义： 点击 Create function 之后，AS 帮我们的生成大部分代码，我们只需要实现函数即可： 如果 AS 帮我们生成的代码不是在你的 cpp 文件夹内（在 /src/main/jni），我们只需要把代码复制到 calc-lib.cpp ，下次再定义 native 接口，点击 Create function 之后，位置就无误了。 控制生成平台 so 库默认情况下，Gradle 会针对 NDK 支持的 ABI 将您的原生库构建到单独的 .so 文件中，并将其全部打包到您的 APK 中。如果您希望 Gradle 仅构建和打包原生库的特定 ABI 配置，您可以在模块级 build.gradle 文件中使用 ndk.abiFilters 标志指定这些配置，如下所示： android &#123; ... defaultConfig &#123; ... externalNativeBuild &#123; cmake &#123;...&#125; // or ndkBuild &#123;...&#125; &#125; ndk &#123; // Specifies the ABI configurations of your native // libraries Gradle should build and package with your APK. abiFilters &apos;x86&apos;, &apos;x86_64&apos;, &apos;armeabi&apos;, &apos;armeabi-v7a&apos;, &apos;arm64-v8a&apos; &#125; &#125; buildTypes &#123;...&#125; externalNativeBuild &#123;...&#125;&#125; 小结以上就是使用Android Studio 3.0版本，通过CMake来进行NDK开发的一个简单例子，主要是学习一下开发的流程，下一篇文章，要学习一下CMakeLists.txt中的语法。 参考： https://www.jianshu.com/p/716641d15ee8 https://developer.android.com/studio/projects/add-native-code.html","categories":[{"name":"Android","slug":"Android","permalink":"https://imeiji.github.io/categories/Android/"}],"tags":[]},{"title":"在VPS中利用vlmcsd搭建KMS激活服务器","slug":"利用vlmcsd搭建KMS激活服务器","date":"2018-02-08T13:16:34.000Z","updated":"2018-02-07T13:19:20.000Z","comments":true,"path":"2018/02/08/利用vlmcsd搭建KMS激活服务器/","link":"","permalink":"https://imeiji.github.io/2018/02/08/利用vlmcsd搭建KMS激活服务器/","excerpt":"","text":"如今我们经常会使用 KMS 对我们的 Windows/Office 进行激活，不过市面上流通着不少良莠不齐的 KMS 激活软件。其实，我们完全可以利用手中的闲置 VPS 资源，利用 vlmcsd 搭建KMS 激活服务器。声明仅 VOL 版本的 Windows/Office 支持此 KMS 激活，请先确认自己安装的非 Retail 零售版。 搭建服务器首先需要一台 VPS，在上面搭建 vlmcsd 服务端 下载最新版，查看最新版本 https://github.com/Wind4/vlmcsd/releases wget https://github.com/Wind4/vlmcsd/releases/download/svn1111/binaries.tar.gz 解压并查看 tar -zxvf binaries.tar.gzcd binaries/Linux/intel/static/ls 挑选适合自己系统的版本，我们能看到适配各个系统的版本，vlmcsd-x64-musl-static 或vlmcsd-x86-musl-static（根据你 VPS 的系统为 x86 或 x64 系统而定）。 接着以 x64 为例子： chmod u+x vlmcsd-x64-musl-static./vlmcsd-x64-musl-static 至此，已经部署完毕 如果你的 VPS 开启了 iptables ，记得开启 1688 端口的 tcp 传输： iptables -I INPUT 5 -p tcp -m state --state NEW -m tcp --dport 1688 -j ACCEPT 开机自启 vi /etc/rc.localcd ~/binaries/Linux/intel/static/ &amp;&amp; ./vlmcsd-x64-musl-static 本地测试本地测试这里仅以本地为 Windows 环境为例 下载 https://github.com/Wind4/vlmcsd/releases ，并解压 进入\\binaries\\Windows\\intel 目录，开启 PowerShell 或者其他终端 根据你本地的 Windows 为 x86 或 x64，输入如下命令： ./vlmcs-Windows-x86.exe -v -l 3 你的VPS的IP或者绑定的域名 或 ./vlmcs-Windows-x64.exe -v -l 3 你的VPS的IP或者绑定的域名 其中 -l 3表示发送 Windows 10 Enterprise 2016 LTSB 的激活请求，具体版本对应列表可以通过 ./vlmcs-Windows-x64.exe -x 查看 如果显示如下，那么就搭建成功了。 激活 激活 Windows 以管理员身份打开命令提示符，然执行下列命令： cd /d &quot;%SystemRoot%\\system32&quot;slmgr /skms 你的VPS的IP或者绑定的域名slmgr /atoslmgr /xpr 激活 Office 以管理员身份打开命令提示符，进入软件安装目录，然后执行下列命令： 这里以 Office 2013 为例： 进入32位版本安装目录：cd /d &quot;%ProgramFiles(x86)%\\Microsoft Office\\Office15 进入64位版本安装目录：cd /d &quot;%ProgramFiles%\\Microsoft Office\\Office15 然后执行下列命令 cscript ospp.vbs /sethst:你的VPS的IP或者绑定的域名cscript ospp.vbs /actcscript ospp.vbs /dstatus 题外话 Windows VOL 版本可以从 http://msdn.itellyou.cn/ 这里下载 Office VOL 版本可以从 https://landian.la/click/OfficeToolPlus.html 这里下载 VOL 版本的镜像一般内置 GVLK key，用于 KMS 激活。如果你手动输过其他 key，那么这个内置的 key 就会被替换掉，这个时候如果你想用 KMS，那么就需要把 GVLK key 输回去。首先，到 https://technet.microsoft.com/en-us/library/jj612867.aspx 获取你对应版本的 key 如果不知道自己的系统是什么版本，可以运行以下命令查看系统版本： wmic os get caption 得到对应key之后，使用管理员权限运行cmd执行安装key： slmgr /ipk xxxxx-xxxxx-xxxxx-xxxxx 然后跟上面说的一样设置 KMS 服务器地址，激活。 KMS 方式激活的有效期只有180天，每隔一段时间系统会自动请求 KMS 服务器续期，只要你的服务器正常，续期就没问题 参考： https://luodaoyi.com/kms.html https://yorkchou.com/vlmcsd.html","categories":[{"name":"VPS","slug":"VPS","permalink":"https://imeiji.github.io/categories/VPS/"}],"tags":[]},{"title":"Git 备忘录","slug":"Git 备忘录","date":"2018-02-01T11:16:34.000Z","updated":"2019-09-29T15:30:20.687Z","comments":true,"path":"2018/02/01/Git 备忘录/","link":"","permalink":"https://imeiji.github.io/2018/02/01/Git 备忘录/","excerpt":"","text":"设置用户信息Git 要求使用者必须提供自己的身份标识，为此我们需要在 Git bash中执行以下命令（当然不设置也行，每次提交都是 unknown… macOS 貌似会提交系统用户名）： //给自己起个用户名git config --global user.name &quot;name&quot; //填写自己的邮箱git config --global user.email &quot;abc@gmail.com&quot; 检查旧密钥生成密钥之前先检测是否存在旧密钥 # Windows 目录在 C:\\Users\\user\\.sshls -al ~/.ssh# Lists the files in your .ssh directory, if they exist 默认情况下，公钥的文件名是以下之一 id_dsa.pub id_ecdsa.pub id_ed25519.pub id_rsa.pub 如果你没有现有的公钥和私钥对，或者不希望使用任何可用于连接到 Github 的公钥和私钥，请生成一个新的 ssh 密钥 如果您看到列出的现有公钥和私钥对（例如 id_rsa.pub 和 id_rsa ），那么你可以将 ssh 密钥添加到 ssh-agent 中 生成密钥以下步骤可能会过时，可参考 https://help.github.com/articles/connecting-to-github-with-ssh/ 获取更详细步骤 GitHub 选择的默认通信方式是 SSH，如果没有配置 SSH key 就只能 clone 代码不能 push 上去（只读），所以要先在 git 里面生成 SHH Key。如果在当前用户的第一级文件夹下有 .ssh 文件夹，说明以前可能使用过 git，把该文件夹删除（或者先备份再删除，防止意外）。 获得密钥： ssh-keygen -t rsa -b 4096 -C &quot;i@gmail.com&quot; 添加密钥到 ssh-agent添加刚刚生成的证书 确保ssh-agent正在运行 # start the ssh-agent in the backgroundeval $(ssh-agent -s)Agent pid 59566 添加证书 ssh-add ~/.ssh/id_rsa 添加密钥到 GitHub 将 ssh 密钥复制到剪贴板 pbcopy &lt; ~/.ssh/id_rsa.pub# Copies the contents of the id_rsa.pub file to your clipboard 打开 Settings，在用户设置边栏中，单击 SSH and GPG keys ，单击 New SSH key or Add SSH key ，”Title” 随意填写，如“Personal MacBook Pro”，“Key” 填写刚刚复制过的文本，直接粘贴 最后测试下 ssh -T git@github.com 提示像我这样：Hi XXX! You’ve successfully authenticated, but GitHub does not provide shell access. 那就说明连接成功了。 设置代理git config --global http.proxy &apos;socks5://127.0.0.1:1080&apos;git config --global https.proxy &apos;socks5://127.0.0.1:1080&apos;# 取消代理git config --global --unset http.proxygit config --global --unset https.proxy 隐藏 commits 记录的邮箱地址如果你想隐藏你的 git log 中的邮箱，但同时 contributions 也不会消失，那么可以采取以下的方法 去 设置页面 勾选 Keep my email address private 这时候，会给你一个的电子邮件 yourusername@users.noreply.github.com 供你用于你的 Git 提交。 更改本地 git config 中的 user.email git config --global user.email \"yourusername@users.noreply.github.com\" git config --global user.email 使用脚本更改 Git 仓库的 commits 历史记录 打开 Git Bash 克隆你要修改的 repo git clone --bare https://github.com/user/repo.gitcd repo.git 复制以下脚本，填写好信息，然后执行脚本 #!/bin/shgit filter-branch --env-filter 'OLD_EMAIL=\"填写你的旧邮箱\"CORRECT_NAME=\"填写你的 Github 用户名\"CORRECT_EMAIL=\"填写新邮箱\"if [ \"$GIT_COMMITTER_EMAIL\" = \"$OLD_EMAIL\" ]then export GIT_COMMITTER_NAME=\"$CORRECT_NAME\" export GIT_COMMITTER_EMAIL=\"$CORRECT_EMAIL\"fiif [ \"$GIT_AUTHOR_EMAIL\" = \"$OLD_EMAIL\" ]then export GIT_AUTHOR_NAME=\"$CORRECT_NAME\" export GIT_AUTHOR_EMAIL=\"$CORRECT_EMAIL\"fi' --tag-name-filter cat -- --branches --tags 运行脚本，等待完成 提交历史 git push --force --tags origin &#39;refs/heads/*&#39; 完成，可以删除 repo 参考： https://help.github.com/articles/connecting-to-github-with-ssh/ https://saraford.net/2017/02/19/how-to-hide-your-email-address-in-your-git-commits-but-still-get-contributions-to-show-up-on-your-github-profile-050/","categories":[{"name":"Git","slug":"Git","permalink":"https://imeiji.github.io/categories/Git/"}],"tags":[]},{"title":"compileSdkVersion、buildToolsVersion、minSdkVersion、targetSdkVersion 的区别","slug":"compileSdkVersion、buildToolsVersion、minSdkVersion、targetSdkV","date":"2017-11-15T06:16:34.000Z","updated":"2017-11-15T06:45:04.000Z","comments":true,"path":"2017/11/15/compileSdkVersion、buildToolsVersion、minSdkVersion、targetSdkV/","link":"","permalink":"https://imeiji.github.io/2017/11/15/compileSdkVersion、buildToolsVersion、minSdkVersion、targetSdkV/","excerpt":"","text":"compileSdkVersioncompileSdkVersion 告诉 Gradle 用哪个 Android SDK 版本编译你的应用。使用任何新添加的 API 就需要使用对应 Level 的 Android SDK。 需要强调的是修改 compileSdkVersion 不会改变运行时的行为。当你修改了 compileSdkVersion 的时候，可能会出现新的编译警告、编译错误，但新的 compileSdkVersion 不会被包含到 APK 中：它纯粹只是在编译的时候使用。（你真的应该修复这些警告，他们的出现一定是有原因的） 因此我们强烈推荐总是使用最新的 SDK 进行编译。在现有代码上使用新的编译检查可以获得很多好处，避免新弃用的 API ，并且为使用新的 API 做好准备。 注意，如果使用 Support Library ，那么使用最新发布的 Support Library 就需要使用最新的 SDK 编译。例如，要使用 23.1.1 版本的 Support Library ，compileSdkVersion 就必需至少是 23 （大版本号要一致！）。通常，新版的 Support Library 随着新的系统版本而发布，它为系统新增加的 API 和新特性提供兼容性支持。 buildToolsVersion表示：构建工具的版本，其中包括了打包工具aapt、dx等等。你应该使用最新版本的来构建。 这个版本号一般是 API-LEVEL.0.0 。 例如 I/O 2017 大会上发布了 API 26 对应的 build-tool 的版本就是 26.0.0 ，在这之间可能有小版本，例如 26.0.2 等等。 minSdkVersion如果 compileSdkVersion 设置为可用的最新 API，那么 minSdkVersion 则是应用可以运行的最低要求。minSdkVersion 是 Google Play 商店用来判断用户设备是否可以安装某个应用的标志之一。 在开发时 minSdkVersion 也起到一个重要角色：lint 默认会在项目中运行，它在你使用了高于 minSdkVersion 的 API 时会警告你，帮你避免调用不存在的 API 的运行时问题。如果只在较高版本的系统上才使用某些 API，通常使用运行时检查系统版本的方式解决。 请记住，你所使用的库，如 Support Library 或 Google Play services，可能有他们自己的 minSdkVersion 。你的应用设置的 minSdkVersion 必需大于等于这些库的 minSdkVersion 。例如有三个库，它们的 minSdkVersion 分别是 4, 7 和 9 ，那么你的 minSdkVersion 必需至少是 9 才能使用它们。在少数情况下，你仍然想用一个比你应用的 minSdkVersion 还高的库（处理所有的边缘情况，确保它只在较新的平台上使用），你可以使用 tools:overrideLibrary 标记，但请做彻底的测试！ 当你决定使用什么 minSdkVersion 时候，你应该参考当前的 Android 分布统计，它显示了最近 7 天所有访问 Google Play 的设备信息。他们就是你把应用发布到 Google Play 时的潜在用户。最终这是一个商业决策问题，取决于为了支持额外 3% 的设备，确保最佳体验而付出的开发和测试成本是否值得。 当然，如果某个新的 API 是你整个应用的关键，那么确定 minSdkVersion 的值就比较容易了。不过要记得 14 亿设备中的 0.7％ 也是个不小的数字。 targetSdkVersion三个版本号中最有趣的就是 targetSdkVersion 了。 targetSdkVersion 是 Android 提供向前兼容的主要依据，在应用的 targetSdkVersion 没有更新之前系统不会应用最新的行为变化。这允许你在适应新的行为变化之前就可以使用新的 API （因为你已经更新了 compileSdkVersion 不是吗？）。 targetSdkVersion 所暗示的许多行为变化都记录在 VERSION_CODES 文档中了，但是所有恐怖的细节也都列在每次发布的平台亮点中了，在这个 API Level 表中可以方便地找到相应的链接。 例如，Android 6.0 变化文档中谈了 target 为 API 23 时会如何把你的应用转换到运行时权限模型上，Android 4.4 行为变化阐述了 target 为 API 19 及以上时使用 set() 和 setRepeating() 设置 alarm 会有怎样的行为变化。 由于某些行为的变化对用户是非常明显的（弃用的 menu 按钮，运行时权限等），所以将 target 更新为最新的 SDK 是所有应用都应该优先处理的事情。但这不意味着你一定要使用所有新引入的功能，也不意味着你可以不做任何测试就盲目地更新 targetSdkVersion ，请一定在更新 targetSdkVersion 之前做测试！你的用户会感谢你的。 综合来看如果你按照上面示例那样配置，你会发现这三个值的关系是：minSdkVersion &lt;= targetSdkVersion &lt;= compileSdkVersion 这种直觉是合理的，如果 compileSdkVersion 是你的最大值，minSdkVersion 是最小值，那么最大值必需至少和最小值一样大且 target 必需在二者之间。 理想上，在稳定状态下三者的关系应该更像这样：minSdkVersion (lowest possible) &lt;= targetSdkVersion == compileSdkVersion (latest SDK) 用较低的 minSdkVersion 来覆盖最大的人群，用最新的 SDK 设置 target 和 compile 来获得最好的外观和行为。 参考 如何选择 compileSdkVersion, minSdkVersion 和 targetSdkVersion","categories":[{"name":"Android","slug":"Android","permalink":"https://imeiji.github.io/categories/Android/"}],"tags":[]},{"title":"Android App 启动页面最佳实现","slug":"Android App 启动页面最佳实现","date":"2017-11-13T09:16:34.000Z","updated":"2017-11-15T06:44:07.000Z","comments":true,"path":"2017/11/13/Android App 启动页面最佳实现/","link":"","permalink":"https://imeiji.github.io/2017/11/13/Android App 启动页面最佳实现/","excerpt":"","text":"什么是App启动屏幕App 启动页 (Splash)，最经典的莫过于微信的启动页了 首次启动出现一个地球界面，然后才进入主界面，这是因为从桌面点击 App 图标启动应用开始，程序会显示一个启动界面等待 Activity 的创建加载完毕再进行显示 再次启动微信，发现并不会出现地球界面，而是直接进入主界面，这是因为微信并没有完全退出(在后台运行) 来看一下 Google 官方文档《Launch-Time Performance》对应用启动方式的概述： 启动方式冷启动冷启动指的是应用程序从头开始：系统的进程没有，直到此开始，创建了应用程序的进程。 在应用程序自设备启动以来第一次启动或系统杀死应用程序等情况下会发生冷启动。 这种类型的启动在最小化启动时间方面是最大的挑战，因为系统和应用程序比其他启动状态具有更多的工作。 cold-launch.png 热启动与冷启动相比，热启动应用程序要简单得多，开销更低。在热启动，系统会把你活动放到前台，如果所有应用程序的活动仍驻留在内存中，那么应用程序可以避免重复对象初始化，UI的布局和渲染。热启动显示与冷启动场景相同的屏幕行为：系统进程显示空白屏幕，直到应用程序完成呈现活动。 温启动用户退出您的应用，但随后重新启动。该过程可能已继续运行，但应用程序必须通过调用 onCreate() 从头开始重新创建活动。系统从内存中驱逐您的应用程序，然后用户重新启动它。进程和Activity需要重新启动，但任务可以从保存的实例状态包传递到 onCreate() 中。 为什么出现白屏冷启动白屏持续时间可能会很长，这可是个槽糕的体验，它的启动速度是由于以下引起的：1、Application 的 onCreate 流程，对于大型的 App 来说，通常会在这里做大量的通用组件的初始化操作；建议：很多第三方SDK都放在Application初始化，我们可以放到用到的地方才进行初始化操作。 2、Activity 的 onCreate() 流程，特别是UI的布局与渲染操作，如果布局过于复杂很可能导致严重的启动性能问题；建议：Activity 仅初始化那些立即需要的对象，xml布局减少冗余或嵌套布局。 优化APP启动速度意义重大，启动时间过长，可能会使用户直接卸载 App 。 优化方案优化方案主要是从主题切换的方向着手： 直接干掉既然有这个 Activity 启动界面，那能不能直接不要这个呢，当然是可以：定义一个 style ： &lt;style name=\"SplashTheme\"&gt; &lt;!--关闭启动窗口--&gt; &lt;item name=\"android:windowDisablePreview\"&gt;true&lt;/item&gt;&lt;/style&gt; 在 manifest 修改启动页面的主题： &lt;activity android:name=\".SplashActivity\" android:label=\"@string/app_name\" android:theme=\"@style/SplashTheme\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\"/&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; SplashActivity 代码： public class SplashActivity extends AppCompatActivity &#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Intent intent = new Intent(this, MainActivity.class); startActivity(intent); finish(); &#125;&#125; 这样启动 App，就没有白屏，但会出现点击桌面图标而半天没有反应的现象，显然不好，据我所知 Inoreader (版本5.3) 就是采用这种方法。 Material Design其实 Google 针对 App 闪屏，在 Material Design 规范 Launch screens，也给出了非常详细的设计定义，有两种方案： 品牌展示 patterns-launch-screens-01.png 屏幕提供短暂的品牌曝光，来看看如何实现的，定义一个 style ： &lt;style name=\"SplashTheme\"&gt; &lt;item name=\"android:windowBackground\"&gt;@drawable/branded_launch_screens&lt;/item&gt;&lt;/style&gt; 新建 drawable/branded_launch_screens &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\" android:opacity=\"opaque\"&gt; &lt;!--黑色背景颜色--&gt; &lt;item android:drawable=\"@android:color/black\" /&gt; &lt;!-- 产品logo--&gt; &lt;item&gt; &lt;bitmap android:gravity=\"center\" android:src=\"@mipmap/empty_image01\" /&gt; &lt;/item&gt; &lt;!-- 右上角的图标元素 --&gt; &lt;item&gt; &lt;bitmap android:gravity=\"top|right\" android:src=\"@mipmap/github\" /&gt; &lt;/item&gt; &lt;!--最下面的文字--&gt; &lt;item android:bottom=\"50dp\"&gt; &lt;bitmap android:gravity=\"bottom\" android:src=\"@mipmap/ic_launcher\" /&gt; &lt;/item&gt;&lt;/layer-list&gt; 其中 android:opacity=”opaque” 参数是为了防止在启动的时候出现背景的闪烁。关于 layer-list 介绍，见博客：用 layer-list 实现图片旋转叠加、错位叠加、阴影、按钮指示灯 。同样需要在 manifest 修改启动页面的主题。微信、YouTube 就是采用这种方式。 主页预加载 patterns-launch-screens-03.png 使用与主界面 UI 一致的占位内容，给用户感觉已经在加载中了，这里模拟了一个高度为 25dp 的状态栏和一个高度为 56dp 的标题栏，定义一个style： &lt;style name=\"SplashTheme\"&gt; &lt;item name=\"android:windowBackground\"&gt;@drawable/placeholder_ui&lt;/item&gt;&lt;/style&gt; 新建 drawable/placeholder_ui &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\" android:opacity=\"opaque\"&gt; &lt;!--状态栏颜色--&gt; &lt;item android:drawable=\"@color/colorPrimaryDark\" /&gt; &lt;!--假装这里是个toolbar--&gt; &lt;item android:drawable=\"@color/colorPrimary\" android:top=\"25dp\" /&gt; &lt;!--状态栏25+toolbar56=距离top81--&gt; &lt;item android:drawable=\"@android:color/white\" android:top=\"81dp\" /&gt;&lt;/layer-list&gt; 同样需要在 manifest 修改启动页面的主题。据我所知，V2EX+ 就是采用这种方法。 注意的问题以上的优化方案基本实现了启动页的基本功能，不过还是有一些小的问题需要注意的。 只显示一次启动页（ App 没被 kill 的情况下） 微信打开之后，按下返回键回到桌面，再打开微信，并不会再看到启动页（除非你手动清了微信的后台或者被系统 kill 了），这个是怎么实现的呢？ 其实很简单，只需要重写一下 MainActivity 的 onBackPressed() 方法就行。 @Overridepublic void onBackPressed() &#123; // super.onBackPressed(); 不要调用父类的方法 Intent intent = new Intent(Intent.ACTION_MAIN); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); intent.addCategory(Intent.CATEGORY_HOME); startActivity(intent); // 或者直接使用 moveTaskToBack(true);&#125; 以上就实现了和微信一样的效果，按返回键不关闭 MainActivity（好恶心的做法~~） 参考： Android APP启动优化","categories":[{"name":"Android","slug":"Android","permalink":"https://imeiji.github.io/categories/Android/"}],"tags":[]},{"title":"Android 仿知乎分享控件","slug":"Android 仿知乎分享控件","date":"2017-10-02T06:10:54.000Z","updated":"2017-10-02T10:22:47.000Z","comments":true,"path":"2017/10/02/Android 仿知乎分享控件/","link":"","permalink":"https://imeiji.github.io/2017/10/02/Android 仿知乎分享控件/","excerpt":"","text":"使用 BottomSheetDialog 实现仿知乎分享控件主要步骤： 首先获取手机内所有支持分享的应用，得到 ResolveInfo 对象，利用反射获取应用图标等信息 然后用 RecyclerView 的 GridLayoutManager 网格布局展示，自己实现点击事件就差不多完成了 截图 1.png 简单实现 写一个分享界面的布局 &lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:padding=\"16dp\" android:text=\"我是广告栏\" android:textAppearance=\"@style/TextAppearance.AppCompat\" android:textSize=\"18sp\"/&gt; &lt;View android:layout_width=\"match_parent\" android:layout_height=\"1px\" android:background=\"@android:color/darker_gray\"/&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/list_view\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"/&gt;&lt;/LinearLayout&gt; 在 Activity 里使用 BottomSheetDialog 控件显示 BottomSheetDialog mBottomSheetDialog = new BottomSheetDialog(this);mBottomSheetDialog.setContentView(R.layout.dialog_bottom_sheet);mBottomSheetDialog.show(); 写一个 RecyclerViewAdapter 和 appinfo_item 布局 &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center&quot; android:orientation=&quot;vertical&quot;&gt; &lt;ImageView android:id=&quot;@+id/img_list_item&quot; android:layout_width=&quot;48dp&quot; android:layout_height=&quot;48dp&quot; android:scaleType=&quot;centerCrop&quot; tools:src=&quot;@mipmap/ic_launcher&quot;/&gt; &lt;TextView android:id=&quot;@+id/text_list_item&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;2dp&quot; android:ellipsize=&quot;end&quot; android:singleLine=&quot;true&quot; tools:text=&quot;分享11111111111111&quot;/&gt;&lt;/LinearLayout&gt; 获取手机内所有支持分享的应用列表 public static List&lt;ResolveInfo&gt; getShareApps(Context context, Intent intent) &#123; List&lt;ResolveInfo&gt; resolveInfoList; PackageManager pm = context.getPackageManager(); resolveInfoList = pm.queryIntentActivities(intent, PackageManager.COMPONENT_ENABLED_STATE_DEFAULT); return resolveInfoList; &#125; 返回数据给 Activity，然后设置 Adapter 就差不多完成，详细代码见 ZhihuShareDialog 缺点 通过 PackageManager 的 queryIntentActivities 方法获取到的应用是按照应用安装的先后顺序，而 Lollipop(5.0) 开始原生分享已支持自动把常用应用排在最顶部。当然也可以自己实现应用的排序，但比较折腾，可参考源码 ResolverActivity ​ 优点 可以自定义分享界面，比如像知乎那样添加广告栏，设计一套属于自己的 UI ，设置应用的排列顺序等等 源码下载地址 ： https://github.com/iMeiji/ZhihuShareDialog","categories":[{"name":"Android","slug":"Android","permalink":"https://imeiji.github.io/categories/Android/"}],"tags":[]},{"title":"OpenConnect VPN server","slug":"OpenConnect VPN server","date":"2017-09-16T06:10:54.000Z","updated":"2017-10-02T10:10:23.000Z","comments":true,"path":"2017/09/16/OpenConnect VPN server/","link":"","permalink":"https://imeiji.github.io/2017/09/16/OpenConnect VPN server/","excerpt":"","text":"OpenConnet Server（ocserv）是通过实现Cisco的AnyConnect协议，用DTLS作为主要的加密传输协议。我认为它的主要好处在于—— AnyConnect的VPN协议默认使用UDP DTLS作为数据传输，但如果有什么网络问题导致UDP传输出现问题，它会利用最初建立的TCP TLS通道作为备份通道，降低VPN断开的概率。 AnyConnect作为Cisco新一代的VPN解决方案，被用于许多大型企业，这些企业依赖它提供正常的商业运作，这些正常运作对应的经济效益（读作GDP），是我们最好的伙伴。 OpenConnet的架设足够麻烦，我的意思是，如果你不是大型企业，你会用AnyConnect的概率无限趋近于零。再者，如果它足够简单，我就不用写这篇文章了。至于它的自定义路由表支持，我觉得都是次要了。 介绍到此，让我们按步骤干好事情。 （下文选用 Debian8 和 ocser v0.11.8 作为标准环境） 配置环境 安装依赖 apt-get install -y build-essential pkg-config libgnutls28-dev libreadline-dev libseccomp-dev libwrap0-dev libnl-nf-3-dev liblz4-dev libev-dev autogen 编译安装 # 查看最新版本 http://www.infradead.org/ocserv/download.htmlwget ftp://ftp.infradead.org/pub/ocserv/ocserv-0.11.8.tar.xztar xvf ocserv-*.tar.xz &amp;&amp; cd ocserv-*./configure make &amp;&amp; make install &amp;&amp; cd .. 配置 OpenConnect Server 配置证书 安装证书工具 apt-get install gnutls-bincd ~ &amp;&amp; mkdir certificates &amp;&amp; cd certificates 在此目录下创建一个名为vi ca.tmpl 的CA证书模板，写入如下语句： cn = &quot;Your CA name&quot; organization = &quot;Your fancy name&quot; serial = 1 expiration_days = 3650ca signing_key cert_signing_key crl_signing_key 生成CA密钥和证书 certtool --generate-privkey --outfile ca-key.pemcerttool --generate-self-signed --load-privkey ca-key.pem --template ca.tmpl --outfile ca-cert.pem 然后我们生成服务器证书vi server.tmpl，这里注意cn 项必须对应你服务器的域名或IP，内容如下： cn = &quot;Your hostname or IP&quot; organization = &quot;Your fancy name&quot; expiration_days = 3650signing_key encryption_keytls_www_server 生成Server密钥和证书 certtool --generate-privkey --outfile server-key.pemcerttool --generate-certificate --load-privkey server-key.pem --load-ca-certificate ca-cert.pem --load-ca-privkey ca-key.pem --template server.tmpl --outfile server-cert.pem 把证书移动到合适的地方： cp ca-cert.pem /etc/ssl/private/my-ca-cert.pemcp server-cert.pem /etc/ssl/private/my-server-cert.pemcp server-key.pem /etc/ssl/private/my-server-key.pem 准备配置文件 我们把配置文件放到 ocserv 默认读取的位置： mkdir /etc/ocservcd ~/ocserv*cp doc/sample.config /etc/ocserv/ocserv.confvi /etc/ocserv/ocserv.conf 配置文件可以官方手册手册来写，不过这里我们重点要确保以下条目正确： # 登陆方式，目前先用密码登录auth = &quot;plain[/etc/ocserv/ocpasswd]&quot; # 允许同时连接的客户端数量max-clients = 4 # 限制同一客户端的并行登陆数量max-same-clients = 2 # 服务监听的IP（服务器IP，可不设置）listen-host = 1.2.3.4 # 服务监听的TCP/UDP端口（选择你喜欢的数字）tcp-port = 9000udp-port = 9001 # 自动优化VPN的网络性能try-mtu-discovery = true # 确保服务器正确读取用户证书（后面会用到用户证书）cert-user-oid = 2.5.4.3 # 服务器证书与密钥ca-cert = /etc/ssl/private/my-ca-cert.pemserver-cert = /etc/ssl/private/my-server-cert.pemserver-key = /etc/ssl/private/my-server-key.pem # 客户端连上vpn后使用的dnsdns = 8.8.8.8dns = 8.8.4.4 # 注释掉所有的route，让服务器成为gateway#route = 192.168.1.0/255.255.255.0 # 启用cisco客户端兼容性支持cisco-client-compat = true#据说可以优化速度output-buffer = 23000 try-mtu-discovery = true 测试服务器 创建一个登陆用的用户名与密码ocpasswd -c /etc/ocserv/ocpasswd your-username 修改内核设置，使得支持转发，vi /etc/sysctl.conf,将net.ipv4.ip_forward=0改为net.ipv4.ip_forward=1 , 保存生效sysctl -p 查看网卡信息ifconfig用于修改防火墙开启NAT转发, 开启端口(对应上面配置的端口) iptables -t nat -A POSTROUTING -j MASQUERADEiptables -A INPUT -p tcp --dport 443 -j ACCEPTiptables -A INPUT -p udp --dport 443 -j ACCEPT# 规则保存 Ubuntuiptables-save &gt; /etc/iptables.rules# 规则保存 Debianapt-get install iptables-persistent -yservice netfilter-persistent save 使用iptables -t nat -L来验证转发是否开启成功 Chain PREROUTING (policy ACCEPT)target prot opt source destination Chain INPUT (policy ACCEPT)target prot opt source destination Chain OUTPUT (policy ACCEPT)target prot opt source destination Chain POSTROUTING (policy ACCEPT)target prot opt source destinationMASQUERADE all -- 192.168.1.0/24 anywhere 使用 iptables -L -n 查看端口是否开启 `Chain INPUT (policy ACCEPT)target prot opt source destination ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 tcp dpt:443ACCEPT udp -- 0.0.0.0/0 0.0.0.0/0 udp dpt:443Chain FORWARD (policy ACCEPT)target prot opt source destination Chain OUTPUT (policy ACCEPT)target prot opt source destination 使用ocserv -f -d 1命令来启动下服务啦打开你手机上的 OpenConnect / Cisco Anyconnect 新建一个 VPN, 添加服务器 IP 就是你的 vps的IP:端口,例如X.X.X.X:443好了，如果你看到如下信息，那服务器应该已经能够正常运行了： Parsing plain auth method subconfig using legacy formatSetting &apos;plain&apos; as primary authentication methodlistening (TCP) on 0.0.0.0:443...listening (UDP) on 0.0.0.0:443...ocserv[16104]: main: initialized ocserv 0.11.8ocserv[16105]: sec-mod: reading supplemental config from filesocserv[16105]: sec-mod: sec-mod initialized (socket: /var/run/ocserv-socket.16104)ocserv[16109]: GnuTLS error (at worker-vpn.c:468): A TLS fatal alert has been received.: Unknown certificateocserv[16104]: main: 60.0.14.48:9890 user disconnectedocserv[16105]: sec-mod: using &apos;plain&apos; authentication to authenticate user (session: FXS0l)ocserv[16104]: main: 60.0.14.48:36627 user disconnectedocserv[16105]: sec-mod: initiating session for user &apos;test&apos; (session: FXS0l)ocserv[16104]: main[test]: 60.0.14.48:9663 new user sessionocserv[16104]: main[test]: 60.0.14.48:9663 user logged inocserv[16104]: main: 60.0.14.48:46429 user disconnectedocserv[16104]: main[test]: 60.0.14.48:9663 user disconnectedocserv[16105]: sec-mod: temporarily closing session for test (session: FXS0l)ocserv[16105]: sec-mod: initiating session for user &apos;test&apos; (session: FXS0l)ocserv[16104]: main[test]: 60.0.14.48:38135 new user sessionocserv[16104]: main[test]: 60.0.14.48:38135 user logged in 好了，目前已经搞定了OpenConnect server，下面讲的是一些优化，创建客户端证书，智能分流 优化OpenConnectServer 制作启动脚本 首先，来写个启动脚本——毕竟，不能每次都用调试模式启动不是吗？ vi /etc/init.d/ocserv 在配置文件中写入如下脚本： #!/bin/sh### BEGIN INIT INFO# Provides: ocserv# Required-Start: $remote_fs $syslog# Required-Stop: $remote_fs $syslog# Default-Start: 2 3 4 5# Default-Stop: 0 1 6### END INIT INFO# Copyright Rene Mayrhofer, Gibraltar, 1999# This script is distibuted under the GPLPATH=/bin:/usr/bin:/sbin:/usr/sbin:/usr/local/sbinDAEMON=/usr/local/sbin/ocservPIDFILE=/var/run/ocserv.pidDAEMON_ARGS=\"-c /etc/ocserv/ocserv.conf\"case \"$1\" instart)if [ ! -r $PIDFILE ]; thenecho -n \"Starting OpenConnect VPN Server Daemon: \"start-stop-daemon --start --quiet --pidfile $PIDFILE --exec $DAEMON -- \\$DAEMON_ARGS &gt; /dev/nullecho \"ocserv.\"elseecho -n \"OpenConnect VPN Server is already running.\\n\\r\"exit 0fi;;stop)echo -n \"Stopping OpenConnect VPN Server Daemon: \"start-stop-daemon --stop --quiet --pidfile $PIDFILE --exec $DAEMONecho \"ocserv.\"rm -f $PIDFILE;;force-reload|restart)echo \"Restarting OpenConnect VPN Server: \"$0 stopsleep 1$0 start;;status)if [ ! -r $PIDFILE ]; then# no pid file, process doesn't seem to be running correctlyexit 3fiPID=`cat $PIDFILE | sed 's/ //g'`EXE=/proc/$PID/exeif [ -x \"$EXE\" ] &amp;&amp;[ \"`ls -l \\\"$EXE\\\" | cut -d'&gt;' -f2,2 | cut -d' ' -f2,2`\" = \\\"$DAEMON\" ]; then# ok, process seems to be runningexit 0elif [ -r $PIDFILE ]; then# process not running, but pidfile existsexit 1else# no lock file to check for, so simply return the stopped statusexit 3fi;;*)echo \"Usage: /etc/init.d/ocserv &#123;start|stop|restart|force-reload|status&#125;\"exit 1;;esacexit 0 赋予其可执行权限 chmod 755 /etc/init.d/ocserv`update-rc.d ocserv defaults 之后就可以使用 /etc/init.d/ocserv start | stop | restartservice ocserv start | stop | restart 免密码登录 创建客户端证书，省的老输入密码 cd ~/certificates/vi user.tmpl 写入如下内容： cn = &quot;some random name&quot;unit = &quot;some random unit&quot;expiration_days = 365signing_keytls_www_client 生成User密钥和证书 certtool --generate-privkey --outfile user-key.pemcerttool --generate-certificate --load-privkey user-key.pem --load-ca-certificate ca-cert.pem --load-ca-privkey ca-key.pem --template user.tmpl --outfile user-cert.pem 然后要将证书和密钥转为PKCS12的格式 certtool --to-p12 --load-privkey user-key.pem --pkcs-cipher 3des-pkcs12 --load-certificate user-cert.pem --outfile user.p12 --outder 期间会要求你输入证书名字和密码。 然后你需要把这个证书放到一个可以被直接访问的地方，然后通过 URL 将 user.p12 文件导入AnyConnect，具体位置在诊断标签页的证书栏目下，导入成功之后，将对应的VPN设置的高级设置部分的证书栏目，改为导入的这张证书。 现在，为了让服务器能够认得这张证书，我们再来修改一下配置： vi /etc/ocserv/ocserv.conf # 改为证书登陆，注释掉原来的登陆模式auth = &quot;certificate&quot; # 证书认证不支持这个选项，注释掉这行#listen-clear-file = /var/run/ocserv-conn.socket # 启用证书验证ca-cert = /etc/ssl/private/my-ca-cert.pem 这样，我们使用service ocserv restart来启动它即可！ 智能分流 编译 ocserv 前需要修改 src/vpn.h 来支持超过 96 行(ocserv默认值)但不超过200行(Cisco AnyConnect最大值)的路由表: vi ~/ocserv*/src/vpn.h#把96改为200以上#define DEFAULT_CONFIG_ENTRIES 96 修改 ocserv 配置文件，添加这些内容 补充:一键脚本(新) https://moeclub.org/2017/06/22/268/一键脚本 https://github.com/fanyueciyuan/eazy-for-ss/tree/master/ocservauto注意Anyconnect和速锐一起使用的话,首先要禁止掉udp-port(详细看配置文件) ,接着重启速锐 最后重启Anyconnect 参考:http://bitinn.net/11084/https://www.logcg.com/archives/1343.htmlhttp://www.fanyueciyuan.info/fq/ocserv-debian.htmlhttps://github.com/CNMan/ocserv-cn-no-route","categories":[{"name":"GFW","slug":"GFW","permalink":"https://imeiji.github.io/categories/GFW/"}],"tags":[]},{"title":"Android Studio设置教程","slug":"Android Studio设置教程","date":"2017-08-22T09:16:34.000Z","updated":"2018-05-31T16:39:55.000Z","comments":true,"path":"2017/08/22/Android Studio设置教程/","link":"","permalink":"https://imeiji.github.io/2017/08/22/Android Studio设置教程/","excerpt":"","text":"文章是很久之前就写好了, 一直没有发出来, 这篇教程比较折腾, 好处是你的系统盘不会给塞满, 我把所有配置都转移到非系统盘, 如果你的 AS 用久了可以看看 .AndroidStudio 文件夹有多大, 再考虑转移配置 下载官网 http://developer.android.com/sdk/index.html各个版本 http://tools.android.com/download/studio 环境变量请按照实际情况进行修改(Android SDK 我就没配置, 反正可以选下载路径)PATH的要特别注意, 要加到原来的后面 ADB Android=D:\\Users\\XXX\\AppData\\Local\\Android\\sdk\\platform-toolsPath=;%Android%; Java JAVA_HOME=C:\\Program Files\\Java\\jdk1.8.0_66CLASSPATH=.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar# 注意，%PATH%为原来的环境变量值，添加&quot;;&quot;和后面的内容到原来值的后面PATH=%PATH%;%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin Gradle # Android Studio正式版后就内置了一个Gradle，当然你也可以另外去Gradle官网下载一个GRADLE_HOME=D:\\Program Files\\android-studio\\gradle\\gradle-2.10PATH=%PATH%;%GRADLE_HOME%\\bin# 依赖仓库存放路径，平时构建工程时下载的依赖库都放在这里# 不配置的话，Windows中默认是在C:\\Users\\&lt;username&gt;\\.gradle的# 重装系统时忘记备份，又不想重新下载依赖的话，就赶紧把这里改了GRADLE_USER_HOME=D:\\Users\\XXX\\.gradle Android SDK ANDROID_HOME=E:\\DevTools\\Android\\sdkPATH=%PATH%;%ANDROID_HOME%\\tools;%ANDROID_HOME%\\platform-tools# ADB端口，可以避免国内一堆软件，如酷狗音乐啥的把ADB端口抢占了，值随便改个不常用的就行ANDROID_ADB_SERVER_PORT=7123 Android Studio 本来是用默认路径也没什么问题，不过在 Windows 环境下，什么东西都往系统盘里塞老是让人觉得不舒服 修改 idea.properties 文件 进入 Android Studio 的安装目录, 进入bin文件夹 ,打开 idea.properties , 修改对应的路径为新路径即可. (PS: 如果你的 idea.properties 文件文件没有以下内容, 点这里下载一个, 覆盖到bin文件夹) idea.config.path=D:/Users/XXX/.AndroidStudio/configidea.system.path=D:/Users/XXX/.AndroidStudio/systemidea.plugins.path=$&#123;idea.system.path&#125;/pluginsidea.log.path=$&#123;idea.system.path&#125;/log 注意plugins和log的路径不要乱改, 不然插件会安装不上这种方式改完之后问题是解决了, 可是之后你在增量升级 AS 的时候就会发现总是失败, 原因就是因为你改了 bin 目录下的 idea.properties 文件, 那么 Google 给出的解决办法就是不要直接改 bin 目录下的 idea.properties 文件, 而是在 %USERPROFILE%\\.{FOLDER_NAME}\\ 目录下创建一个空的idea.properties 文件, 把修改过的 idea.properties 文件复制到这里 .android 文件夹的修改 这个文件夹是由 Android SDK 配置模拟器生成的, 也是最占空间的一个首先, 需要添加一个系统的环境变量变量名ANDROID_SDK_HOME变量值D:\\Users\\XXX 设置Android Studio不要急着新建工程,先Configure→Settings去修改设置 修改主题,全局字体 主题默认就好,个人不喜欢深色主题,字体选Microsoft YaHei UI就不错了 ​ 禁止自动打开上次的工程 ​ 设置代理 ​ SDK目录 快捷键 不推荐使用 Eclipse 快捷键了, 很多功能会缺失, 强烈建议使用 IDEA 的快捷键 鼠标悬停显示文档, 格式化&amp;导包提示 鼠标指针悬停若干时间, 显示文档, 时间自己改 就是按格式化代码或者导包时, 是否会显示个对话框 自动导包 显示行号, 显示方法分隔线 代码智能提示 敲什么字符会提示 All 大小写全部符合 None 不管大小写, 符合就提示 First letter 第一个字符符合就OK, 其他随意 自动弹出时间自己改下 ​ 代码样式配置 修改注释位置, 禁用“语句堆一行” Line breaks: 启用的话, 表示保持断行 Comment at frist column: 启用的话, 注释符号就会在行首, 否则就按照缩进来注释 Control statement in one line: 格式化代码的时候, 会把些很短的语句合并成一行. 我觉得这样影响代码可读性, 故取消 Ensure right margin is not exceeded: 表示代码超过标准线就自动换行 修改新建文件文件头 修改文件编码为UTF-8 修改Gradle目录 开启Instant Run 到此已经配置好 AS , 新建一个工程试试吧为了保险, 打开Android Studio内置的终端, 在输入如下命令查看 gradle 版本:gradlew -v配置没问题的话就显示你的 gradle 版本, 如果你配置错误 AS 会自动下载并安装个 gradle 补充 Gradle 设置代理 找到 gradle.properties 这个文件，如果你按照我上面的环境变量设置，那么文件在GRADLE_USER_HOME=D:\\Users\\XXX\\.gradle 下，否则在 C 盘 修改 gradle.properties 这个文件 ## Proxy setupsystemProp.proxySet=\"true\"systemProp.http.keepAlive=\"true\"systemProp.http.proxyHost=127.0.0.1systemProp.http.proxyPort=1080systemProp.https.keepAlive=\"true\"systemProp.https.proxyHost=127.0.0.1systemProp.https.proxyPort=1080## 据说只要添加下面这行 https://www.zhihu.com/question/37810416/answer/82464203org.gradle.jvmargs=-DsocksProxyHost=127.0.0.1 -DsocksProxyPort=1080## 自动删除 30 天前的缓存buildCache &#123; local &#123; removeUnusedEntriesAfterDays = 30 &#125; &#125;## 为所有的构建启用构建缓存org.gradle.caching=true IDEA主题 修改最大堆内存 在Help菜单下面，有个Edit Custom VM Option 选项，可以直接打开那个studio(64?).vmoptions文件 -Xmx4g 参考自定义androidstudio的配置文件目录后，无法正常安装和卸载插件，是何原因？ - 知乎 Android Studio 使用起来很卡，你们是如何解决的？","categories":[{"name":"Android","slug":"Android","permalink":"https://imeiji.github.io/categories/Android/"}],"tags":[]},{"title":"Windows 软件清单","slug":"Windows 软件清单","date":"2017-07-09T16:22:01.000Z","updated":"2018-03-30T14:11:05.000Z","comments":true,"path":"2017/07/10/Windows 软件清单/","link":"","permalink":"https://imeiji.github.io/2017/07/10/Windows 软件清单/","excerpt":"","text":"记录下自己常用的软件, 整理软件清单, 便于后续持续利用 浏览器 Chrome Firefox 编辑器 Notepad++ Sublime Text Markdown工具 Typora MarkdownPad 2 笔记工具 Evernote 代理工具 SS / SSR Proxifier SSTap SocksCap64 AnyConnect OpenConnect 聊天工具 QQ Lite / TIM WeChat Telegram Discord 系统工具 f.lux MacType Dism++ Listary uTrun Geek Uninstaller CCleaner VMware 截图工具 FastStone Capture Snipaste 下载工具 Thunder IDM qBittorrent 办公工具 Office / WPS PDF-XChange Viewer SumatraPDF 远程工具 TeamViewer VNC 词典 欧路词典 开发环境 JDK &amp; JRE Python Node.js Git MySQL IDE Navicat JRE Source Insight SqliteBrowser IntelliJ IDEA Android Studio 播放器 网易云音乐 AIMP PotPlayer MPC-BE 压缩工具 7zip Bandizip 图片浏览器 蜂蜜浏览器 网络抓包 Charles Wireshark Fiddler 终端工具 Xshell Xftp 游戏 Steam Origin 其他 Clover 资源管理器多标签拓展 Ditto 剪切板记录 Everthing 全盘搜索 Beyond Compare 文件对比 WinMTR 路由追踪 SpaceSniffer 查看硬盘空间占用 NetLimiter 网速限制 FxSound Enhancer 音效增强","categories":[{"name":"Default","slug":"Default","permalink":"https://imeiji.github.io/categories/Default/"}],"tags":[]},{"title":"搭建 sspanel v3 魔改版记录","slug":"搭建 sspanel v3 魔改版记录","date":"2017-01-09T07:57:01.000Z","updated":"2017-03-20T11:21:18.000Z","comments":true,"path":"2017/01/09/搭建 sspanel v3 魔改版记录/","link":"","permalink":"https://imeiji.github.io/2017/01/09/搭建 sspanel v3 魔改版记录/","excerpt":"","text":"前端使用赵大的魔改版 https://github.com/esdeathlove/ss-panel-v3-mod 后端也使用赵大的魔改版 https://github.com/esdeathlove/shadowsocks 演示环境 : VirMach 512RAM机子 Ubuntu 14 x64 安装前端1.安装 LNMP screen -S lnmp2G以上内存wget http://soft.vpser.net/lnmp/lnmp1.3-full.tar.gz &amp;&amp; tar xvzf lnmp1.3-full.tar.gzcd lnmp1.3-full &amp;&amp; ./install.sh1G以下内存wget http://soft.vpser.net/lnmp/lnmp1.2-full.tar.gz &amp;&amp; tar xvzf lnmp1.2-full.tar.gzcd lnmp1.2-full &amp;&amp; ./install.sh 安装过程要求输入MySQL密码, 选择MySQL版本&gt;=5.5, PHP版本&gt;5.6. 安装大概需要半小时, 如果中途 ssh 断线, 输入 screen -r lnmp 2.设置虚拟主机 lnmp vhost add 要求输入你的域名, 然后其余项都选 no 接着修改下 nginx 编辑 /usr/local/nginx/conf/vhost/你的域名.conf 然后添加下面这一段到 server location / &#123; try_files $uri $uri/ /index.php$is_args$args; &#125; 修改 root 那一行为 root /home/wwwroot/你的域名/public; 3.下载 sspanel 代码 cd /home/wwwroot/你的域名apt-get install git -ygit clone -b master https://github.com/esdeathlove/ss-panel-v3-mod.git tmp &amp;&amp; mv tmp/.git . &amp;&amp; rm -rf tmp &amp;&amp; git reset --hardchown -R root:root *chmod -R 755 *chown -R www:www storagechattr -i .user.inimv .user.ini publiccd publicchattr +i .user.iniservice nginx restart 4.安装 radius , 不使用VPN的话, 可以不进行这一步 # 先安装perlapt-get install perl # 然后需要安装perl的DBI组件perl -MCPAN -e shellcpan&gt;install DBI//安装完成后退出cpancpan&gt;quit# 再安装其它组件apt install freeradius freeradius-mysql freeradius-utils 5.配置数据库 浏览器打开 http://你的vps ip/phpmyadmin 用户 : root 密码 :安装 lnmp 时设置的 需要创建一个数据库和一个访问这个数据库的用户 点击 用户 -&gt; 新建 -&gt; 添加用户 登录信息 : Username 选择 使用文本域 , 填写你的用户名 如 sspanel Host 选择任意主机 % 密码 选择使用文本域 填写密码 用户数据库 : 勾选 创建与用户同名的数据库并授予所有权限 全局权限 : 全选 接着按执行 选择刚刚新建的数据库 sspanel 导入程序目录下的 glzjin_all.sql 不适用 VPN 的话跳下一步 接着配置 radius , 创建个 radius 数据库和用户 (重复以上步骤) 选择 radius 数据库 导入 https://github.com/glzjin/Radius-install/raw/master/all.sql 回到 ssh 继续设置 radius 编辑 /etc/freeradius/sql.conf 配置 login(用户名), password(密码), radius_db(数据库名)等字段 找到 readclients 一行，设为 yes 并去掉注释符号# 然后下面是几个文件的覆盖 wget https://github.com/glzjin/Radius-install/raw/master/radiusd.conf -O /etc/freeradius/radiusd.confwget https://github.com/glzjin/Radius-install/raw/master/default -O /etc/freeradius/sites-enabled/defaultwget https://github.com/glzjin/Radius-install/raw/master/dialup.conf -O /etc/freeradius/sql/mysql/dialup.confwget https://github.com/glzjin/Radius-install/raw/master/dictionary -O /etc/freeradius/dictionarywget https://github.com/glzjin/Radius-install/raw/master/counter.conf -O /etc/freeradius/sql/mysql/counter.conf Radius 配置完成, service freeradius start 然后你也可以将该 freeradius 设为开机启动项 6.配置 sspanel cd /home/wwwroot/你的域名cp config/.config.php.example config/.config.php# 编辑以下文件 建议使用 FTP 下载到本地修改vi config/.config.php 由于配置太多 这里只说重点 $System_Config['key'] = ''; //修改此key为随机字符串确保网站安全$System_Config['appName'] = ''; //站点名称$System_Config['baseUrl'] = 'https://zhaojin97.cn'; // 站点地址$System_Config['timeZone'] = 'PRC'; // RPC 天朝时间 UTC 格林时间$System_Config['pwdMethod'] = 'sha256'; // 密码加密 可选 md5,sha256$System_Config['salt'] = ''; // 密码加密用，从旧版升级请留空$System_Config['authDriver'] = 'cookie'; // 登录验证存储方式,推荐使用Redis 可选: cookie,redis$System_Config['mailDriver'] = 'mailgun'; // 邮件 可选 mailgun or smtp 需要支持qq邮箱的选 smtp$System_Config['checkinMin'] = '100'; // 签到最少流量 单位MB$System_Config['checkinMax'] = '500'; // 签到最多流量$System_Config['defaultTraffic'] = '100'; // 用户初始流量 单位GB$System_Config['inviteNum'] = '0'; // 注册后获得的邀请码数量# database 数据库配置$System_Config['db_driver'] = 'mysql';$System_Config['db_host'] = 'localhost'; // 数据库地址$System_Config['db_database'] = ''; // 数据库名称 sspanel$System_Config['db_username'] = ''; // 数据库用户 sspanel$System_Config['db_password'] = ''; // sspanel用户的密码$System_Config['db_charset'] = 'utf8';$System_Config['db_collation'] = 'utf8_general_ci';$System_Config['db_prefix'] = '';# redis$System_Config['redis_scheme'] = 'tcp'; // 登录验证存储方式选了 redis 的话需要配置$System_Config['redis_host'] = '127.0.0.1';$System_Config['redis_port'] = '6379';$System_Config['redis_database'] = '0';$System_Config['redis_password']=\"\";# smtp$System_Config['smtp_host'] = ''; // 例如 smtp.qq.com$System_Config['smtp_username'] = '';$System_Config['smtp_port'] = '25';$System_Config['smtp_name'] = '';$System_Config['smtp_sender'] = '';$System_Config['smtp_passsword'] = '';$System_Config['smtp_ssl'] = 'false';#功能开关 需要用到的才开 建议先别动$System_Config['enable_wecenter']='false';$System_Config['enable_radius']='false'; // 配置了 radius 的话就开$System_Config['enable_cloudxns']='false';$System_Config['enable_duoshuo']='false';$System_Config['enable_rss']='true';$System_Config['enable_paymentwall']='false';#Radius数据库设置$System_Config['radius_db_host']=''; // 跟 上面 database 数据库配置差不多 换成radius即可$System_Config['radius_db_database']='';$System_Config['radius_db_user']='';$System_Config['radius_db_password']='';#Radius连接密钥$System_Config['radius_secret']=''; // 这个重要 必须设#端口池$System_Config['min_port']='10000'; // SSR 分配端口号范围$System_Config['max_port']='65535';#两种方式相对于ss端口的偏移$System_Config['pacp_offset']='-20000'; // PAC+ 和 PAC++ 用到$System_Config['pacpp_offset']='-20000';#测速周期/h$System_Config['Speedtest_duration']='6'; // 对应后端 SSR 的 userapiconfig.py 里的 SPEEDTEST#随机分组，注册时随机分配到的分组，多个分组请用英文半角逗号分隔。$System_Config['ramdom_group']='0'; // 组别用于区分用户组 对应组只能访问对应组和0组的服务器 明白后再修改 #充值返利百分比$System_Config['code_payback']='20'; // 用户充值后 给邀请他注册的人返利多少%#注册时的流量重置日以及需要重置的流量,0不重置$System_Config['reg_auto_reset_day']='0';$System_Config['reg_auto_reset_bandwidth']='100'; // 单位G 以上为 config 部分配置 完成后保存并上传到原目录下 切换到 ssh 窗口, 在你的网站目录下执行以下命令创建管理员 php xcat createAdmin 按照提示, 输入管理员邮箱密码等信息, 然后执行以下命令同步用户 php xcat syncusers 此时管理员创建完成 接下来需要对服务器进行计划任务的设置,执行 crontab -e 命令, 添加以下五段 30 22 * * * php /home/wwwroot/站点文件夹/xcat sendDiaryMail */1 * * * * php /home/wwwroot/站点文件夹/xcat synclogin*/1 * * * * php /home/wwwroot/站点文件夹/xcat syncvpn0 0 * * * php /home/wwwroot/站点文件夹/xcat dailyjob*/1 * * * * php /home/wwwroot/站点文件夹/xcat checkjob */1 * * * * php /home/wwwroot/站点文件夹/xcat syncnas 重启Crontab/etc/init.d/cron restart 7.注意事项 检查时间是否为天朝时间 如果VPS默认是非中国时区的话, 如下命令可以用来更改为中国时区 cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 检查防火墙是否屏蔽数据库端口 # 允许本机访问iptables -A INPUT -s 127.0.0.1/32 -p tcp -m tcp --dport 3306 -j ACCEPT# 允许节点访问iptables -A INPUT -s 节点IP -p tcp -m tcp --dport 3306 -j ACCEPT# 允许所有IP访问iptables -A INPUT -p tcp -m tcp --dport 3306 -j ACCEPT 查看防火墙规则 查看已添加的iptables规则iptables -L -n --line-numbers删除已添加的iptables规则iptables -D INPUT line-numbers 规则保存 # Ubuntuiptables-save &gt; /etc/iptables.rules# CentOSservice iptables save 安装后端1.安装 libsodium apt-get install build-essential wget -ywget https://github.com/jedisct1/libsodium/releases/download/1.0.10/libsodium-1.0.10.tar.gztar xf libsodium-1.0.10.tar.gz &amp;&amp; cd libsodium-1.0.10./configure &amp;&amp; make -j2 &amp;&amp; make installldconfig 2.安装SSR apt-get install python-pip git -ypip install cymysqlcd ..git clone -b manyuser https://github.com/glzjin/shadowsocks.gitcd shadowsockschmod +x *.sh# 配置程序cp apiconfig.py userapiconfig.pycp config.json user-config.jsonvi userapiconfig.py 然后主要编辑 userapiconfig.py, 来解释下里面各项配置的意思 # Config#节点ID 对应前端节点列表的IDNODE_ID = 1#自动化测速，为0不测试，此处以小时为单位，要和 ss-panel 设置的小时数一致SPEEDTEST = 6#云安全，自动上报与下载封禁IP，1为开启，0为关闭CLOUDSAFE = 1#自动封禁SS密码和加密方式错误的 IP，1为开启，0为关闭ANTISSATTACK = 0#是否接受上级下发的命令，如果你要用这个命令，请参考我之前写的东西，公钥放在目录下的 ssshell.ascAUTOEXEC = 1#是否以多线程模式运行，关闭这个限速就会无效。请优先测试 1 ，开启试试，能运行没。MULTI_THREAD = 0#多端口单用户设置，看重大更新说明。MU_SUFFIX = 'zhaoj.in'#多端口单用户设置，看重大更新说明。MU_REGEX = '%5m%id.%suffix'#不明觉厉SERVER_PUB_ADDR = '127.0.0.1' # mujson_mgr need this to generate ssr link#此处不要修改API_INTERFACE = 'glzjinmod' #mudbjson, sspanelv2, sspanelv3, sspanelv3ssr, muapiv2(not support)#mudb，不要管MUDB_FILE = 'mudb.json'# Mysql 数据库连接信息MYSQL_HOST = '127.0.0.1'MYSQL_PORT = 3306MYSQL_USER = 'ss'MYSQL_PASS = 'ss'MYSQL_DB = 'shadowsocks'MYSQL_UPDATE_TIME = 60# 是否启用SSL连接，0为关，1为开MYSQL_SSL_ENABLE = 0# 客户端证书目录，请看 https://github.com/glzjin/shadowsocks/wiki/Mysql-SSL%E9%85%8D%E7%BD%AEMYSQL_SSL_CERT = '/root/shadowsocks/client-cert.pem'MYSQL_SSL_KEY = '/root/shadowsocks/client-key.pem'MYSQL_SSL_CA = '/root/shadowsocks/ca.pem'# API，不用管API_HOST = '127.0.0.1'API_PORT = 80API_PATH = '/mu/v2/'API_TOKEN = 'abcdef'API_UPDATE_TIME = 60# Manager 不用管MANAGE_PASS = 'ss233333333'#if you want manage in other server you should set this value to global ipMANAGE_BIND_IP = '127.0.0.1'#make sure this port is idleMANAGE_PORT = 23333 3.运行SSR 运行的话, 有几种方式 python server.py 用于调错的 ./run.sh 无日志后台运行 ./logrun.sh 有日志后台运行 supervisord 这里说下 使用Supervisor守护进程启动ssr # 安装apt-get install supervisor -y# 写入配置vi /etc/supervisor/conf.d/ssr.conf# 写入以下内容[program:ssr]command=python /root/shadowsocks/server.py autorestart=trueautostart=trueuser=root# 重启Supervisor服务。/etc/init.d/supervisor restart# 重启 ssrsupervisorctl restart ssr# 查看Supervisor服务运行状态。supervisorctl status# 如果遇到问题，可以检查日志：supervisorctl tail -f ssr stderr# 如果使用supervisor进程守护，需要修改文件vi /etc/default/supervisor，添加一行：ulimit -n 1024000 强化安全1.将网站支持 SSL 强化安全 需要提前准备好 SSL 证书文件, 没有的话可以使用Let’s Encrypt 搞个免费SSL证书, 接着配置 nginx 编辑 /usr/local/nginx/conf/vhost/域名.conf server&#123; listen 80; #listen [::]:80; #有ipv6的开 server_name 域名; rewrite ^(.*) https://$server_name$1 permanent;&#125;server&#123; listen 443 ssl; #listen [::]:443 ssl; #有ipv6的开 ssl_certificate /etc/letsencrypt/live/你的域名/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/你的域名/privkey.pem; ssl_trusted_certificate /etc/letsencrypt/live/你的域名/chain.pem;&#125; 2.禁止 http 的访问请求 由于 http 仍然可以访问, 所以我们需要将 http 的请求手动转移到 https, 由于 SSpanel 本身使用了重定向, 那么在不使用其他重定向的情况下, 最简单的方法就是用 html 网页的 参数 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"refresh\" content=\"0;url=https://域名\"&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt;&lt;/head&gt;&lt;/html&gt; 3.转移 phpMyAdmin 目录 转移目录 LNMP安装完毕以后默认的会在IP地址网站根目录生成一个 phpMyAdmin 的目录, 但是正是因为这个原因, 暴露了该目录, 我一般都会直接把这个文件夹转移到新的网站目录下, 比如转移到其他二级域名下的某个目录, 只需要在LNMP中新建一个二级域名而已, 然后把 phpMyAdmin 这个目录再转移到这个二级域名的网站目录下 限制IP 在 phpMyAdmin 的目录下新增 .htaccess 写入以下 allow from 59.168.1.0/24allow from 59.168.2.50deny from all 除了 59.168.1.1 至 59.168.1.254 的区间IP 与 59.168.2.50 可以进入后台其于IP都封锁, 就算对方知道路径, IP不允许也是无法进入 参考 ss-panel-v3-mod安装说明 说明以及安装方法 Linux上iptables防火墙的基本应用教程","categories":[{"name":"VPS","slug":"VPS","permalink":"https://imeiji.github.io/categories/VPS/"}],"tags":[]},{"title":"自动备份 VPS 数据到 email 和 Dropbox","slug":"自动备份 VPS 数据到 email 和 Dropbox","date":"2017-01-07T16:00:00.000Z","updated":"2017-12-18T07:53:11.000Z","comments":true,"path":"2017/01/08/自动备份 VPS 数据到 email 和 Dropbox/","link":"","permalink":"https://imeiji.github.io/2017/01/08/自动备份 VPS 数据到 email 和 Dropbox/","excerpt":"","text":"Dropbox 准备 登录 Dropbox，打开 Apps 页面，点击 Create App 按钮，创建一个 App 获取 Access token，点击 Generate 获取备用。 接着 SSH 登录 VPS 获取最新的 Dropbox Uploader 脚本 git clone https://github.com/andreafabrizi/Dropbox-Uploader.gitchmod +x dropbox_uploader.sh./dropbox_uploader.sh info 根据提示输入 Access token，Dropbox 绑定成功。再次运行 ./dropbox_uploader.sh info 可以看到绑定的 Dropbox 账户信息。 Email 准备 安装Email组件，以保证数据库文件可以发送到您的邮箱 apt-get install sendmail mutt 创建备份脚本 请确保有以下目录，如果没有请执行 mkdir -p /root/backups/sql 脚本开始vi backup.sh #!/bin/bash#你要修改的地方从这里开始MYSQL_USER= #数据库用户MYSQL_PASS= #数据库密码MAIL_TO= #发送邮箱 WEB_DATA=/home/wwwroot #本地网站路径DOMAIN= #域名#你要修改的地方从这里结束#定义备份的名字DBName=Data_$(date +\"%Y%m%d%H\").tar.gzWebName=Web_$(date +%Y%m%d).tar.gz#定义旧数据名字 这里删除60天前的数据OldDBName=Data_$(date -d -60day +\"%Y%m%d\").tar.gzOldWebName=Web_$(date -d -60day +\"%Y%m%d\").tar.gz##备份目录cd /root/backups/sql#导出数据库,一个数据库一个压缩文件for db in `/usr/bin/mysql -u$MYSQL_USER -p$MYSQL_PASS -B -N -e 'SHOW DATABASES' | xargs`; do (/usr/bin/mysqldump -u$MYSQL_USER -p$MYSQL_PASS $&#123;db&#125; | gzip -9 - &gt; $&#123;db&#125;.sql.gz)done#压缩数据库文件为一个文件tar zcf $DBName *.sql.gzrm -rf *.sql.gz#将文件上传到 Dropbox/root/dropbox_uploader.sh upload \"$DBName\" \"/\"#删除旧的数据rm -rf OldDBName OldWebName#开始删除远程旧的文件/root/dropbox_uploader.sh delete $OldDBName#以下内容需要根据实际环境修改#发送数据库到Email#echo \"主题:数据库备份\" | mutt -e \"my_hdr from:$DOMAIN&lt;root@$DOMAIN&gt;\" -a /root/backups/sql/$DBName -s \"内容:数据库备份\" -- $MAIL_TO#压缩网站数据#tar zcf /root/backups/$WebName $WEB_DATA#将文件上传到 Dropbox#/root/dropbox_uploader.sh upload \"$WebName\" \"/\"#/root/dropbox_uploader.sh delete $OldWebName#发送网站数据到Email#echo \"主题:网站备份\" | mutt -e \"my_hdr from:$DOMAIN&lt;root@$DOMAIN&gt;\" -a /root/backups/$DBName /root/backups/$DBName -s \"内容:网站备份\" -- $MAIL_TO 脚本修改完，上传至 /root/ 目录下，并赋予执行权限chmod +x /root/backup.sh 准备添加定时设置，每2小时备份数据 crontab -e0 */2 * * * bash /root/backupsql.sh 重启Crontab/etc/init.d/cron restart 参考文章http://www.laozuo.org/4560.html https://cyhour.com/549/","categories":[{"name":"VPS","slug":"VPS","permalink":"https://imeiji.github.io/categories/VPS/"}],"tags":[]},{"title":"今日头条Api分析","slug":"今日头条Api分析","date":"2017-01-04T16:00:00.000Z","updated":"2017-01-09T10:17:54.000Z","comments":true,"path":"2017/01/05/今日头条Api分析/","link":"","permalink":"https://imeiji.github.io/2017/01/05/今日头条Api分析/","excerpt":"","text":"获取新闻标题普通用法http://toutiao.com/api/article/recent/?source=2&amp;category=类型&amp;as=A1D5D87595C3287 例如获取热点新闻http://toutiao.com/api/article/recent/?source=2&amp;category=news_hot&amp;as=A1D5D87595C3287 其中 category 指类型 as 值随机生成 感兴趣的自己去抓取得到的信息为&#123; \"has_more\": true, \"message\": \"success\", \"data\": [ &#123; \"media_name\": \"侠客岛\", \"abstract\": \"今天又有大新闻啦。据美国多家媒体的消息， 12月15日，中国海军在南海趁美国一艘无人水下潜航器（UUV）故障之机，抢在美军打捞人员之前将其捞走。\", \"impression_count\": 7433280, \"image_list\": [ &#123; \"url\": \"http://p1.pstatp.com/list/134b00048dd993d77429\" &#125;, &#123; \"url\": \"http://p3.pstatp.com/list/1349000017bb1b3c7366\" &#125;, &#123; \"url\": \"http://p3.pstatp.com/list/134c0003788b24d74346\" &#125; ], \"media_avatar_url\": \"http://p3.pstatp.com/large/1731/4112623237\", \"external_visit_count\": 14999, \"article_type\": 0, \"more_mode\": true, \"tag\": \"news_military\", \"is_favorite\": 0, \"has_m3u8_video\": 0, \"keywords\": \"南海诸岛,南海,美国,专属经济区,公约,国际法\", \"has_mp4_video\": 0, \"favorite_count\": 1059, \"display_url\": \"http://toutiao.com/group/6365056560833659137/\", \"article_sub_type\": 0, \"bury_count\": 9, \"title\": \"美国想在南海下黑手，结果被中国抓个正着！这下送礼了\", \"datetime\": \"2016-12-17 22:27\", \"has_video\": false, \"share_url\": \"http://toutiao.com/group/6365056560833659137/?iid=41507200127&amp;app=news_article\", \"id\": 6365056560833659000, \"source\": \"侠客岛\", \"comment_count\": 17, \"article_url\": \"http://toutiao.com/group/6365056560833659137/\", \"create_time\": 1481980801, \"recommend\": 0, \"tips\": 0, \"aggr_type\": 1, \"item_source_url\": \"/item/6365059050404577794/\", \"media_url\": \"http://toutiao.com/m3741758306/\", \"display_time\": 1481980795, \"publish_time\": 1481980795, \"go_detail_count\": 504591, \"group_flags\": 2, \"middle_mode\": false, \"display_title\": \" \", \"gallary_image_count\": 3, \"item_seo_url\": \"/item/6365059050404577794/\", \"tag_id\": 6365056560833659000, \"source_url\": \"/group/6365056560833659137/\", \"article_genre\": \"article\", \"large_mode\": false, \"item_id\": 6365059050404578000, \"natant_level\": 0, \"is_digg\": 0, \"seo_url\": \"/group/6365056560833659137/\", \"repin_count\": 1059, \"url\": \"http://toutiao.com/group/6365056560833659137/\", \"level\": 0, \"digg_count\": 55, \"behot_time\": 1481984828, \"hot\": 0, \"preload_web\": 2, \"comments_count\": 17, \"has_image\": true, \"is_bury\": 0, \"group_id\": 6365056560833659000, \"middle_image\": &#123; \"url\": \"http://p1.pstatp.com/list/134b00048dd993d77429\", \"width\": 415, \"url_list\": [ &#123; \"url\": \"http://p1.pstatp.com/list/134b00048dd993d77429\" &#125;, &#123; \"url\": \"http://pb3.pstatp.com/list/134b00048dd993d77429\" &#125;, &#123; \"url\": \"http://pb3.pstatp.com/list/134b00048dd993d77429\" &#125; ], \"uri\": \"list/134b00048dd993d77429\", \"height\": 536 &#125; &#125; ], \"next\": &#123; \"max_behot_time\": 1481984828 &#125;&#125; 我们要获取的新闻都在 data 数组里, 这里我只罗列了部分 以下给出部分类型 仅供参考&apos;推荐&apos;: &apos;__all__&apos;,&apos;热点&apos;: &apos;news_hot&apos;,&apos;社会&apos;: &apos;news_society&apos;,&apos;娱乐&apos;: &apos;news_entertainment&apos;,&apos;科技&apos;: &apos;news_tech&apos;,&apos;军事&apos;: &apos;news_military&apos;,&apos;体育&apos;: &apos;news_sports&apos;&apos;汽车&apos;: &apos;news_car&apos;,&apos;财经&apos;: &apos;news_finance&apos;,&apos;国际&apos;: &apos;news_world&apos;,&apos;时尚&apos;: &apos;news_fashion&apos;,&apos;旅游&apos;: &apos;news_travel&apos;,&apos;探索&apos;: &apos;news_discovery&apos;,&apos;育儿&apos;: &apos;news_baby&apos;,&apos;养生&apos;: &apos;news_regimen&apos;,&apos;故事&apos;: &apos;news_story&apos;,&apos;美文&apos;: &apos;news_essay&apos;,&apos;游戏&apos;: &apos;news_game&apos;,&apos;历史&apos;: &apos;news_history&apos;,&apos;美食&apos;: &apos;news_food&apos;, 高级用法http://toutiao.com/api/article/recent/?source=2&amp;category=news_hot&amp;as=A105177907376A5&amp;cp=5797C7865AD54E1&amp;count=20&amp;offset=0&amp;_=1481986412 category 指类型 as 随机生成 cp 随机生成 count 获取文章数量 offset 偏移量 _= 指 max_behot_time 补充一个Api, 从手机版获取到的http://m.toutiao.com/list/?tag=__all__&amp;ac=wap&amp;count=20&amp;format=json_raw&amp;as=A17538D54D106FF&amp;cp=585DF0A65F0F1E1&amp;min_behot_time=1482491618 获取新闻获取新闻内容http://m.toutiao.com/item_seo_url值/info/ 例如获取 美国无人潜航器被中国抓获引爆网络 这篇新闻的内容http://m.toutiao.com/i6364969235889783298/info/ 其中 i6364969235889783298 值为 item_seo_url 可从上面的Api获取得到的信息为&#123; \"_ck\": &#123;&#125;, \"data\": &#123; \"detail_source\": \"诤闻军事\", \"media_user\": &#123; \"avatar_url\": \"http://p2.pstatp.com/large/11543/4356023632\", \"id\": 5866716857, \"screen_name\": \"诤闻军事\" &#125;, \"publish_time\": 1481959884, \"title\": \"美国无人潜航器被中国抓获引爆网络，一中国网友外媒舌战群儒\", \"url\": \"http://toutiao.com/group/6364965628189327618/\", \"is_original\": true, \"is_pgc_article\": true, \"content\": \"&lt;div&gt;&lt;p&gt;据外媒报道，12月15日中国海军一艘南救510打捞救生船，在靠近菲律宾的海域持续跟踪美军海洋测量船鲍迪奇号之后，当着美军的面，将其放出的两艘水下无人航行器之一打捞带走。目前美方已经向中国提起抗议，要求归还无人航行器。&lt;strong&gt;据CNN报道，当时美军鲍迪奇号立刻使用无线电呼叫中国舰艇，但是却没有应答，过了很久之后中国军舰突然回应：有什么事要帮忙吗？我们正在附近巡逻。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=\\\"http://p3.pstatp.com/large/12db0007c12ad2732220\\\" img_width=\\\"938\\\" img_height=\\\"732\\\" alt=\\\"美国无人潜航器被中国抓获引爆网络，一中国网友外媒舌战群儒\\\" onerror=\\\"javascript:errorimg.call(this);\\\"&gt;&lt;/p&gt;&lt;p class=\\\"pgc-img-caption\\\"&gt;鲍迪奇号&lt;/p&gt;&lt;p&gt;类似《华尔街日报》、CNN等媒体，对这一事件都冠以“Breaking News”（重大新闻）的标题，迅速进行了报道，因此也引发了国外网友的讨论。特别有趣的是，在《华尔街日报》网站上，一位网友“&lt;strong&gt;adam w”却独自在外媒网站和拥护美国的外国网友进行了一场激烈的辩论&lt;/strong&gt;。从名字和用语来开，这位网友很可能来自中国。&lt;/p&gt;&lt;p&gt;例如网名“Bryan Jaeck”用户认为，如果中国不归还无人航行器，过一段时间中国就能山寨所有的美国技术来建造自己的无人航行器。美国舰长应该把手放到扳机上发出警告：要么归还要么就去死！“adam w”则回答说：一名间谍被抓获了，现在暴徒说了：如果不交出间谍他们就开战！&lt;/p&gt;&lt;p&gt;网名“Christopher Holland”表示，中国的法律认为：我的是我的，你的也是我的。这就是中国人的想法。偷窃美国政府财产对于中国人来说小菜一碟。&lt;strong&gt;“adam w”则回答说：美国拥有世界上最庞大的间谍网络，不断从中国、俄罗斯窃取机密，甚至连德国、法国这样的盟友都不放过&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;img src=\\\"http://p3.pstatp.com/large/134d0000fb0668a5844f\\\" img_width=\\\"634\\\" img_height=\\\"439\\\" alt=\\\"美国无人潜航器被中国抓获引爆网络，一中国网友外媒舌战群儒\\\" onerror=\\\"javascript:errorimg.call(this);\\\"&gt;&lt;/p&gt;&lt;p class=\\\"pgc-img-caption\\\"&gt;无人潜航器&lt;/p&gt;&lt;p&gt;网名“Timothy corrigan”称：下次中国如果还要这么干，美国就应该把他们都赶出这片水域。应该让附近的潜艇发射战斧导弹到中国的岛礁上去“参观”。中国已经看穿了奥巴马是一个弱者，特朗普应该给中国一个教训。“adam w”回答说：&lt;strong&gt;美国人当着中国舰艇的面释放间谍无人器。中国抓获了它，美国却要以此为借口发动战争。美国暴徒终于显露了自己的本色&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;“Timothy corrigan”回应说：国际海域意味着你不能碰其他人的东西。中国的所作所为是盗窃，应该被严厉惩罚。&lt;strong&gt;美国应该击沉中国舰艇，派遣两个航母编队到南海，如果不够就派三个&lt;/strong&gt;。“adam w”则回答；&lt;strong&gt;真的吗？美国就没有在国际海域抓获其他人的舰艇吗（应该是意指银河号事件）？&lt;/strong&gt;在你谴责其他人搞间谍的时候，其他国家的所有计算机又在被谁监控？美国CIA一直在干这事，你这个伪君子。&lt;/p&gt;&lt;p&gt;网名“michael de martine”认为。为什么美国海军会派遣一艘小型没有武装的测量船到“敌军海域”？这不是成心让中国这个坏人来来搞事吗？“adam w”回应说：派没有武装的测量船到“敌军海域”，还来到中国舰艇的旁边。这件事美国才是事实上的挑衅者。&lt;/p&gt;&lt;p&gt;&lt;img src=\\\"http://p1.pstatp.com/large/134c0002f256279ce44d\\\" img_width=\\\"634\\\" img_height=\\\"444\\\" alt=\\\"美国无人潜航器被中国抓获引爆网络，一中国网友外媒舌战群儒\\\" onerror=\\\"javascript:errorimg.call(this);\\\"&gt;&lt;/p&gt;&lt;p class=\\\"pgc-img-caption\\\"&gt;特朗普的某些举动激怒了中国&lt;br&gt;&lt;/p&gt;&lt;p&gt;网友“WILLIAM A TAYLOR”说，这并不是“敌军海域”而是国际公海。而中国声称对这片国际海域拥有主权。美国有义务保持这一海域的航行自由，但中国去想把其他人排除在外。权利如果没有武力维护就没有任何意义，这就是为什么那么多人要带枪。“adam w”则问道：义务？到底是什么义务？菲律宾已经告诉美国离开他们的海域，不想当美国人对抗中国的马前卒。所以现在是美国打算单枪匹马挑衅中国。到底谁才是恶人？&lt;/p&gt;&lt;p&gt;除了那些为美国鼓噪的人之外，其实还是有清醒者。一位Gioklie Tanthe说到：&lt;strong&gt;美国必须懂得尊重其他国家，才能够得到其他国家的尊重。&lt;/strong&gt;&lt;/p&gt;&lt;/div&gt;&lt;p class=\\\"footnote\\\"&gt;本文为头条号作者原创，未经授权，不得转载。&lt;/p&gt;\", \"source\": \"诤闻军事\", \"video_play_count\": 6 &#125;, \"success\": true&#125; 获取新闻评论http://www.toutiao.com/api/comment/list/?group_id=头条号&amp;item_id=文章号&amp;offset=偏移量&amp;count=数量 例如获取 美国无人潜航器被中国抓获引爆网络 这篇新闻的评论 http://www.toutiao.com/api/comment/list/?group_id=6364965628189327618&amp;item_id=6364969235889783298&amp;offset=0&amp;count=10 其中 group_id 和 item_id 可从上面的Api获取得到的信息为&#123; \"message\": \"success\", \"data\": &#123; \"has_more\": true, \"total\": 2410, \"comments\": [ &#123; \"text\": \"中国是一个负责任的大国，只要美方提供证据证明这东西是美国的，中国可以归还。流程是:美方提供生产厂家原始记录、生产编号，该型号潜航器的设计图纸，以及该次海洋调查任务的详细说明、行动计划等等。中方需要半年左右的调查就可以了。\", \"digg_count\": 4351, \"reply_data\": &#123; \"reply_list\": [] &#125;, \"reply_count\": 176, \"create_time\": 1481964505, \"user\": &#123; \"avatar_url\": \"http://p0.pstatp.com/origin/3793/3131589739\", \"user_id\": 6180186929, \"name\": \"hanxinping1969\" &#125;, \"dongtai_id\": 7105200091, \"user_digg\": 0, \"id\": 52960355361 &#125; ] &#125;&#125; 获取头条号文章http://www.toutiao.com/pgc/ma/?media_id=头条号&amp;page_type=1&amp;count=10&amp;version=2&amp;platform=pc&amp;as=A1C548D5FDB17E6&amp;cp=585DB1871ED64E1&amp;max_behot_time=偏移量 例如获取 国际在线 的文章http://www.toutiao.com/pgc/ma/?media_id=3232597584&amp;page_type=1&amp;max_behot_time=0&amp;count=10&amp;version=2&amp;platform=pc&amp;as=A1C548D5FDB17E6&amp;cp=585DB1871ED64E1 其中 media_id 可从上面的Api获取得到的信息为&#123; \"media_id\": 3232597584, \"has_more\": 1, \"next\": &#123; \"max_behot_time\": 1482474718 &#125;, \"page_type\": 1, \"message\": \"success\", \"data\": [ &#123; \"play_effective_count\": \"0\", \"gallery_pic_count\": 0, \"go_detail_count\": \"62\", \"title\": \"【老外谈】巴基斯坦专家：中央经济工作会议为2017年中国发展奠定基础\", \"image_list\": [ &#123; \"url\": \"http://p2.pstatp.com/list/13c5000a0fe801679b19\", \"pc_url\": \"http://p2.pstatp.com/list/194x108/13c5000a0fe801679b19\" &#125; ], \"abstract\": \"莎菲·哈里（巴基斯坦）一年一度的中央经济工作会议日前在北京召开。与会的领导人们总结中国在2016年的经济工作，并着眼于2017年的经济战略。\", \"show_play_effective_count\": 0, \"middle_mode\": true, \"has_video\": false, \"source_url\": \"http://www.toutiao.com/item/6367207970920464898/\", \"datetime\": \"2016-12-23 16:06\", \"live_status\": \"\", \"more_mode\": false, \"comments_count\": \"0\", \"video_duration_str\": \"00:00\", \"has_gallery\": false, \"pc_image_url\": \"http://p2.pstatp.com/list/126x82/13c5000a0fe801679b19\" &#125; ]&#125; 获取段子获取段子内容http://www.toutiao.com/api/article/feed/?category=essay_joke&amp;as=A115C8457F69B85&amp;cp=585F294B8845EE1 得到的信息为&#123; \"has_more\": true, \"message\": \"success\", \"data\": [ &#123; \"group\": &#123; \"text\": \"地铁上，一个怂孩子在那一直打他妈妈的手。然后他妈妈把手放在了小孩儿的脸上，怂孩子又使劲要打过去，结果他妈妈突然把手给撤开了。就听啪的一声然后就没有然后了。\", \"create_time\": 1483004786, \"id\": 53368972910, \"favorite_count\": 78, \"go_detail_count\": 43711, \"user_favorite\": 0, \"share_type\": 1, \"is_can_share\": 1, \"comment_count\": 81, \"share_url\": \"http://m.neihanshequ.com/share/group/53368972910/?iid=0&amp;amp;app=joke_essay\", \"label\": 1, \"content\": \"地铁上，一个怂孩子在那一直打他妈妈的手。然后他妈妈把手放在了小孩儿的脸上，怂孩子又使劲要打过去，结果他妈妈突然把手给撤开了。就听啪的一声然后就没有然后了。\", \"category_type\": 1, \"id_str\": \"53368972910\", \"media_type\": 0, \"share_count\": 119, \"type\": 3, \"status\": 112, \"has_comments\": 1, \"user_bury\": 0, \"status_desc\": \"热门投稿\", \"user\": &#123; \"is_following\": false, \"avatar_url\": \"http://p3.pstatp.com/thumb/1353000081efff334e3e\", \"user_id\": 6088312852, \"name\": \"蓝筱蝶\", \"user_verified\": false &#125;, \"user_digg\": 0, \"online_time\": 1483004786, \"category_name\": \"内涵段子\", \"category_visible\": false, \"bury_count\": 248, \"is_anonymous\": false, \"repin_count\": 78, \"digg_count\": 7537, \"has_hot_comments\": 1, \"user_repin\": 0, \"activity\": &#123;&#125;, \"group_id\": 53368972910, \"category_id\": 1 &#125;, \"comments\": [ &#123; \"status\": 5, \"user_profile_url\": \"\", \"is_digg\": 0, \"user_id\": 3126306787, \"description\": \"\", \"bury_count\": 0, \"avatar_url\": \"http://p3.pstatp.com/thumb/1354000a27104141c471\", \"text\": \"这个故事，告诉了我们，不要坐地铁\", \"comment_id\": 53372167364, \"user_verified\": false, \"digg_count\": 11343, \"user_profile_image_url\": \"http://p3.pstatp.com/thumb/1354000a27104141c471\", \"platform_id\": \"feifei\", \"platform\": \"feifei\", \"create_time\": 1483011406, \"user_digg\": 0, \"group_id\": 53368972910, \"user_name\": \"哈哈1个大开心\", \"id\": 53372167364, \"user_bury\": 0 &#125; ], \"type\": 1, \"display_time\": 1483101547, \"online_time\": 1483101547 &#125; ], \"next\": &#123; \"max_behot_time\": 1483101547 &#125;&#125; 获取段子评论http://www.toutiao.com/group/段子ID/comments/?count=总数&amp;offset=偏移量&amp;item_id=0&amp;format=json 例如http://www.toutiao.com/group/53404620593/comments/?count=20&amp;offset=0&amp;item_id=0&amp;format=json 其中 段子ID 可从上面的Api获取得到的信息为&#123; \"message\": \"success\", \"data\": &#123; \"comment_pagination\": &#123; \"count\": 1, \"total_count\": 75, \"url_fmt\": \"?offset=%s&amp;amp;count=%s\", \"offset\": 0 &#125;, \"group\": &#123; \"status\": 1, \"type\": 3, \"id\": 53404620593, \"_id\": 892139876 &#125;, \"comments\": [ &#123; \"status\": 1, \"user_uid\": null, \"description\": \"这个用户很懒，神马都木有写\", \"reply_to_user_name\": null, \"reply_to_user_verified\": null, \"text\": \"抽烟害人害己\", \"target_id\": null, \"forum_id\": 0, \"reply_count\": 1, \"reply_to_user_id\": null, \"is_blocked\": 0, \"user_verified\": false, \"user_followers_count\": 0, \"is_blocking\": 0, \"user_id\": 5874570453, \"bury_count\": 0, \"type\": 2, \"digg_count\": 405, \"id\": 53409568162, \"platform_id\": 0, \"rate_score\": 0, \"create_time\": 1483093293, \"user_name\": \"今天回家吃晚饭\", \"user_profile_image_url\": \"http://p9.pstatp.com/thumb/bc3000463d913c1744c\" &#125; ], \"page_display_range\": [ 1, 2, 3, 4, 5, 6, 7 ], \"page\": 1, \"page_size\": 1, \"page_last\": 75 &#125;&#125;","categories":[{"name":"Default","slug":"Default","permalink":"https://imeiji.github.io/categories/Default/"}],"tags":[]},{"title":"eBesucher挂机赚钱教程(LXDE+VNC+restarter)","slug":"eBesucher挂机赚钱教程(LXDE+VNC+restarter)","date":"2016-04-03T08:15:07.000Z","updated":"2017-03-20T12:03:12.000Z","comments":true,"path":"2016/04/03/eBesucher挂机赚钱教程(LXDE+VNC+restarter)/","link":"","permalink":"https://imeiji.github.io/2016/04/03/eBesucher挂机赚钱教程(LXDE+VNC+restarter)/","excerpt":"","text":"ebesucher是德国目前最著名的自动冲浪赚钱站，该站最低提现金额PAYPAL2欧元，此站除了可以通过自动冲浪来赚钱之外，还可以通过邮件交换的方式来赚钱 关于收益也不好说，各个地区的IP不一样，德国IP最值钱，但是德国IP比较贵；其他欧美地区的IP差不多，收益不多，但是好在可以多台VPS同时挂机，要做到支付还是相当轻松的（100000积分=2.1欧元，2欧元起付，Paypal支付）。 挂机条件 VPS内存在512M以上 一个欧洲的IP的VPS 挂机准备 ebesucher注册地址: https://www.ebesucher.com尽量还是要填写真实信息，收款时会验证手机号，请务必国籍填写中国。 必须安装 VNC, 浏览器 可选安装 Java, restarter 安装轻量级桌面LXDE+VNC LXDE，全名为Lightweight X11 Desktop Environment，是一个自由桌面环境，可在Unix以及如Linux、BSD等POSIX相容平台上执行。廉价迷你Linux机器Raspberry Pi安装的就是这个桌面，LXDE支持debian及ubuntu环境。 LXDE桌面安装方法 首先运行updateapt-get update 安装LXDE环境apt-get install xorg lxde-core tightvncserver其中xorg为x window，tightvncserver为vnc server在过程中有一个机器地区选择，我们默认回车就可以。 启动VNC/输入密码tightvncserver :1需要输入vnc密码，提示”Would you like to enter a view-only password (y/n)?”时回车即可 配置xstartup系统文件首先要暂停vnc，可以使用如下代码：tightvncserver -kill :1编辑xstartup文件：vi ~/.vnc/xstartup然后在文件的最后添加下面的脚本代码 lxterminal &amp;/usr/bin/lxsession -s LXDE &amp; 重启VNCtightvncserver :1 LXDE桌面使用方法 使用vnc viewer登陆在这里下载: http://www.realvnc.com/download/viewer/打开客户端，输入IP:590x，这里x是x桌面的编号:连接后输入密码，就可以进入桌面了。 安装浏览器和Flash 建议安装两个浏览器,方便随时切换 安装Firefox # debianapt-get install iceweasel# Ubuntuapt-get install firefox 安装chrome(可选) # 32位wget https://dl.google.com/linux/direct/google-chrome-stable_current_i386.debdpkg -i google-chrome-stable_current_i386.deb# 64位wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.debdpkg -i google-chrome-stable_current_amd64.deb 安装Flash方法一: vi /etc/apt/sources.list# 添加如下源deb ftp://ftp.debian.org/debian stable main contrib non-free# 更新源apt-get update# 安装flashplugin-nonfreeapt-get install flashplugin-nonfree# 安装成功后重启firefox，进入firefox的插件设置页面,看看是否成功 ​ 方法二: wget https://fpdownload.adobe.com/get/flashplayer/pdc/24.0.0.221/flash_player_npapi_linux.x86_64.tar.gztar -zxf flash_player_*_linux.x86_64.tar.gzcp libflashplayer.so /usr/lib/mozilla/plugins/cp -r usr /usr# 最新下载地址 https://get.adobe.com/cn/flashplayer/otherversions/ 安装Java(可选) Debian echo \"deb http://ppa.launchpad.net/webupd8team/java/ubuntu xenial main\" | tee /etc/apt/sources.list.d/webupd8team-java.listecho \"deb-src http://ppa.launchpad.net/webupd8team/java/ubuntu xenial main\" | tee -a /etc/apt/sources.list.d/webupd8team-java.listapt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys EEA14886apt-get updateapt-get install oracle-java8-installer Ubuntu apt-get install python-software-propertie software-properties-commonadd-apt-repository ppa:webupd8team/javaapt-get updateapt-get install oracle-java8-installer# 选择Java版本(可选)update-alternatives --config java 安装restarter(可选) restarter是ebesucher提供的挂机辅助工具，可以在浏览器出现错误（冲浪的网站弹窗，卡死，崩溃等）时自动重启浏览器，这样极大的方便了我们挂机，避免手动维护。 下载restarter wget https://www.ebesucher.com/data/restarter-setup-others.v1.2.03.zipapt-get install unzipunzip restarter-setup-others.v1.2.03.zip 安装好java及restarter之后，通过vnc viewer进入桌面，启动终端界面root Terminal输入以下命令： cd /rootjava -jar restarter.jar 这样就已启动restarter 设置restarter(可选) 启动restarter之后需要对restarter进行设置 输入username和CODE。CODE可以在 http://www.ebesucher.com/restarter.html 中找到 选择语言language有三个选项，到这里查看你的地址 https://www.ebesucher.com/punkteverdienen.html一般我们选择ebesucher.de 选择浏览器优先选择Firefoxchrome需要手动设置路径 /opt/google/chrome/chrome --user-data-dir 点击start surfbar即可启动firefox开始冲浪 开始冲浪 安装 Firefox 插件并设置好你的 username https://www.ebesucher.com/addon.html 检查 flash 是否安装成功 点击插件, 开始挂机 选择一个积分最多的地区 http://www.ebesucher.de/surfbar/usernamehttp://www.ebesucher.com/surfbar/usernamehttp://www.ebesucher.ru/surfbar/usernamehttp://www.ebesucher.es/surfbar/usernamehttp://www.ebesucher.fr/surfbar/username ​ 优化 浏览器不保存历史记录这一点比较重要，因为你一直在冲浪如果保存历史记录，会导致大量的记录文件。进入firefox的preferences-privacy-history，设置为never remember history 制作脚本,定时重启浏览器及restarter Firefox vi /root/Desktop/restart_ff.sh写入以下内容 #!/bin/shexport DISPLAY=localhost:1.0cd /rootrm -rf ~/.vnc/*.log /tmp/plugtmp* &gt; /dev/null 2&gt;&amp;1killall firefox &gt; /dev/null 2&gt;&amp;1killall java &gt; /dev/null 2&gt;&amp;1/usr/bin/firefox --new-tab http://www.ebesucher.com/surfbar/username &gt; /dev/null 2&gt;&amp;1 /usr/bin/java -jar /root/restarter.jar &gt; /dev/null 2&gt;&amp;1 其中，http://www.ebesucher.com/surfbar/username中的username改为你的用户名 给脚本添加可执行权限 chmod a+x /root/Desktop/restart_ff.sh 编辑cron vi /etc/crontab 设置每小时执行一次该脚本 0 * * * * root /root/Desktop/restart_ff.sh 重启cron service cron restart chrome vi /root/Desktop/restart_ch.sh 写入以下内容 #!/bin/shexport DISPLAY=localhost:1.0cd /rootrm -rf ~/.vnc/*.log /tmp/plugtmp* &gt; /dev/null 2&gt;&amp;1killall java &gt; /dev/null 2&gt;&amp;1killall chrome &gt; /dev/null 2&gt;&amp;1/opt/google/chrome/chrome --new-tab http://www.ebesucher.com/surfbar/username --user-data-dir &gt; /dev/null 2&gt;&amp;1 /usr/bin/java -jar /root/restarter.jar &gt; /dev/null 2&gt;&amp;1 其中，http://www.ebesucher.com/surfbar/username中的username改为你的用户名 给脚本添加可执行权限 chmod a+x /root/Desktop/restart_ch.sh 编辑cron vi /etc/crontab 设置每小时执行一次该脚本 0 * * * * root /root/Desktop/restart_ch.sh 重启cron service cron restart 3.使用 cpulimit 限制 firefox 的使用, 防止卡死 apt-get install cpulimit# 限制firefox使用50% cpu 利用率cpulimit -e firefox -l 50 &gt; /dev/null 2&gt;&amp;1 &amp; 使用docker使用docker挂机 详细教程查看 https://github.com/iMeiji/arukas-docker 参考TENNFY WU » Ebesucher debian vps挂机教程之restarter篇","categories":[{"name":"VPS","slug":"VPS","permalink":"https://imeiji.github.io/categories/VPS/"}],"tags":[]},{"title":"搭建h5ai文件服务器","slug":"搭建h5ai文件服务器","date":"2016-03-26T09:16:34.000Z","updated":"2017-08-12T13:18:09.000Z","comments":true,"path":"2016/03/26/搭建h5ai文件服务器/","link":"","permalink":"https://imeiji.github.io/2016/03/26/搭建h5ai文件服务器/","excerpt":"","text":"h5ai是一款不错的php目录列表程序，也就是php列目录工具,支持apache和nginx官网 https://larsjung.de/h5ai/ 介绍 h5ai is a modern file indexer for HTTP web servers with focus on your files. Directories are displayed in a appealing way and browsing them is enhanced by different views, a breadcrumb and a tree overview. Initially h5ai was an acronym for HTML5 Apache Index but now it supports other web servers too. Requires PHP 5.5+ and works fine with Apache httpd, lighttpd, nginx and Cherokee. 安装依赖一条命令安装LAMPapt-get install mysql-server mysql-client apache2 php5 php5-cli libapache2-mod-php5 php5-mysql php5-curl php5-gd php-pear php5-imagick php5-mcrypt php5-memcache php5-mhash php5-sqlite php5-xmlrpc php5-xsl php5-json php5-dev libpcre3-dev 安装h5aicd /var/www/html# wget https://release.larsjung.de/h5ai/h5ai-0.28.1.zip 旧版本有 搜索/打包下载 等功能wget https://release.larsjung.de/h5ai/h5ai-0.29.0.zipapt-get install unzip unzip h5ai*.zip 查看h5ai配置打开http://YOUR-DOMAIN.TLD/_h5ai/public/index.php Cache directory这个是系统文件夹的权限，分别修改public和private文件夹里的cache文件夹就可以正常 cd _h5aichmod 666 private/cache chmod 666 public/cache Movie thumbs视频预览,执行:apt-get install libav-tools PDF thumbsPDF预览,执行: apt-get install aptitudeaptitude install imagemagick Shell zipzip预览,执行:apt-get install zip 配置web服务器将/_h5ai/public/index.php添加到web服务器配置文件中默认首页文件列表代码的最后位置 Apache2cd /etc/apache2/sites-available/修改配置文件,增加一行DirectoryIndex index.html index.php /_h5ai/public/index.php然后执行a2enmod rewrite最后service apache2 reload Nginx 对应的nginx配置文件中找到如下一行 index index.html index.php 改为 index index.html index.php /_h5ai/public/index.php 最后service nginx reload 正常安装后，文件放置到和_h5ai平级目录就可以，当然也可以建立文件夹等等 使用 LNMP 一键包的要删除 PHP 禁用函数 编辑 /usr/local/php/etc/php.ini 将 scandir exec passthru 三个函数删除, 并保存重启lnmp 参考h5ai-默默的文件分享系统","categories":[{"name":"VPS","slug":"VPS","permalink":"https://imeiji.github.io/categories/VPS/"}],"tags":[]},{"title":"在Linux上安装deluge实现BT离线下载","slug":"在Linux上安装deluge实现BT离线下载","date":"2016-03-26T07:47:34.000Z","updated":"2016-03-31T15:10:32.000Z","comments":true,"path":"2016/03/26/在Linux上安装deluge实现BT离线下载/","link":"","permalink":"https://imeiji.github.io/2016/03/26/在Linux上安装deluge实现BT离线下载/","excerpt":"","text":"官网 http://dev.deluge-torrent.org/项目地址 https://github.com/deluge-torrent/deluge GTK UI for the desktopWeb UI for the browserConsole UI for the command line 有三种版本,我们这里只安装Web UI 从软件源安装 Ubuntu apt-get install python-software-properties software-properties-commonadd-apt-repository ppa:deluge-team/ppaapt-get updateapt-get install deluged deluge-web deluge-webui Debian apt-get updateapt-get install deluged deluge-web deluge-webui 其他系统请参考官网的教程 http://dev.deluge-torrent.org/wiki/Download http://dev.deluge-torrent.org/wiki/Installing 从源码编译安装Debian &amp; Ubuntu 安装依赖apt-get install python python-twisted python-openssl python-setuptools intltool python-xdg python-chardet geoip-database python-libtorrent python-notify python-pygame python-glade2 librsvg2-common xdg-utils python-mako 编译安装ftp下载 GitHub下载wget http://download.deluge-torrent.org/source/deluge-1.3.12.tar.gztar zxf deluge*.tar.gzcd deluge*python setup.py buildpython setup.py install 启动正常启动deluge-webGo to http://localhost:8112/ default-password = &quot;deluge&quot; 指定端口启动deluge-web -f -p 54321 后台运行# 安装screenapt-get install screen# 建立一个名为deluge的后台screen，方便后续切换，此名字可随意命名screen -S &quot;deluge&quot;# 在新的screen窗口里输入deluge-web# 此时终端会持续运行，要将其切换到后台，按下ctrl+a+d键，将当前screen切换到后台，后续通过执行screen -r deluge# 即可切回此窗口，这时再去停止服务很方便 参考官方wiki在Ubuntu 14.04上安装deluge实现在VPS上进行bt离线下载","categories":[{"name":"VPS","slug":"VPS","permalink":"https://imeiji.github.io/categories/VPS/"}],"tags":[]},{"title":"GitHub Pages 折腾笔记","slug":"GitHub Pages 折腾笔记","date":"2016-01-15T03:34:34.000Z","updated":"2016-01-15T07:44:31.000Z","comments":true,"path":"2016/01/15/GitHub Pages 折腾笔记/","link":"","permalink":"https://imeiji.github.io/2016/01/15/GitHub Pages 折腾笔记/","excerpt":"","text":"玩转多说 多说评论评论的出色的开放性和可定制性，让我们可以通过自定义CSS，给我们的评论栏带来更多的想象力：圆角头像、触发动画效果、阴影神马的当然不在话下。 自定义CSS路径：多说后台管理--设置--基本设置--自定义CSS 自定义头像动画 圆角(或者圆形)+阴影#ds-reset .ds-avatar img&#123; width:54px;height:54px; /*设置图像的长和宽*/ border-radius: 27px;/*设置图像圆角效果,在这里我直接设置了超过width/2的像素，即为圆形了*/ -webkit-border-radius: 27px;/*圆角效果：兼容webkit浏览器*/ -moz-border-radius:27px; box-shadow: inset 0 -1px 0 #3333sf;/*设置图像阴影效果*/ -webkit-box-shadow: inset 0 -1px 0 #3333sf;&#125; 鼠标悬浮时:图像进行360度旋转#ds-reset .ds-avatar img&#123; width:54px;height:54px; /*设置图像的长和宽*/ border-radius: 27px;/*设置图像圆角效果,在这里我直接设置了超过width/2的像素，即为圆形了*/ -webkit-border-radius: 27px;/*圆角效果：兼容webkit浏览器*/ -moz-border-radius:27px; box-shadow: inset 0 -1px 0 #3333sf;/*设置图像阴影效果*/ -webkit-box-shadow: inset 0 -1px 0 #3333sf; -webkit-transition: 0.4s; -webkit-transition: -webkit-transform 0.4s ease-out; transition: transform 0.4s ease-out;/*变化时间设置为0.4秒(变化动作即为下面的图像旋转360读）*/ -moz-transition: -moz-transform 0.4s ease-out;&#125; #ds-reset .ds-avatar img:hover&#123;/*设置鼠标悬浮在头像时的CSS样式*/ box-shadow: 0 0 10px #fff; rgba(255,255,255,.6), inset 0 0 20px rgba(255,255,255,1); -webkit-box-shadow: 0 0 10px #fff; rgba(255,255,255,.6), inset 0 0 20px rgba(255,255,255,1); transform: rotateZ(360deg);/*图像旋转360度*/ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); &#125; 鼠标悬浮时:图像放大缩小#ds-reset .ds-avatar img,#ds-reset .ds-avatar img:hover&#123; -webkit-animation-fill-mode: both; -moz-animation-fill-mode: both; -ms-animation-fill-mode: both; -o-animation-fill-mode: both; animation-fill-mode: both; -webkit-animation-duration: 0s; -moz-animation-duration: 0s; -ms-animation-duration: 0s; -o-animation-duration: 0s; animation-duration: 0s; -webkit-animation-duration: 0.7s; -moz-animation-duration: 0.7s; -ms-animation-duration: 0.7s; -o-animation-duration: 0.7s; animation-duration: 0.7s; &#125; @-webkit-keyframes bounceIn &#123; 0% &#123; opacity: 0; -webkit-transform: scale(.3); &#125; 50% &#123; opacity: 1; -webkit-transform: scale(1.05); &#125; 70% &#123; -webkit-transform: scale(.9); &#125; 100% &#123; -webkit-transform: scale(1); &#125; &#125; @-moz-keyframes bounceIn &#123; 0% &#123; opacity: 0; -moz-transform: scale(.3); &#125; 50% &#123; opacity: 1; -moz-transform: scale(1.05); &#125; 70% &#123; -moz-transform: scale(.9); &#125; 100% &#123; -moz-transform: scale(1); &#125; &#125; @-o-keyframes bounceIn &#123; 0% &#123; opacity: 0; -o-transform: scale(.3); &#125; 50% &#123; opacity: 1; -o-transform: scale(1.05); &#125; 70% &#123; -o-transform: scale(.9); &#125; 100% &#123; -o-transform: scale(1); &#125; &#125; @keyframes bounceIn &#123; 0% &#123; opacity: 0; transform: scale(.3); &#125; 50% &#123; opacity: 1; transform: scale(1.05); &#125; 70% &#123; transform: scale(.9); &#125; 100% &#123; transform: scale(1); &#125; &#125; #ds-reset .ds-avatar img &#123; -webkit-animation-name: bounceIn; -moz-animation-name: bounceIn; -o-animation-name: bounceIn; animation-name: bounceIn; &#125; @-webkit-keyframes bounceOut &#123; 0% &#123; -webkit-transform: scale(1); &#125; 25% &#123; -webkit-transform: scale(.95); &#125; 50% &#123; opacity: 1; -webkit-transform: scale(1.1); &#125; 100% &#123; opacity: 0; -webkit-transform: scale(.3); &#125; &#125; @-moz-keyframes bounceOut &#123; 0% &#123; -moz-transform: scale(1); &#125; 25% &#123; -moz-transform: scale(.95); &#125; 50% &#123; opacity: 1; -moz-transform: scale(1.1); &#125; 100% &#123; opacity: 0; -moz-transform: scale(.3); &#125; &#125; @-o-keyframes bounceOut &#123; 0% &#123; -o-transform: scale(1); &#125; 25% &#123; -o-transform: scale(.95); &#125; 50% &#123; opacity: 1; -o-transform: scale(1.1); &#125; 100% &#123; opacity: 0; -o-transform: scale(.3); &#125; &#125; @keyframes bounceOut &#123; 0% &#123; transform: scale(1); &#125; 25% &#123; transform: scale(.95); &#125; 50% &#123; opacity: 1; transform: scale(1.1); &#125; 100% &#123; opacity: 0; transform: scale(.3); &#125; &#125; #ds-reset .ds-avatar img:hover&#123; -webkit-animation-name: bounceOut; -moz-animation-name: bounceOut; -o-animation-name: bounceOut; animation-name: bounceOut; &#125; 评论显示User Agent 下载embed.js多说官方(已失效)下载我当前使用的 获取多说ID访问多说后台，http://duoshuo.com/settings/ ，点击你的用户名，地址栏中会出现如如下的ID地址http://duoshuo.com/profile/6232054888176550658/ 本地修改embed.js修改e.user_id为你的多说ID //管理员判断开始function sskadmin(e) &#123; var ssk = &apos;&apos;; if(e.user_id==6232054888176550658)&#123; ssk = &apos;&lt;span class=&quot;sskadmin&quot;&gt;admin&apos; &#125; return ssk+&quot;&lt;/span&gt; &quot;;&#125;//管理员判断结束 上传embed.js我的做法是上传到GitHub,仓库的分支必须是gh-pages才行,master分支会失效,原因未知.如果你有服务器也可以上传到那. 修改多说调用地址多说调用文件为next\\layout\\_scripts\\comments\\duoshuo.swig其他主题估计差不多修改ds.src的js地址为你刚刚上传的地址 &lt;script type=&quot;text/javascript&quot;&gt; var duoshuoQuery = &#123;short_name:&quot;&#123;&#123;duoshuo_shortname&#125;&#125;&quot;&#125;; (function() &#123; var ds = document.createElement(&apos;script&apos;); ds.type = &apos;text/javascript&apos;;ds.async = true; ds.id = &apos;duoshuo-script&apos;; ds.src = (document.location.protocol == &apos;https:&apos; ? &apos;https:&apos; : &apos;http:&apos;) + &apos;//imeiji.info/gitDemo/embed.js&apos;; ds.charset = &apos;UTF-8&apos;; (document.getElementsByTagName(&apos;head&apos;)[0] || document.getElementsByTagName(&apos;body&apos;)[0]).appendChild(ds); &#125;)(); &lt;/script&gt; 自定义后台CSS /*多说UA开始*/span.ua&#123; margin: 0 1px!important; color:#FFFFFF!important; /*text-transform: Capitalize!important; float: right!important; line-height: 18px!important;*/&#125;.ua_other.os_other&#123; background-color: #ccc!important; color: #fff; border: 1px solid #BBB!important; border-radius: 4px;&#125;.ua_ie&#123; background-color: #428bca!important; border-color: #357ebd!important; border-radius: 4px; padding: 0 5px!important;&#125;.ua_firefox&#123; background-color: #f0ad4e!important; border-color: #eea236!important; border-radius: 4px; padding: 0 5px!important;&#125;.ua_maxthon&#123; background-color: #7373B9!important; border-color: #7373B9!important; border-radius: 4px; padding: 0 5px!important;&#125;.ua_ucweb&#123; background-color: #FF740F!important; border-color: #d43f3a!important; border-radius: 4px; padding: 0 5px!important;&#125;.ua_sogou&#123; background-color: #78ACE9!important; border-color: #4cae4c!important; border-radius: 4px; padding: 0 5px!important;&#125;.ua_2345explorer&#123; background-color: #2478B8!important; border-color: #4cae4c!important; border-radius: 4px; padding: 0 5px!important;&#125;.ua_2345chrome&#123; background-color: #F9D024!important; border-color: #4cae4c!important; border-radius: 4px; padding: 0 5px!important;&#125;.ua_mi&#123; background-color: #FF4A00!important; border-color: #4cae4c!important; border-radius: 4px; padding: 0 5px!important;&#125;.ua_lbbrowser&#123; background-color: #FC9D2E!important; border-color: #4cae4c!important; border-radius: 4px; padding: 0 5px!important;&#125;.ua_chrome&#123; background-color: #EE6252!important; border-color: #4cae4c!important; border-radius: 4px; padding: 0 5px!important;&#125;.ua_qq&#123; background-color: #3D88A8!important; border-color: #4cae4c!important; border-radius: 4px; padding: 0 5px!important;&#125;.ua_apple&#123; background-color: #E95620!important; border-color: #4cae4c!important; border-radius: 4px; padding: 0 5px!important;&#125;.ua_opera&#123; background-color: #d9534f!important; border-color: #d43f3a!important; border-radius: 4px; padding: 0 5px!important;&#125;.os_vista,.os_2000,.os_windows,.os_xp,.os_7,.os_8,.os_8_1 &#123; background-color: #39b3d7!important; border-color: #46b8da!important; border-radius: 4px; padding: 0 5px!important;&#125;.os_android &#123; background-color: #98C13D!important; border-color: #01B171!important; border-radius: 4px; padding: 0 5px!important;&#125;.os_ubuntu&#123; background-color: #DD4814!important; border-color: #01B171!important; border-radius: 4px; padding: 0 5px!important;&#125;.os_linux &#123; background-color: #3A3A3A!important; border-color: #1F1F1F!important; border-radius: 4px; padding: 0 5px!important;&#125;.os_mac&#123; background-color: #666666!important; border-color: #1F1F1F!important; border-radius: 4px; padding: 0 5px!important;&#125;.os_unix&#123; background-color: #006600!important; border-color: #1F1F1F!important; border-radius: 4px; padding: 0 5px!important;&#125;.os_nokia&#123; background-color: #014485!important; border-color: #1F1F1F!important; border-radius: 4px; padding: 0 5px!important;&#125;.sskadmin&#123;background-color: #00a67c!important; border-color: #01B171!important; border-radius: 4px; padding: 0 5px!important;&#125;/*多说UA结束*/ 站点访问计数 站点访问计数我使用的是不蒜子使用非常方便，只需一行脚本+一行标签 显示站点总访问量 我们使用的是hexo，所以要找到网站的布局文件，不同的主题的布局文件可能不一样，下面教程是针对NexT主题做出的修改。 找到站点的themes/next/layout/_partials目录下的footer.swig文件,将以下脚本和标签插入到文件中 &lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;本站总访问量 &lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt; &amp;nbsp&amp;nbsp&amp;nbsp您是第&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;个来到的小伙伴 插入到这里 &lt;div class=&quot;powered-by&quot;&gt; &#123;&#123; __(&apos;footer.powered&apos;, &apos;&lt;a class=&quot;theme-link&quot; href=&quot;http://hexo.io&quot;&gt;Hexo&lt;/a&gt;&apos;) &#125;&#125;&lt;/div&gt;&lt;div class=&quot;theme-info&quot;&gt; &#123;&#123; __(&apos;footer.theme&apos;) &#125;&#125; - &lt;a class=&quot;theme-link&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot;&gt; NexT&#123;% if theme.scheme %&#125;.&#123;&#123; theme.scheme &#125;&#125;&#123;% endif %&#125; &lt;/a&gt;&lt;/div&gt;# 插入到这里&#123;% block footer %&#125;&#123;% endblock %&#125; 显示单页面访问量 不蒜子目前是不支持在首页显示每篇博文的计数的，而且NexT主题中，首页文章显示跟具体文章显示会用到同一个模板文件(themes/next/layout/_macro目录下的post.swig文件)，所以我们需要稍微修改一下模板的代码。 修改themes/next/layout/_macro目录下的post.swig文件位于文件开头,在第三个参数的位置,增加is_pv字段 &#123;% macro render(post, is_index, is_pv, post_extra_class) %&#125; 插入以下代码，用于区分文章页面跟首页这里不用像”显示站点总访问量”中那样安装脚本，否则会出现重复计数的问题。 &#123;% if is_pv %&#125;&lt;span&gt;&amp;nbsp; | &amp;nbsp;&lt;span id=&quot;busuanzi_value_page_pv&quot; &gt;&lt;/span&gt;次阅读&lt;/span&gt; &#123;% endif %&#125; 插入这个位置 &#123;% if post.comments %&#125; &#123;% if (theme.duoshuo and theme.duoshuo.shortname) or theme.duoshuo_shortname %&#125; &lt;span class=&quot;post-comments-count&quot;&gt; &amp;nbsp; | &amp;nbsp; &lt;a href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;#comments&quot; itemprop=&quot;discussionUrl&quot;&gt; &lt;span class=&quot;post-comments-count ds-thread-count&quot; data-thread-key=&quot;&#123;&#123; post.path &#125;&#125;&quot; itemprop=&quot;commentsCount&quot;&gt;&lt;/span&gt; &lt;/a&gt; &lt;/span&gt; &#123;% elseif theme.disqus_shortname %&#125; &lt;span class=&quot;post-comments-count&quot;&gt; &amp;nbsp; | &amp;nbsp; &lt;a href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;#comments&quot; itemprop=&quot;discussionUrl&quot;&gt; &lt;span class=&quot;post-comments-count disqus-comment-count&quot; data-disqus-identifier=&quot;&#123;&#123; post.path &#125;&#125;&quot; itemprop=&quot;commentsCount&quot;&gt;&lt;/span&gt; &lt;/a&gt; &lt;/span&gt; &#123;% endif %&#125; &#123;% endif %&#125; # 插入到这里 &lt;/div&gt; &lt;/header&gt; 修改themes/next/layout目录下的post.swig文件 这个文件是文章的模板找到以下代码，给render方法传入刚才第一步中设置的参数。 &#123;% block content %&#125; &lt;div id=&quot;posts&quot; class=&quot;posts-expand&quot;&gt; #render方法第二个参数is_index为是否为首页 #第三个参数is_pv为我们刚才设置的是否显示计数 &#123;&#123; post_template.render(page, false, true) &#125;&#125; &lt;div class=&quot;post-spread&quot;&gt; &#123;% if theme.jiathis %&#125; &#123;% include &apos;_partials/share/jiathis.swig&apos; %&#125; &#123;% elseif theme.duoshuo_shortname and theme.duoshuo_share %&#125; &#123;% include &apos;_partials/share/duoshuo_share.swig&apos; %&#125; &#123;% endif %&#125; &lt;/div&gt; &lt;/div&gt;&#123;% endblock %&#125; 修改themes/next/layout目录下的index.swig文件这个文件是首页的模板找到以下代码，给render方法传入刚才第一步中设置的参数。 &#123;% block content %&#125; &lt;section id=&quot;posts&quot; class=&quot;posts-expand&quot;&gt; &#123;% for post in page.posts %&#125; #render方法第二个参数is_index为是否为首页 #第三个参数is_pv为我们刚才设置的是否显示计数 &#123;&#123; post_template.render(post, true, false) &#125;&#125; &#123;% endfor %&#125; &lt;/section&gt; &#123;% include &apos;_partials/pagination.swig&apos; %&#125;&#123;% endblock %&#125; 至此，我们的站点计数功能就做好了~ 参考:多说评论也玩圆角头像动画「自定义CSS:无压力小白级教程」多说自定义CSS 让你的多说评论动感起来多说评论框UA显示/博主标记Hexo搭建GitHub博客（三）- NexT主题配置使用","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://imeiji.github.io/categories/Hexo/"}],"tags":[]},{"title":"Hello World","slug":"Hello World","date":"2015-12-25T06:10:54.000Z","updated":"2015-12-26T06:25:37.000Z","comments":true,"path":"2015/12/25/Hello World/","link":"","permalink":"https://imeiji.github.io/2015/12/25/Hello World/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[{"name":"Default","slug":"Default","permalink":"https://imeiji.github.io/categories/Default/"}],"tags":[]}]}