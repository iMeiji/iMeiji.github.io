<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>这是个标题</title>
  
  <subtitle>这是个子标题</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://imeiji.github.io/"/>
  <updated>2018-08-11T09:10:51.000Z</updated>
  <id>https://imeiji.github.io/</id>
  
  <author>
    <name>iMeiji</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android 开发艺术探索 - 第三章笔记</title>
    <link href="https://imeiji.github.io/2018/08/10/Android%20%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%20-%20%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://imeiji.github.io/2018/08/10/Android 开发艺术探索 - 第三章笔记/</id>
    <published>2018-08-09T16:15:15.000Z</published>
    <updated>2018-08-11T09:10:51.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="3-1-View-基础知识"><a href="#3-1-View-基础知识" class="headerlink" title="3.1 View 基础知识"></a>3.1 View 基础知识</h3><h4 id="3-1-1-什么是-View"><a href="#3-1-1-什么是-View" class="headerlink" title="3.1.1 什么是 View"></a>3.1.1 什么是 View</h4><p>View 是 Android 中所有控件的基类，View 是一种界面层的控件的一种抽象，它代表了一个控件（如：Button、TextView）。除了 View 还有 ViewGroup，可以理解为控件组，它内部包含了许多个控件，即一组 View。在 Android 设计中，ViewGroup 也继承了 View，这就意味 View 本身就可以是单个控件也可以是多个控件组成的一组控件，通过这种关系就形成了 View 树，这和 Web 前端中的 DOM 树的概念是相识的。</p><h4 id="3-1-2-View-的位置参数"><a href="#3-1-2-View-的位置参数" class="headerlink" title="3.1.2 View 的位置参数"></a>3.1.2 View 的位置参数</h4><p>View 的位置主要由它的四个定点来决定，分别对应于 View 的四个属性：top、left、right、bottom。在 Android 中，x 轴和 y 轴的正方向分别为右和下。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/10/5b6daf240078d.png" alt="View的位置坐标和父容器的关系.png" title="">                </div>                <div class="image-caption">View的位置坐标和父容器的关系.png</div>            </figure><p>根据 View 的宽高和坐标的关系，得出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">width = right - left</span><br><span class="line">height = bottom - top</span><br></pre></td></tr></table></figure><p>解释部分参数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// View 的四个属性</span><br><span class="line">left = getLeft();</span><br><span class="line">right = getRight();</span><br><span class="line">top = getTop();</span><br><span class="line">bottom = getBottom();</span><br><span class="line"></span><br><span class="line">// x、y 是 View 左上角的坐标</span><br><span class="line">x = getX(); </span><br><span class="line">y = getY();</span><br><span class="line"></span><br><span class="line">// View 左上角相对于父容器的偏移量</span><br><span class="line">translationX = getTranslationX()</span><br><span class="line">translationY = getTranslationY()</span><br><span class="line"></span><br><span class="line">// 换算关系</span><br><span class="line">y = top + translationY</span><br></pre></td></tr></table></figure><h4 id="3-1-3-MotionEvent-和-TouchSlop"><a href="#3-1-3-MotionEvent-和-TouchSlop" class="headerlink" title="3.1.3 MotionEvent 和 TouchSlop"></a>3.1.3 MotionEvent 和 TouchSlop</h4><ul><li><p>MotionEvent</p><p>在手指接触屏幕后所产生的一系列事件中，典型的事件类型有如下几种：</p><ul><li>ACTION_DOWM 手指刚接触屏幕</li><li>ACTION_MOVE 手指在屏幕上移动</li><li>ACTION_UP 手指从屏幕上松开的一瞬间</li></ul><p>正常情况下，一次手指触摸屏幕的行为会触发一系列点击事件，考虑如下几种形况：</p><ul><li>点击屏幕后离开松开，事件序列为 DOWN -&gt; UP</li><li>点击屏幕滑动一会儿再松开，事件序列为 DOWN -&gt; MOVE -&gt; …. &gt; MOVE -&gt; UP</li></ul></li><li><p>TouchSlop</p><p>TouchSlop 是系统所能识别出的被认为是滑动的最小距离。当手指在屏幕上滑动，如果两次滑动之间的距离小于这个常量，那么系统就不认为你是在进行滑动操作。</p><p>通过以下方式获取这个常量：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ViewConfiguration.get(getContext()).getScaledTouchSlop();</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-1-4-VelocityTracker、GestureDetector-和-Scroller"><a href="#3-1-4-VelocityTracker、GestureDetector-和-Scroller" class="headerlink" title="3.1.4 VelocityTracker、GestureDetector 和 Scroller"></a>3.1.4 VelocityTracker、GestureDetector 和 Scroller</h4><ol><li><p>VelocityTracker</p><p>速度追踪，用于追踪手指在滑动过程中的速度，包括水平和竖直方向的速度。速度的计算公式如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">速度 = （终点位置 - 起点位置）/ 时间段</span><br></pre></td></tr></table></figure><p>使用方式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 首先在 View 的 onTouchEvent 方法中追踪当前单击事件的速度</span><br><span class="line">VelocityTracker vt = VelocityTracker.obtain();</span><br><span class="line">vt.addMovement(event);</span><br><span class="line">// 计算速度</span><br><span class="line">vt.computeCurrentVelocity(1000);</span><br><span class="line">// 获取速度</span><br><span class="line">getXVelocity()；</span><br><span class="line">getYVelocity()</span><br><span class="line">// 重置和回收</span><br><span class="line">vt.clear();</span><br><span class="line">vt.recycler();</span><br></pre></td></tr></table></figure></li><li><p>GestureDetector</p><p>手势检测，用于辅助检测用户的单击、滑动、长按、双击等行为。如果只是监听滑动相关的，建议自己在 onTouchEvent 中实现，如果想要监听双击这种行为，那么就用 GestureDetecort。</p><p>使用方式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GestureDetector mGes = new GestureDetector(this);</span><br><span class="line">// 接管目标 View 的 onTouchEvent 方法</span><br><span class="line">boolean consume = mGes.onTouchEvent(event);</span><br><span class="line">return consume;</span><br></pre></td></tr></table></figure></li><li><p>Scroller</p><p>弹性滑动对象，用于实现View的弹性滑动。Scroller本身无法让View弹性滑动，它需要和 View 的computeScroll 方法配合使用才能共同完成这个功能。 </p><p>使用方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scroller mScroller = <span class="keyword">new</span> Scroller(getContext());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓慢滑动到指定位置，1000 ms</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">smoothScrollTo</span><span class="params">(<span class="keyword">int</span> destX, <span class="keyword">int</span> destY)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> scrollX = getScrollX();</span><br><span class="line">        <span class="keyword">int</span> delta = destX - scrollX;</span><br><span class="line">        mScroller.startScroll(scrollX, <span class="number">0</span>, delta, <span class="number">0</span>, <span class="number">1000</span>);</span><br><span class="line">        invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (scroller.computeScrollOffset()) &#123;</span><br><span class="line">            scrollTo(mScroller.getCurrX(),mScroller.getCurrY());</span><br><span class="line">            postInvalidate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-2-View-的滑动"><a href="#3-2-View-的滑动" class="headerlink" title="3.2 View 的滑动"></a>3.2 View 的滑动</h3><p>通过三种方式可以实现 View 的滑动</p><ul><li>第一种是通过 View 本身提供的 scrollTo/scrollBy 方法来实现滑动</li><li>第二种是通过动画给 View 施加平移效果来实现滑动</li><li>通过改变 View 的 LayoutParams 使得 View 重新布局从而实现滑动</li></ul><h4 id="3-2-1-使用-scrollTo-scrollBy"><a href="#3-2-1-使用-scrollTo-scrollBy" class="headerlink" title="3.2.1 使用 scrollTo/scrollBy"></a>3.2.1 使用 scrollTo/scrollBy</h4><p>scrollTo 和 scrollBy 方法只能改变 view 内容的位置而不能改变 view 在布局中的位置。 scrollBy 是基于当前位置的相对滑动，而 scrollTo 是基于所传参数的绝对滑动。通过 View 的 getScrollX 和 getScrollY 方法可以得到滑动的距离。</p><h4 id="3-2-2-使用动画"><a href="#3-2-2-使用动画" class="headerlink" title="3.2.2 使用动画"></a>3.2.2 使用动画</h4><p>使用动画来移动 View 主要是操作view的 translationX 和 translationY 属性，既可以使用传统的 View 动画，也可以使用属性动画。</p><h4 id="3-2-3-改变布局参数"><a href="#3-2-3-改变布局参数" class="headerlink" title="3.2.3 改变布局参数"></a>3.2.3 改变布局参数</h4><p>通过改变 LayoutParams 的方式去实现 View 的滑动是一种灵活的方法。</p><h4 id="3-2-4-各种滑动方式的对比"><a href="#3-2-4-各种滑动方式的对比" class="headerlink" title="3.2.4 各种滑动方式的对比"></a>3.2.4 各种滑动方式的对比</h4><ul><li>scrollTo/scrollBy：操作简单，适合对 View 内容的滑动</li><li>动画：操作简单，主要适用于没有交互的 View 和实现复杂的动画效果</li><li>改变布局参数：操作稍微复杂，适用于有交互的 View</li></ul><h3 id="3-4-View-的事件分发机制"><a href="#3-4-View-的事件分发机制" class="headerlink" title="3.4 View 的事件分发机制"></a>3.4 View 的事件分发机制</h3><h4 id="3-4-1-事件分发机制的三个重要方法"><a href="#3-4-1-事件分发机制的三个重要方法" class="headerlink" title="3.4.1 事件分发机制的三个重要方法"></a>3.4.1 事件分发机制的三个重要方法</h4><ul><li>public boolean dispatchTouchEvent(MotionEvent ev)</li></ul><p>用来进行事件的分发。如果事件能够传递给当前的 View，那么此方法一定会被调用，返回结果受当前 View 的onTouchEvent 和下级 View 的 dispatchTouchEvent 方法的影响，表示是否消耗当前事件。</p><ul><li>public boolean onInterceptTouchEvent(MotionEvent event)</li></ul><p>在上述方法内部调用，用来判断是否拦截某个事件，如果当前 View 拦截了某个事件，那么在同一个事件序列当中，此方法不会被再次调用，返回结果表示是否拦截当前事件。</p><ul><li>public boolean onTouchEvent(MotionEvent event)</li></ul><p>在 dispatchTouchEvent 方法中调用，用来处理点击事件，返回结果表示是否消耗当前的事件，如果不消耗，则在同一个事件序列中，当前 View 无法再次接受到事件。</p><p>这三个方法的关系可以用如下伪代码表示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> consume = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span>(onInterceptTouchEvent(ev))</span><br><span class="line">&#123;</span><br><span class="line">consume = onTouchEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">consume = child.dispatchTouchEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> consume;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以大致了解点击事件的传递规则：对于一个根 ViewGroup 来说，点击事件产生后，首先会传递给它，这时它的 dispatchTouchEvent 会被调用，如果这个 ViewGroup 的 onInterceptTouchEvent 方法返回 true 就表示它要拦截当前事件，接着事件就会交给这个 ViewGroup 处理，即它的 onTouchEvent 方法就会被调用；如果这个 ViewGroup 的 onInterceptTouchEvent 方法返回 false 就表示它不拦截当前事件，这时当前事件就会继续传递给它的子元素，接着子元素的 dispatchTouchEvent 方法就会被调用，如此反复直到事件被最终处理。</p><p><strong>OnTouchListener 的优先级比 onTouchEvent 要高</strong></p><p>如果给一个 View 设置了 OnTouchListener，那么 OnTouchListener 中的 onTouch 方法会被回调。这时事件如何处理还要看 onTouch 的返回值，如果返回 false，那么当前 View 的 onTouchEvent 方法会被调用；如果返回 true，那么 onTouchEvent 方法将不会被调用。 在 onTouchEvent 方法中，如果当前 View 设置了  OnClickListener，那么它的 onClick 方法会被调用，所以 OnClickListener 的优先级最低。</p><p><strong>当点击一个事件产生后，它的传递过程遵循如顺序，Activity -&gt; Window -&gt; View</strong></p><p>如果一个 View 的 onTouchEvent 方法返回 false，那么它的父容器的 onTouchEvent 方法将会被调用，依次类推，如果所有的元素都不处理这个事件，那么这个事件将会最终传递给 Activity 处理（调用 Activity 的onTouchEvent 方法）</p><p><strong>关于事件传递的机制，给出一些结论：</strong></p><ul><li>同一个事件序列是以 down 事件开始，中间含有数量不定的 move 事件，最终以 up 事件结束</li><li>正常情况下，一个事件序列只能被一个 View 拦截且消耗。一旦一个元素拦截了某次事件，那么同一个事件序列内的所有事件都会直接交给它处理，因此同一个事件序列中的事件不能分别由两个View同时处理，但是通过特殊手段可以做到，比如一个 View 将本该自己处理的事件通过 onTouchEvent 强行传递给其他 View 处理</li><li>某个 View 一旦开始处理事件，如果它不消耗 ACTION_DOWN 事件，那么同一事件序列的其他事情都不会再交给它来处理，并且事件将重新交给它的父容器去处理（调用父容器的 onTouchEvent 方法）；如果它消耗 ACTION_DOWN 事件，但是不消耗其他类型事件，那么这个点击事件会消失，父容器的 onTouchEvent 方法不会被调用，当前 View 依然可以收到后续的事件，但是这些事件最后都会传递给 Activity 处理。</li><li>ViewGroup 默认不拦截任何事件。Android 源码中 ViewGroup 的 onInterceptTouchEvent 方法默认返回false，View 没有 onInterceptTouchEvent 方法，一旦有点击事件传递给它，那么它的 onTouchEvent 方法就会调用。</li><li>View 的 onTouchEvent 默认都会消耗事件（返回true），除非它是不可点击的（clickable 和 longClickable 同时为 false）。View 的 longClickable 属性默认都为 false，clickable 要分情况，比如 Button 的 clickable 属性默认为 true，而 TextView 的 clickable 属性默认为 false。</li><li>View 的 enable 属性不影响 onTouchEvent 的默认返回值，哪怕一个 View 是 disable 状态的，只要它的 clickable 或者 longClickable 有一个为 true，那么它的 onTouchEvent 就返回 true</li><li>事件传递过程总是先传递给父元素，然后再由父元素分发给子 View，通过requestDisallowInterceptTouchEvent 方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN 事件除外，即当面对 ACTION_DOWN 事件时，ViewGroup 总是会调用自己的onInterceptTouchEvent 方法来询问自己是否要拦截事件。</li></ul><h3 id="3-5-View-的滑动冲突"><a href="#3-5-View-的滑动冲突" class="headerlink" title="3.5 View 的滑动冲突"></a>3.5 View 的滑动冲突</h3><h4 id="3-5-1-常见的滑动冲突场景"><a href="#3-5-1-常见的滑动冲突场景" class="headerlink" title="3.5.1 常见的滑动冲突场景"></a>3.5.1 常见的滑动冲突场景</h4><ul><li>外部滑动方向与内部滑动方向不一致，比如 ViewPager 中包含 ListView</li><li>外部滑动方向与内部滑动方向一致</li><li>上面两种情况的嵌套</li></ul><h4 id="3-5-2-滑动冲突的处理规则"><a href="#3-5-2-滑动冲突的处理规则" class="headerlink" title="3.5.2 滑动冲突的处理规则"></a>3.5.2 滑动冲突的处理规则</h4><p>可以根据滑动距离和水平方向形成的夹角；或者根据水平和竖直方向滑动的距离差；或者两个方向上的速度差等。</p><h4 id="3-5-3-滑动冲突的解决方式"><a href="#3-5-3-滑动冲突的解决方式" class="headerlink" title="3.5.3 滑动冲突的解决方式"></a>3.5.3 滑动冲突的解决方式</h4><ul><li>外部拦截法</li></ul><p>点击事件都经过父容器的拦截处理，如果父容器需要此事件就拦截，如果不需要此事件就不拦截，该方法需要重写父容器的 onInterceptTouchEvent 方法，在内部做相应的拦截即可，伪代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> intercepted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">        <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">                intercepted = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">                <span class="keyword">int</span> deltaX = x - mLastXIntercept;</span><br><span class="line">                <span class="keyword">int</span> deltaY = y - mLastYIntercept;</span><br><span class="line">                <span class="keyword">if</span> (父容器需要拦截当前点击事件的条件，例如：Math.abs(deltaX) &gt; Math.abs(deltaY))&#123;</span><br><span class="line">                    intercepted = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                    intercepted = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</span><br><span class="line">                intercepted = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mLastXIntercept = x;</span><br><span class="line">        mLastYIntercept = y;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> intercepted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>内部拦截法</li></ul><p>父容器不拦截任何事件，所有的事件都传递给子元素，如果子元素需要此事件就直接消耗掉，否则就由父容器进行处理，这种方法和 Android 中的事件分发机制不一样，需要配合 requestDisallowInterceptTouchEvent 方法才能正常工作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</span><br><span class="line">        <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;]</span><br><span class="line">                getParent().requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">                <span class="keyword">int</span> deltaX = x - mLastX;</span><br><span class="line">                <span class="keyword">int</span> deltaY = y - mLastY;</span><br><span class="line">                <span class="keyword">if</span> (当前view需要拦截当前点击事件的条件，例如：Math.abs(deltaX) &gt; Math.abs(deltaY))&#123;</span><br><span class="line">                    getParent().requestDisallowInterceptTouchEvent(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mLastX = x;</span><br><span class="line">        mLastY = y;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;3-1-View-基础知识&quot;&gt;&lt;a href=&quot;#3-1-View-基础知识&quot; class=&quot;headerlink&quot; title=&quot;3.1 View 基础知识&quot;&gt;&lt;/a&gt;3.1 View 基础知识&lt;/h3&gt;&lt;h4 id=&quot;3-1-1-什么是-View&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="Android" scheme="https://imeiji.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Android 开发艺术探索 - 第二章笔记</title>
    <link href="https://imeiji.github.io/2018/08/01/Android%20%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%20-%20%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://imeiji.github.io/2018/08/01/Android 开发艺术探索 - 第二章笔记/</id>
    <published>2018-07-31T16:15:15.000Z</published>
    <updated>2018-08-04T10:25:35.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2-1-Android-IPC-简介"><a href="#2-1-Android-IPC-简介" class="headerlink" title="2.1 Android IPC 简介"></a>2.1 Android IPC 简介</h3><ol><li>线程是 CPU 调度的最小单元，同时线程是一种有限的系统资源。而进程一般指一个执行单元，在 PC 和移动设备上指一个程序或者一个应用。一个进程可以包含多个线程</li><li>Windows 上可以通过剪贴板、管道和油槽等来进行进程间通信；Linux 上可以通过命名管道、共享内存、信号量等来进行进程间通讯；Android 上可以通过 Binder、Socket 实现进程间通讯</li></ol><h3 id="2-2-Android-中的多进程模式"><a href="#2-2-Android-中的多进程模式" class="headerlink" title="2.2 Android 中的多进程模式"></a>2.2 Android 中的多进程模式</h3><h4 id="2-2-1-开启多进程模式"><a href="#2-2-1-开启多进程模式" class="headerlink" title="2.2.1 开启多进程模式"></a>2.2.1 开启多进程模式</h4><p>在 Android 中使用多进程的方法，那就是给四大组件（Activity、Service、Receiver、ContentProvider）在 AndroidMenifest 中指定 android:process 属性。其实还有另一种非常规的多进程方法，那就是通过 JNI 在 native 层去 fork 一个新的进程。</p><p>实例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 包名为 com.example.application</span><br><span class="line">&lt;service</span><br><span class="line">    android:name=&quot;.service.MyRemoteService&quot;</span><br><span class="line">    android:process=&quot;:remote&quot; /&gt;</span><br><span class="line">&lt;service</span><br><span class="line">    android:name=&quot;.service.MyRemoteServiceII&quot;</span><br><span class="line">    android:process=&quot;com.example.application.remote&quot; /&gt;</span><br></pre></td></tr></table></figure><p>当 MyRemoteService 启动时，系统会为它创建一个单独的进程 ”com.example.application:remote“；</p><p>当 MyRemoteServiceII 启动时，系统会为它创建一个单独的进程 ”com.example.application.remote“；</p><p>没有指定 process 属性的，那么它运行在默认进程中，默认进程就是包名。</p><p>”:“ 的含义是指要在当前的进程名前面附加上当前的包名，这是一种简写。其次，进程名以 ”:“ 开头的进程属于当前应用的私有进程，其他应用的组件不可以和它跑在同一个进程中，而进程名不以 ”:“ 开头的进程属于全局进程，其他应用通过 shareUID 方式可以和它跑在同一个进程中。</p><h4 id="2-2-2-多进程模式的运行机制"><a href="#2-2-2-多进程模式的运行机制" class="headerlink" title="2.2.2 多进程模式的运行机制"></a>2.2.2 多进程模式的运行机制</h4><p>一般来说，使用多进程会造成如下几方面的问题：</p><ol><li>静态成员和单例模式完全失效</li><li>线程同步机制完全失效</li><li>SharedPreferences 的可靠性下降</li><li>Application 会多次创建</li></ol><p>第一、二个问题是类似的，既然都不在同一块内存了，那么不管是锁对象还是锁全局类都无法保证线程同步，因为不同进程锁的不是用一个对象。第三个问题因为 SharedPreferences 底层是通过读/写 XML 文件来实现，并发读/写都有可能出现问题。第四个问题，运行在不同进程中的组件是属于两个不同的虚拟机和 Application 的。</p><h3 id="2-3-IPC-基础概念介绍"><a href="#2-3-IPC-基础概念介绍" class="headerlink" title="2.3 IPC 基础概念介绍"></a>2.3 IPC 基础概念介绍</h3><h4 id="2-3-1-Serializable-接口"><a href="#2-3-1-Serializable-接口" class="headerlink" title="2.3.1 Serializable 接口"></a>2.3.1 Serializable 接口</h4><p>Serializable 是 Java 所提供的一个序列化接口，它是一个空接口，为对象提供标准的序列化和反序列化操作。使用  Serializable 只需要在类的声明中指定 serialVersionUID 。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static final long serialVersionUID = 233333333333333L</span><br></pre></td></tr></table></figure><p>这个 serialVersionUID 是用来辅助序列化和反序列化过程的，原则上序列化后的数据中的 serialVersionUID 只有和当前类的 serialVersionUID 相同才能够正常地被反序列化。</p><p>默认实现 Serializable 不会自动创建 serialVersionUID 属性，我们可以开启警告，这样按下代码补全就自动生成 serialVersionUID 。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/01/5b61bccc75dee.png" alt="Serializable_setting.png" title="">                </div>                <div class="image-caption">Serializable_setting.png</div>            </figure><p>以下两点需要特别注意：</p><ol><li>静态成员变量不属于类对象，所以不会参与序列化过程</li><li>用 transient 关键字标记的成员变量不会参与序列化过程</li></ol><h4 id="2-3-2-Parcelable-接口"><a href="#2-3-2-Parcelable-接口" class="headerlink" title="2.3.2 Parcelable 接口"></a>2.3.2 Parcelable 接口</h4><p>Parcelable 也是一个接口，只要实现了这个接口，一个类的对象就可以实现序列化并可以通过 Intent 和 Binder 传递。Android Studio 支持一键自动生成 Parcelable 代码，所以不用怕麻烦。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/01/5b61bde931fff.png" alt="Parcelable.png" title="">                </div>                <div class="image-caption">Parcelable.png</div>            </figure><p>Serializable 和 Parcelable 如何选取？</p><p>Serializable 是 Java 中的序列化接口，其使用起来非常简单但是开销很大，整个过程需要大量 I/O 操作。一般在保存数据到 SD 卡或者网络传输时建议使用 Serializable 即可，虽然效率差一些，好在使用方便。</p><p>而 Parcelable 是 Android 中的序列化方式，更适合在 Android 平台上，缺点是使用起来稍微麻烦，但是它的效率很高。而在运行时数据传递时建议使用 Parcelable，比如 Intent，Bundle 等。</p><h4 id="2-3-3-Binder"><a href="#2-3-3-Binder" class="headerlink" title="2.3.3 Binder"></a>2.3.3 Binder</h4><p>直观来说，Binder 是 Android 中的一个类，它实现了 IBinder 接口。从 IPC 角度来说，Binder 是 Android 中的一种跨进程通讯方式；从  Android Framework 角度来说，Binder 是 ServiceManager 连接各种 Manager（ActivityManager、WindowManager，等等）和相应 ManagerService 的桥梁；从 Android 应用层来说，Binder 是客户端和服务端进行通讯的媒介。</p><p>下面讲几个重要的方法：</p><ul><li><p>asInterface</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于将服务端的 Binder 对象转换成客户端所需的 AIDL 接口对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> com.meiji.<span class="function">IMyAidlInterface <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 客户端和服务端位于同一进程，返回服务端的 Stub 对象本身</span></span><br><span class="line">    android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">    <span class="keyword">if</span> (((iin != <span class="keyword">null</span>) &amp;&amp; (iin <span class="keyword">instanceof</span> com.meiji.IMyAidlInterface))) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((com.meiji.IMyAidlInterface) iin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回封装后的 Stub.Proxy 对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> com.meiji.IMyAidlInterface.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>onTransact</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line"><span class="comment">// 服务端通过 code 确定客户端请求的目标方法</span></span><br><span class="line">  <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">      <span class="keyword">case</span> TRANSACTION_basicTypes: &#123;</span><br><span class="line">          data.enforceInterface(DESCRIPTOR);</span><br><span class="line">          <span class="keyword">int</span> _arg0;</span><br><span class="line">          <span class="comment">// 从 data 中取出参数</span></span><br><span class="line">          _arg0 = data.readInt();</span><br><span class="line">          <span class="comment">// 然后执行目标方法</span></span><br><span class="line">          <span class="keyword">this</span>.basicTypes(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5);</span><br><span class="line">          <span class="comment">// 执行完毕后，向 reply 中写入返回值</span></span><br><span class="line">          reply.writeNoException();</span><br><span class="line">          reply.writeInt(_result);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Proxy#toUpperCase</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个方法是我们在 AIDL 文件里定义的接口实现方法，当客户端调用此方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toUpperCase</span><span class="params">(java.lang.String aString)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建输入型 Parcel 对象 _data</span></span><br><span class="line">    android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">    <span class="comment">// 创建输出型 Parcel 对象 _reply</span></span><br><span class="line">    android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">    java.lang.String _result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">        <span class="comment">// 把参数信息写入 _data 中</span></span><br><span class="line">        _data.writeString(aString);</span><br><span class="line">        <span class="comment">// 调用 transact 发起 RPC（远程调用过程），同时挂起当前线程，然后服务端 onTransact 被调用</span></span><br><span class="line">        mRemote.transact(Stub.TRANSACTION_toUpperCase, _data, _reply, <span class="number">0</span>);</span><br><span class="line">        _reply.readException();</span><br><span class="line">        <span class="comment">// 写入服务端 onTransact 返回的数据</span></span><br><span class="line">        _result = _reply.readString();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        _reply.recycle();</span><br><span class="line">        _data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后返回 _reply 中的数据</span></span><br><span class="line">    <span class="keyword">return</span> _result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>注意几点：</p><ol><li>当客户端发起远程请求时，由于当前线程会被挂起直至服务端进程返回数据，所以如果一个远程方法时很耗时的，那么不能再 UI 线程中发起远程请求</li><li>由于服务端的 Binder 方法运行在 Binder 的线程池中，所以 Binder 方法不管是否耗时都应该采用同步的方式去实现，因为它已经运行在一个线程中了</li><li>通过 Binder 的 linkToDeath 方法可以给 Binder 设置一个死亡代理，当 Binder 死亡时 ，我们就会收到通知，这个时候可以重新发起连接请求从而恢复连接</li></ol><p>Binder 的工作机制：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/04/5b64899d6e169.png" alt="Binder工作机制.png" title="">                </div>                <div class="image-caption">Binder工作机制.png</div>            </figure><h3 id="2-4-Android-中的-IPC-方式"><a href="#2-4-Android-中的-IPC-方式" class="headerlink" title="2.4 Android 中的 IPC 方式"></a>2.4 Android 中的 IPC 方式</h3><h4 id="2-4-1-使用-Bundle"><a href="#2-4-1-使用-Bundle" class="headerlink" title="2.4.1 使用 Bundle"></a>2.4.1 使用 Bundle</h4><p>四大组件中的三大组件（Activity、Service、Receiver）都支持在 Intent 中传递 Bundle 数据</p><h4 id="2-4-2-使用文件共享"><a href="#2-4-2-使用文件共享" class="headerlink" title="2.4.2 使用文件共享"></a>2.4.2 使用文件共享</h4><p>两个进程通过读/写同一个文件来交换数据，Android 系统允许并发读/写文件。使用 ObjectOutputStream 、ObjectInputStream 序列化一个对象到文件系统中同时从另一个进程中恢复这个对象。</p><p>SharedPreferences 也属于文件共享的一类，当面对高并发的读/写访问，SharedPreferences 有很大几率会丢失数据。</p><p>综上所示，文件共享方式适合在对数据同步要求不高的进程之间进行通讯，并且要妥协处理并发读/写的问题。</p><h4 id="2-4-3-使用-Messenger"><a href="#2-4-3-使用-Messenger" class="headerlink" title="2.4.3 使用 Messenger"></a>2.4.3 使用 Messenger</h4><p>Messenger 可以翻译为信使，通过它可以在不同进程中传递 Message 对象，在 Message 中放入我们需要传递的数据，就可以轻松地实现数据的进程间传递。Messenger 是一种轻量级的 IPC 方案，它的底层实现是 AIDL 。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/04/5b64976be0f67.png" alt="Messenger工作机制.png" title="">                </div>                <div class="image-caption">Messenger工作机制.png</div>            </figure><h4 id="2-4-4-使用-AIDL"><a href="#2-4-4-使用-AIDL" class="headerlink" title="2.4.4 使用 AIDL"></a>2.4.4 使用 AIDL</h4><p>Messenger 的作用主要是为了传递消息，很多时候我们可能需要跨进程调用服务端的方法，这种情形用 Mess anger 就无法做大了，但是可以使用 AIDL 来实现跨进程的方法调用。</p><p>AIDL 大致流程：首先创建一个 Service 和一个 AIDL 接口，接着创建一个类继承 AIDL 接口中的 Stub 类并实现 Stub 中的抽象方法，在 Service 的 onBind 方法中返回这个类的对象，然后客户端就可以绑定服务端 Service，建立连接后就可以访问远程服务端的方法了。</p><p>另外，由于服务端的方法（Stub 中的抽象方法）本身运行在服务端的 Binder 线程池中，所以服务端方法本身就可以执行大量耗时操作，这个时候切记不要再服务端方法中开线程去进行异步任务，除非你明确知道自己在干什么，否则不建议这么做。</p><h4 id="2-4-5-使用-ContentProvider"><a href="#2-4-5-使用-ContentProvider" class="headerlink" title="2.4.5 使用 ContentProvider"></a>2.4.5 使用 ContentProvider</h4><p>和 Messenger 一样，ContentProvider 的底层实现同样也是 Binder，它是 Android 中提供的专门用于不同应用间进行数据共享的方式。系统预置了许多 ContentProvider，比如通讯录信息、日程表信息等。</p><p>ContentProvider 中有六个抽象方法：onCreate、query、update、insert、delete、getType，除了 onCreate 由系统回调并运行在主线程里，其他五个方法均由外界回调并运行在 Binder 线程池中。</p><h3 id="2-5-Binder-连接池"><a href="#2-5-Binder-连接池" class="headerlink" title="2.5 Binder 连接池"></a>2.5 Binder 连接池</h3><p>随着项目越来越大，AIDL 数量的增加，我们不能无限制地增加 Service，应该将所有的 AIDL 放在同一个 Service 中去管理。在这种模式下，服务端提供一个 queryBinder 接口，这个接口能够根据不同业务返回相应的 Binder 对象给客户端，客户端就可以进行远程方法调用了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/04/5b6574177a1a4.png" alt="Binder连接池的工作原理.png" title="">                </div>                <div class="image-caption">Binder连接池的工作原理.png</div>            </figure><h3 id="2-6-选用合适的-IPC-方式"><a href="#2-6-选用合适的-IPC-方式" class="headerlink" title="2.6 选用合适的 IPC 方式"></a>2.6 选用合适的 IPC 方式</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/08/04/5b657f128861a.png" alt="IPC优缺点和适用场景.png" title="">                </div>                <div class="image-caption">IPC优缺点和适用场景.png</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;2-1-Android-IPC-简介&quot;&gt;&lt;a href=&quot;#2-1-Android-IPC-简介&quot; class=&quot;headerlink&quot; title=&quot;2.1 Android IPC 简介&quot;&gt;&lt;/a&gt;2.1 Android IPC 简介&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="Android" scheme="https://imeiji.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Android 开发艺术探索 - 第一章笔记</title>
    <link href="https://imeiji.github.io/2018/07/23/Android%20%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%20-%20%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://imeiji.github.io/2018/07/23/Android 开发艺术探索 - 第一章笔记/</id>
    <published>2018-07-23T14:28:15.000Z</published>
    <updated>2018-07-24T13:20:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-1-Activity-的生命周期全面分析"><a href="#1-1-Activity-的生命周期全面分析" class="headerlink" title="1.1 Activity 的生命周期全面分析"></a>1.1 Activity 的生命周期全面分析</h2><ol><li>onStart 和 onResume 的区别是 onStart 此时 Activity 已经可见，但是还没有出现在前台，无法和用户交互。onResume 的时候 Activity 在前台，获取到焦点能与用户交互。</li><li>新 Activity 是透明主题时，旧 Activity 不会走 onStop</li><li>Activity 切换时，旧 Activity 的 onPause 会先执行，然后才会启动新的 Activity </li><li>Activity 在异常情况下被回收时，onSaveInstanceState 方法会被回调，回调时机是在onStop 之前，当 Activity 被重新创建的时候，onRestoreInstanceState 方法会被回调，时序在 onStart 之后 </li><li>当 Activity 被销毁并重新创建后，可恢复的位置可以选择 onRestoreInstanceState 和 onCreate ，二者的区别是 onRestoreInstanceState 一旦被调用，其参数 Bundle savedInstanceState 一定是有值的，我们不用额外判断是否为空；但是在 onCreate 里必须判断是否为空，官方推荐采用 onRestoreInstanceState 去恢复数据</li></ol><h2 id="1-2-Activity-的-LaunchMode"><a href="#1-2-Activity-的-LaunchMode" class="headerlink" title="1.2 Activity 的 LaunchMode"></a>1.2 Activity 的 LaunchMode</h2><ul><li>standard 系统默认。每次启动会重新创建新的实例，谁启动了这个Activity，这个Activity 就在谁的栈里</li><li>singleTop 栈顶复用模式。如果新的 Activity 已经位于任务栈的栈顶，那么此Activity不会被重新创建，该 Activity 的 onNewIntent 方法会被回调，onCreate 和 onStart 并不会被调用 </li><li>singleTask 栈内复用模式。只要该 Activity 在一个栈中存在，都不会重新创建，onNewIntent 会被回调。如果不存在，系统会先寻找是否存在需要的栈，如果不存在该栈，就创建一个任务栈，然后把这个 Activity 放进去；如果存在，就会创建到已经存在的这个栈中 </li><li>singleInstance 单实例模式。具有此种模式的 Activity 只能单独存在于一个任务栈 </li></ul><p>什么是任务栈？</p><p>默认情况下所有 Activity 所需的任务栈的名字为应用的包名，可以为每个 Activity 都单独在 AndroidManifest 指定 TaskAffinity 属性。当 TaskAffinity 和 singleTask 启动模式配对使用的时候，待启动的 Activity 会运行在名字和 TaskAffinity 相同的任务栈中</p><p>Activity 的 Flags</p><ul><li><p>FLAG_ACTIVITY_NEW_TASK</p><p>它与 launchMode=”singleTask” 具有相同的行为。实际上，并不是完全相同！很少单独使用 FLAG_ACTIVITY_NEW_TASK，通常与 FLAG_ACTIVITY_CLEAR_TASK 或 FLAG_ACTIVITY_CLEAR_TOP 联合使用。在相互跳转的两个 Activity的 android:taskAffinity 相同的情况下 ，单独使用 FLAG_ACTIVITY_NEW_TASK 不会产生任何效果</p></li><li><p>FLAG_ACTIVITY_SINGLE_TOP</p><p>它与 launchMode=”singleTop” 具有相同的行为</p></li><li><p>FLAG_ACTIVITY_CLEAR_TOP</p><p>当它启动时，在同一个任务栈中所有位于它上面的 Activity 都要出栈。FLAG_ACTIVITY_CLEAR_TOP 和 FLAG_ACTIVITY_NEW_TASK 两者同时使用，就能达到和 launchMode=”singleTask” 一样的效果</p></li><li><p>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS</p><p>具有这个标记的 Activity 不会出现在历史 Activity 的列表中，他等同于在 XML 中指定 Activity 的属性 android:excludeFromRecents=’true’</p></li><li><p>FLAG_ACTIVITY_CLEAR_TASK</p><p>使用 FLAG_ACTIVITY_CLEAR_TASK 时，通常会包含 FLAG_ACTIVITY_NEW_TASK 。这样做的目的是启动 Activity 时，清除之前已经存在的 Activity 实例所在的 task ；这自然也就清除了之前存在的 Activity 实例</p></li></ul><p>通过 AndroidManifest 指定启动模式和通过在 Intent 中设置标志位来指定启动模式，二者的区别是什么？</p><ol><li>优先级。当同时使用 launchMode 和上面的 FLAG_ACTIVITY_NEW_TASK 等标签时，以FLAG_ACTIVITY_NEW_TASK 为标准。也就是说，代码的优先级比 manifest 中配置文件的优先级更高</li><li>限定范围。在 manifest 中无法配置 FLAG_ACTIVITY_CLEAR_TOP 等标识，在 Intent 中无法指定 singleInstance 模式</li></ol><h2 id="1-3-IntentFilter-的匹配规则"><a href="#1-3-IntentFilter-的匹配规则" class="headerlink" title="1.3 IntentFilter 的匹配规则"></a>1.3 IntentFilter 的匹配规则</h2><ul><li><p>action 匹配规则：要求 Intent 中的 action 存在且必须和过滤规则中的其中一个相同，区分大小写</p></li><li><p>category 匹配规则：系统会默认加上一个 android.intent.category.DEAFAULT ，所以Intent 中可以不存在 category ，但如果存在就必须匹配其中一个</p></li><li><p>data 匹配规则：data 由两部分组成，mimeType 和 URI。mimeType 指媒体类型，比如 image/jpeg、video/*，可以表示图片、文本、视频等不同的媒体格式，而 URI 中包含的数据就比较多了，下面是 URI 的结构：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;]</span><br></pre></td></tr></table></figure><p>这里再给几个实际的例子就好理解了 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">content://com.example.project:200/folder/subfolder/etc</span><br><span class="line">https://www.google.com:443/search/info</span><br></pre></td></tr></table></figure><p>要求 Intent 中必须含有 data 数据。如果没有指定 URI，URI 的默认值为 content 和file（schema）</p></li></ul><p>判断是否有 Activity 匹配我们的隐式 Intent：</p><p>采用 PackageManager 的 resolveActivity 方法或者 Intent 的 resolveActivity 方法，果它们找不到匹配的 Activity 就会返回 null。另外，PackageManager 还提供了queryIntentActivities 方法，这个方法和 resolveActivity 方法不同的是：它不是返回最佳匹配的 Activity 信息而是返回所有成功匹配的 Activity 信息<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract List&lt;ResolveInfo&gt;queryIntentActivities(Intent intent,int fladgs);</span><br><span class="line">public abstract ResolveInfo resolveActivity(Intent intent,int flags);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-1-Activity-的生命周期全面分析&quot;&gt;&lt;a href=&quot;#1-1-Activity-的生命周期全面分析&quot; class=&quot;headerlink&quot; title=&quot;1.1 Activity 的生命周期全面分析&quot;&gt;&lt;/a&gt;1.1 Activity 的生命周期全面
      
    
    </summary>
    
      <category term="Android" scheme="https://imeiji.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>谈谈 Android 压缩和加载大图片</title>
    <link href="https://imeiji.github.io/2018/07/08/%E8%B0%88%E8%B0%88%20Android%20%E5%8E%8B%E7%BC%A9%E5%92%8C%E5%8A%A0%E8%BD%BD%E5%A4%A7%E5%9B%BE%E7%89%87/"/>
    <id>https://imeiji.github.io/2018/07/08/谈谈 Android 压缩和加载大图片/</id>
    <published>2018-07-08T13:28:15.000Z</published>
    <updated>2018-07-08T13:31:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>目前手机摄像头像素越来越高，拍个照动不动就 5-10 M，图片体积过大导致程序很可能直接 OOM，所以压缩和加载大图片要特殊处理。<a href="http://weixin.qq.com/cgi-bin/readtemplate?promote=2&amp;nav=contact&amp;t=weixin_faq_networkflow" target="_blank" rel="noopener">微信官方</a>有一条关于图片流量的数据，根据原图质量压缩至50-200K/张 。朋友圈的图片是强制压缩，我们只能给朋友发照片的时候选择发送原图。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/07/08/5b41b28cc3423.png" alt="wechat.png" title="">                </div>                <div class="image-caption">wechat.png</div>            </figure><h2 id="为什么会-OOM"><a href="#为什么会-OOM" class="headerlink" title="为什么会 OOM"></a>为什么会 OOM</h2><ul><li>通常情况下，移动设备的内存资源是有限的，Android 系统会根据手机的屏幕大小和密度，为每个程序设置一个最大内存限制，应用程序消耗的内存不能超过这个最大内存限制，否则就会出现 OOM 现象。当然，这个内存限制是跟手机配置相关联的，可以通过 <code>ActivityManager.getLargeMemoryClass</code> 读取</li><li>图片的操作会消耗大量的内存，特别是细节丰富的图片，例如照片。以 Galaxy Nexus 相机为例子，它拍摄一张 2592x1936 像素的照片，如果使用的位图配置是 ARGB_8888 (默认从 Android 2.3 开始)，那么这张照片加载到内存，大约会消耗 19MB 的内存（2592 x 1936 x 4字节），仅仅是图片消耗内存的数值可能已经超过了某些设备的内存限制</li><li>Android 的 UI 经常会一次加载多张图片，例如，ListView、GridView、ViewPager 等等</li></ul><h2 id="压缩图片"><a href="#压缩图片" class="headerlink" title="压缩图片"></a>压缩图片</h2><p>首先，在 Android 设备中，图片有如下三种存在形式：</p><ol><li>在硬盘上时，图片展现的方式是 File</li><li>在网络传输时，图片展现的方式是 Stream</li><li>在内存中，图片展现的方式是 Stream 或 Bitmap</li></ol><p>因此，我们既要压缩图片 File 大小（减轻服务器存储压力），又要压缩图片 Pixel（避免 OOM）</p><p>Android 中有两种压缩图片的方法：</p><ol><li><p>质量压缩（不改变图片的尺寸）</p><p>质量压缩一般可用于上传大图前的处理，这样就可以节省一定的流量。<br>所谓的质量压缩，它其实只能实现对 File 的影响。<br>缺点：照片失真、耗时</p></li><li><p>尺寸压缩（相当于是像素上的压缩）</p><p>尺寸压缩一般可用于生成缩略图<br>通过缩放图片像素来减少图片占用内存大小</p></li></ol><p>那么问题来了，拿到一张超大图片是先进行质量压缩，还是尺寸压缩呢？</p><h3 id="质量压缩"><a href="#质量压缩" class="headerlink" title="质量压缩"></a>质量压缩</h3><p><code>Bitmap.compress(CompressFormat format, int quality, OutputStream stream)</code></p><p>这个方法有三个参数，是布尔类型的返回值</p><ul><li>CompressFormat 指定的 Bitmap 被压缩成的图片格式，只支持 JPEG，PNG，WEBP 三种</li><li>quality  图片压缩质量的控制，范围为 0~100，0 表示压缩后体积最小，但是质量也是最差，100 表示压缩后体积最大，但是质量也是最好的（个人认为相当于未压缩，注意某些特殊情况压缩后体积反而增大），有些格式，例如 PNG，它是无损的，所以会忽略这个值。</li><li>OutputStream 压缩后的数据会写入这个字节流中</li><li>返回值表示返回的字节流是否可以使用<code>BitmapFactory.decodeStream()</code>解码成 Bitmap，至于返回值是怎么得到的，因为是 Native 的代码，没法找到逻辑。</li></ul><p>压缩过程如下，通过依次减少图片质量，将图片大小控制在限制值范围内</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 压缩图片</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bitmap 被压缩的图片</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sizeLimit 大小限制</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 压缩后的图片</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Bitmap <span class="title">compressBitmap</span><span class="params">(Bitmap bitmap, <span class="keyword">long</span> sizeLimit)</span> </span>&#123;</span><br><span class="line">    ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    <span class="keyword">int</span> quality = <span class="number">100</span>;</span><br><span class="line">    bitmap.compress(Bitmap.CompressFormat.JPEG, quality, baos);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环判断压缩后图片是否超过限制大小，注意控制 quality 不能小于 0 ，我这里设置为 10</span></span><br><span class="line">    <span class="keyword">while</span>(baos.toByteArray().length / <span class="number">1024</span> &gt; sizeLimit &amp;&amp; quality &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="comment">// 清空baos</span></span><br><span class="line">        baos.reset();</span><br><span class="line">        bitmap.compress(Bitmap.CompressFormat.JPEG, quality, baos);</span><br><span class="line">        quality -= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Bitmap newBitmap = BitmapFactory.decodeStream(<span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray()), <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> newBitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结，质量压缩通过不断较少 quality 来限制文件大小，假如图片特别大，当执行ByteArrayOutputStream.toByteArray() 这行时很可能 OOM，消耗的内存超过最大内存限制，所以质量压缩不能先执行。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/07/08/5b41c76443f0b.png" alt="OOM.png" title="">                </div>                <div class="image-caption">OOM.png</div>            </figure><h3 id="尺寸压缩"><a href="#尺寸压缩" class="headerlink" title="尺寸压缩"></a>尺寸压缩</h3><p>Android 中的 BitmapFactory 类提供了一些解码方法，decodeByteArray()、decodeFile()、decodeResource()等等，根据不通的图片源选择不同的解码方法加载图片创建出 Bitmap。这些方法中都会传入一个<code>BitmapFactory.Options</code> 实例化对象，通过这个对象，可以更改一些加载图片的设置。由于这些解码方法用于解码加载图片，会占用内存构建 Bitmap，因此很容易导致 OOM 的异常。<br>如果将 <code>options.inJustDecodeBounds</code> 设置为 true，在解码过程中就不会申请内存去创建 Bitmap，返回的是一个空的 Bitmap，但是可以获取图片的一些属性，例如图片宽高，图片类型等等。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">options.inJustDecodeBounds = <span class="keyword">true</span>;      <span class="comment">// 设置为true，不将图片解码到内存中</span></span><br><span class="line">BitmapFactory.decodeResource(getResources(), R.id.myimage, options);</span><br><span class="line"><span class="keyword">int</span> imageHeight = options.outHeight;    <span class="comment">// 图片高度</span></span><br><span class="line"><span class="keyword">int</span> imageWidth = options.outWidth;      <span class="comment">// 图片宽度</span></span><br><span class="line">String imageType = options.outMimeType; <span class="comment">// 图片类型</span></span><br></pre></td></tr></table></figure><p>我们知道图片的大小之后，就可以决定是否将完整的图片加载到内存或者加载压缩版的图片到内存。可以基于以下几点做出决定： </p><ul><li>估计完整图片加载到内存中所使用内存</li><li>可分配给加载图片的内存</li><li>用于显示图片的控件的大小</li><li>当前设备的屏幕大小和密度</li></ul><p>例如，如果显示图片的控件大小为 128x96 像素，就没有必要将一个 1024x768 像素的图片加载到内存中。</p><p>设置<code>options.inSampleSize</code>的数值，来控制压缩图片程度。例如，将<code>options.inSampleSize</code>设置为 4，将一个 2048x1536 像素的图片解码加载到内存后产生的 Bitmap 大约为 512x384 像素，如果使用的位图配置是ARGB_8888，那么仅仅需要 0.75M（512 <em> 384 </em> 4 / 1024 / 1024） 就加载了缩小版的图片到内存，而加载完整的图片需要 12M（2048 <em> 1536 </em> 4 / 1024 / 1024）。</p><p>也就是说，如果我们设置<code>inSampleSize == 2</code>，解码出来的位图的宽高是原图的 1/2，图片所占用内存缩小了1/4（1/2 * 1/2）。如果<code>inSampleSize</code>设置的值小于等1，都会当做<code>inSampleSize == 1</code>来解码加载图片。</p><p>于是我们可以在加载图片的时候，根据控件的大小（显示到屏幕上的大小）来计算出压缩版图片的<code>inSampleSize</code>值。计算恰当的<code>inSampleSize</code>是尺寸压缩最重要的参数，网上有很多种算法，这里罗列几种</p><ul><li><p>Android 源码计算方式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">computeSizeByAndroid</span><span class="params">(BitmapFactory.Options options, <span class="keyword">int</span> minSideLength, <span class="keyword">int</span> maxNumOfPixels)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> initialSize = computeInitialSampleSize(options, minSideLength,   maxNumOfPixels);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> roundedSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (initialSize &lt;= <span class="number">8</span>) &#123;</span><br><span class="line">            roundedSize = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (roundedSize &lt; initialSize) &#123;</span><br><span class="line">                roundedSize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            roundedSize = (initialSize + <span class="number">7</span>) / <span class="number">8</span> * <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> roundedSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">computeInitialSampleSize</span><span class="params">(BitmapFactory.Options options, <span class="keyword">int</span> minSideLength, <span class="keyword">int</span> maxNumOfPixels)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> w = options.outWidth;</span><br><span class="line">        <span class="keyword">double</span> h = options.outHeight;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lowerBound = (maxNumOfPixels == -<span class="number">1</span>) ? <span class="number">1</span> :</span><br><span class="line">        (<span class="keyword">int</span>) Math.ceil(Math.sqrt(w * h / maxNumOfPixels));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> upperBound = (minSideLength == -<span class="number">1</span>) ? <span class="number">128</span> : (<span class="keyword">int</span>) Math.min(Math.floor(w / minSideLength), Math.floor(h / minSideLength));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (upperBound &lt; lowerBound) &#123;</span><br><span class="line">            <span class="comment">// return the larger one when there is no overlapping zone.</span></span><br><span class="line">            <span class="keyword">return</span> lowerBound;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((maxNumOfPixels == -<span class="number">1</span>) &amp;&amp; (minSideLength == -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (minSideLength == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> lowerBound;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> upperBound;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用方法如下，其中 tagWidth 和 tagHeight 为压缩后的长宽</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">options.inJustDecodeBounds = <span class="keyword">true</span>;</span><br><span class="line">options.inSampleSize = computeSampleSize(options, -<span class="number">1</span>, tagWidth * tagHeight);</span><br></pre></td></tr></table></figure></li><li><p>常规算法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">computeSize</span><span class="params">(<span class="keyword">int</span> srcWidth, <span class="keyword">int</span> srcHeight, <span class="keyword">int</span> tagWidth, <span class="keyword">int</span> tagHeight)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sampleSize = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (srcHeight &gt; tagHeight &amp;&amp; srcWidth &gt; tagWidth) &#123;</span><br><span class="line">      sampleSize = srcWidth / tagWidth;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (srcHeight &lt; tagHeight &amp;&amp; srcWidth &gt; tagWidth) &#123;</span><br><span class="line">      sampleSize = srcHeight / tagHeight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sampleSize;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>其中，srcWidth 和 srcHeight 为原图片大小，tagWidth 和 tagHeight 为压缩后的长宽</p></li><li><p><a href="https://github.com/Curzibn/Luban" target="_blank" rel="noopener">鲁班算法</a>，据说接近微信压缩算法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">computeSizeByLuban</span><span class="params">(<span class="keyword">int</span> srcWidth, <span class="keyword">int</span> srcHeight)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sampleSize;</span><br><span class="line">    srcWidth = srcWidth % <span class="number">2</span> == <span class="number">1</span> ? srcWidth + <span class="number">1</span> : srcWidth;</span><br><span class="line">    srcHeight = srcHeight % <span class="number">2</span> == <span class="number">1</span> ? srcHeight + <span class="number">1</span> : srcHeight;</span><br><span class="line">    srcWidth = srcWidth &gt; srcHeight ? srcHeight : srcWidth;</span><br><span class="line">    srcHeight = srcWidth &gt; srcHeight ? srcWidth : srcHeight;</span><br><span class="line">    <span class="keyword">double</span> scale = ((<span class="keyword">double</span>) srcWidth / srcHeight);</span><br><span class="line">    <span class="keyword">if</span> (scale &lt;= <span class="number">1</span> &amp;&amp; scale &gt; <span class="number">0.5625</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (srcHeight &lt; <span class="number">1664</span>) &#123;</span><br><span class="line">        sampleSize = <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (srcHeight &gt;= <span class="number">1664</span> &amp;&amp; srcHeight &lt; <span class="number">4990</span>) &#123;</span><br><span class="line">        sampleSize = <span class="number">2</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (srcHeight &gt;= <span class="number">4990</span> &amp;&amp; srcHeight &lt; <span class="number">10240</span>) &#123;</span><br><span class="line">        sampleSize = <span class="number">4</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sampleSize = srcHeight / <span class="number">1280</span> == <span class="number">0</span> ? <span class="number">1</span> : srcHeight / <span class="number">1280</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scale &lt;= <span class="number">0.5625</span> &amp;&amp; scale &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">      sampleSize = srcHeight / <span class="number">1280</span> == <span class="number">0</span> ? <span class="number">1</span> : srcHeight / <span class="number">1280</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      sampleSize = (<span class="keyword">int</span>) Math.ceil(srcHeight / (<span class="number">1280.0</span> / scale));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sampleSize;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><p>OK，得到 inSampleSize 值后，就可以根据这个值来加载压缩版的图片了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">decodeSampledBitmapFromResource</span><span class="params">(Resources res, <span class="keyword">int</span> resId,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> reqWidth, <span class="keyword">int</span> reqHeight)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先将inJustDecodeBounds设置为true来获取图片的长宽属性</span></span><br><span class="line">    <span class="keyword">final</span> BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">    options.inJustDecodeBounds = <span class="keyword">true</span>;</span><br><span class="line">    BitmapFactory.decodeResource(res, resId, options);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算inSampleSize</span></span><br><span class="line">    options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载压缩版图片</span></span><br><span class="line">    options.inJustDecodeBounds = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 根据具体情况选择具体的解码方法</span></span><br><span class="line">    <span class="keyword">return</span> BitmapFactory.decodeResource(res, resId, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结，尺寸压缩的首先要获取原图的长宽值，设置<code>options.inJustDecodeBounds = true</code>仅获取 Bitmap 基本信息，接着计算 inSampleSize 值，最后通过 BitmapFactory 解码完成</p><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>回到上面那个问题，拿到一张超大图片是先进行质量压缩，还是尺寸压缩呢？</p><p>答案是先尺寸压缩，后质量压缩，因为尺寸压缩可以设置<code>options.inJustDecodeBounds = true</code>仅获取 Bitmap 基本信息，几乎不占用应用程序的运行内存，最终代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 图片压缩，先尺寸压缩，后质量压缩</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> srcImage  原图片文件</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> tagImage  压缩后的文件</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> byteSize  压缩后的文件大小 单位 byte</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> tagWidth  压缩后的图片宽度</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> tagHeight 压缩后的图片高度</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 压缩后的文件</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> File <span class="title">compress</span><span class="params">(File srcImage, File tagImage, <span class="keyword">long</span> byteSize, <span class="keyword">int</span> tagWidth, <span class="keyword">int</span> tagHeight)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">    <span class="comment">// 仅获取基本 Bitmap 信息</span></span><br><span class="line">    options.inJustDecodeBounds = <span class="keyword">true</span>;</span><br><span class="line">    BitmapFactory.decodeFile(srcImage.getAbsolutePath(), options);</span><br><span class="line">    <span class="comment">// 原图片的宽高</span></span><br><span class="line">    <span class="keyword">int</span> srcWidth = options.outWidth;</span><br><span class="line">    <span class="keyword">int</span> srcHeight = options.outHeight;</span><br><span class="line">    <span class="comment">// 若不指定压缩后的图片宽高，采用鲁班算法</span></span><br><span class="line">    <span class="keyword">if</span> (tagHeight == <span class="number">0</span> || tagWidth == <span class="number">0</span>) &#123;</span><br><span class="line">      options.inSampleSize = computeSizeByLuban(srcWidth, srcHeight);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 定压缩后的图片宽高，采用Android算法</span></span><br><span class="line">      options.inSampleSize = computeSizeByAndroid(options, -<span class="number">1</span>, tagWidth * tagHeight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    options.inJustDecodeBounds = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 尺寸压缩后的 Bitmap</span></span><br><span class="line">    Bitmap tagBitmap = BitmapFactory.decodeFile(srcImage.getAbsolutePath(), options);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义字节流</span></span><br><span class="line">    ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    <span class="keyword">int</span> quality = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 若不指定压缩后的文件大小，不压缩</span></span><br><span class="line">    <span class="keyword">if</span> (byteSize == <span class="number">0</span>) &#123;</span><br><span class="line">      tagBitmap.compress(Bitmap.CompressFormat.JPEG, quality, byteArrayOutputStream);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 开始质量压缩</span></span><br><span class="line">      tagBitmap.compress(Bitmap.CompressFormat.JPEG, quality, byteArrayOutputStream);</span><br><span class="line">      <span class="keyword">long</span> dataSize = byteArrayOutputStream.toByteArray().length;</span><br><span class="line">      <span class="comment">// 文件过大，压缩质量从 60 开始</span></span><br><span class="line">      <span class="keyword">if</span> (dataSize / byteSize &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">        quality = <span class="number">60</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 质量低于 30 不压缩（压缩出来的效果太渣）</span></span><br><span class="line">      <span class="keyword">while</span> (quality &gt; <span class="number">30</span> &amp;&amp; dataSize &gt; byteSize) &#123;</span><br><span class="line">        quality = (<span class="keyword">int</span>) (quality * <span class="number">0.85</span>);</span><br><span class="line">        byteArrayOutputStream.reset();</span><br><span class="line">        tagBitmap.compress(Bitmap.CompressFormat.JPEG, quality, byteArrayOutputStream);</span><br><span class="line">        dataSize = byteArrayOutputStream.toByteArray().length;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Bitmap 回收</span></span><br><span class="line">    tagBitmap.recycle();</span><br><span class="line">    <span class="comment">// 输出文件</span></span><br><span class="line">    FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(tagImage);</span><br><span class="line">    fileOutputStream.write(byteArrayOutputStream.toByteArray());</span><br><span class="line">    fileOutputStream.flush();</span><br><span class="line">    fileOutputStream.close();</span><br><span class="line">    byteArrayOutputStream.close();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tagImage;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>小结，压缩图片主要分为质量压缩和尺寸压缩，质量压缩用于减少 File 文件的体积大小，尺寸压缩用于生成缩略图，降低像素来减少图片占用内存大小（后面会讲到拒绝压缩像素加载高清图）。</p><h2 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h2><p>首先要知道 Bitmap 所占内存大小计算方式：</p><p>图片长度 x 图片宽度 x 一个像素点占用的字节数</p><p>图片的长宽我们在上面已经讲到通过尺寸压缩的方式来降低，那么接下来就如何改变一个像素点占用的字节数</p><h3 id="降低像素点字节"><a href="#降低像素点字节" class="headerlink" title="降低像素点字节"></a>降低像素点字节</h3><p>在 Bitmap 中有一个 Config 的属性，这个属性是用来描述每个像素被储存的大小。目前常用的 Config 有四个值：ALPHA_8、RGB_565、ARGB_4444、ARGB_8888。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/07/08/5b4209cf58cd0.png" alt="config.png" title="">                </div>                <div class="image-caption">config.png</div>            </figure><p>其中，A 代表透明度；R 代表红色；G 代表绿色；B 代表蓝色。 </p><ul><li><p>ALPHA_8 </p><p>表示 8 位 Alpha 位图，即 A=8，一个像素点占用 1 个字节,它没有颜色，只有透明度 </p></li><li><p>ARGB_4444<br>表示 16 位 ARGB 位图，即 A=4，R=4，G=4，B=4，一个像素点占 4+4+4+4=16 位，2 个字节 </p></li><li><p>ARGB_8888<br>表示 32 位 ARGB 位图，即 A=8，R=8，G=8，B=8，一个像素点占 8+8+8+8=32 位，4 个字节 </p></li><li><p>RGB_565<br>表示 16 位 RGB 位图，即 R=5，G=6，B=5，它没有透明度，一个像素点占 5+6+5=16 位，2个字节</p></li></ul><p>有什么区别呢？最简单的，当一个颜色表现形式越多，那么画面整体的色彩就会更丰富，图片质量就会越高，当然，图片占用的储存空间也越大。Android 默认采用 ARGB_8888 ，那么我们在加载图片的时候使用 RGB_565 就能降低一半图片占用内存</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">options.inPreferredConfig = Bitmap.Config.RGB_565;</span><br><span class="line">imageView.setImageBitmap(BitmapFactory.decodeFile(tagFile.absolutePath, options));</span><br></pre></td></tr></table></figure><h3 id="局部加载"><a href="#局部加载" class="headerlink" title="局部加载"></a>局部加载</h3><p>对于图片加载还有种情况，就是单个图片非常巨大，并且还不允许压缩。比如显示：世界地图、清明上河图、微博长图等。</p><p>那么对于这种需求，该如何做呢？</p><p>首先不压缩，按照原图尺寸加载，那么屏幕肯定是不够大的，并且考虑到内存的情况，不可能一次性整图加载到内存中，所以肯定是局部加载，那么就需要用到一个类：<code>BitmapRegionDecoder</code></p><p>至于 <code>BitmapRegionDecoder</code> 是啥，本文不打算讲，感兴趣的去看看<a href="https://blog.csdn.net/lmj623565791/article/details/49300989" target="_blank" rel="noopener">鸿洋的文章</a></p><p>这里我直接推荐 2个 开源库，拿来就用</p><ol><li><a href="https://github.com/LuckyJayce/LargeImage" target="_blank" rel="noopener">https://github.com/LuckyJayce/LargeImage</a></li><li><a href="https://github.com/davemorrissey/subsampling-scale-image-view" target="_blank" rel="noopener">https://github.com/davemorrissey/subsampling-scale-image-view</a></li></ol><p>具体用法看看 example ，本文也不打算讲</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>图片的处理，时刻都需要注意，因为机型配置的不同，以及现场设备内存使用的情况，都有可能导致 OOM 的现象，上述提到了压缩方法，基本适用与大部分图片压缩情况。当然如果对图片画质显示有要求，使用局部加载方法。</p><p>参考：</p><p><a href="https://developer.android.com/reference/android/graphics/Bitmap" target="_blank" rel="noopener">https://developer.android.com/reference/android/graphics/Bitmap</a></p><p><a href="https://www.jianshu.com/p/0f56f35068e2" target="_blank" rel="noopener">https://www.jianshu.com/p/0f56f35068e2</a></p><p><a href="https://blog.csdn.net/HarryWeasley/article/details/51955467" target="_blank" rel="noopener">https://blog.csdn.net/HarryWeasley/article/details/51955467</a></p><p><a href="https://blog.csdn.net/lmj623565791/article/details/49300989" target="_blank" rel="noopener">https://blog.csdn.net/lmj623565791/article/details/49300989</a></p><p><a href="https://github.com/LuckyJayce/LargeImage" target="_blank" rel="noopener">https://github.com/LuckyJayce/LargeImage</a></p><p><a href="https://github.com/davemorrissey/subsampling-scale-image-view" target="_blank" rel="noopener">https://github.com/davemorrissey/subsampling-scale-image-view</a></p><p><a href="https://github.com/Curzibn/Luban" target="_blank" rel="noopener">https://github.com/Curzibn/Luban</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;目前手机摄像头像素越来越高，拍个照动不动就 5-10 M，图片体积过大导致程序很可能直接 OOM，所以压缩和加载大图片要特殊处理。&lt;a hr
      
    
    </summary>
    
      <category term="Android" scheme="https://imeiji.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>搭建 IDEA license server 服务器</title>
    <link href="https://imeiji.github.io/2018/03/24/IntelliJ%20IDEA%20license%20server%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
    <id>https://imeiji.github.io/2018/03/24/IntelliJ IDEA license server服务器搭建/</id>
    <published>2018-03-24T12:30:34.000Z</published>
    <updated>2018-03-24T14:13:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>若资金允许，请点击 <a href="https://www.jetbrains.com/idea/buy/" target="_blank" rel="noopener">https://www.jetbrains.com/idea/buy/</a> 购买正版</p><h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><ul><li><p>方法一：使用 nginx 反代</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    location /idea/ &#123;</span><br><span class="line">        proxy_pass http://idea.lanyus.com/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  然后使用 <code>https://yourdomain.com/idea/</code> 即可</p></li></ul><ul><li><p>方法二：使用反代软件</p><p>  项目地址 ： <a href="https://github.com/ilanyu/ReverseProxy" target="_blank" rel="noopener">https://github.com/ilanyu/ReverseProxy</a></p><p>  下载对应系统的二进制文件，下面以 linux-amd64 为例</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https://github.com/ilanyu/ReverseProxy/releases/download/v1.2/ReverseProxy_linux_amd64</span><br><span class="line">chmod a+x ReverseProxy_linux_amd64</span><br><span class="line">./ReverseProxy_linux_amd64 -l &quot;0.0.0.0:8888&quot; -r http://idea.lanyus.com/</span><br></pre></td></tr></table></figure><p>  然后使用 <code>http://yourdomain.com:8888</code> 即可</p></li></ul><ul><li><p>方法三：使用破解补丁</p><p>  <a href="http://idea.lanyus.com/" target="_blank" rel="noopener">http://idea.lanyus.com/</a></p></li></ul><h2 id="激活网址"><a href="#激活网址" class="headerlink" title="激活网址"></a>激活网址</h2><p>上面地址失效了可以换个试试</p><p><a href="http://xidea.online/" target="_blank" rel="noopener">http://xidea.online/</a><br><a href="http://idea.singee77.com/" target="_blank" rel="noopener">http://idea.singee77.com/</a><br><a href="http://idea.lanyus.com/" target="_blank" rel="noopener">http://idea.lanyus.com/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;若资金允许，请点击 &lt;a href=&quot;https://www.jetbrains.com/idea/buy/&quot; target=&quot;_blank
      
    
    </summary>
    
      <category term="VPS" scheme="https://imeiji.github.io/categories/VPS/"/>
    
    
  </entry>
  
  <entry>
    <title>Android NDK 入门 - 玩转 CMake</title>
    <link href="https://imeiji.github.io/2018/03/17/Android%20NDK%20%E5%85%A5%E9%97%A8%20-%20%E7%8E%A9%E8%BD%AC%20CMake/"/>
    <id>https://imeiji.github.io/2018/03/17/Android NDK 入门 - 玩转 CMake/</id>
    <published>2018-03-17T12:30:34.000Z</published>
    <updated>2018-03-17T12:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上一篇文章 <a href="https://imeiji.github.io/2018/03/15/Android%20NDK%20%E5%85%A5%E9%97%A8%20-%20%E5%88%9D%E6%8E%A2%20CMake/">Android NDK 入门 - 初探 CMake</a> 中，学习了如何在 AS 中使用 CMake 来开发 NDK，而编写 CMakeLists.txt 构建脚本是其中一个重要的环节，今天我们就来一起学习 CMakeLists.txt 的一些应用，介绍它在下面四种场景的用法：</p><ul><li>CMakeLists.txt 文件解析</li><li>使用 Android NDK 的 API</li><li>编写 so 库</li><li>使用 so 库</li></ul><h2 id="CMakeLists-txt-文件解析"><a href="#CMakeLists-txt-文件解析" class="headerlink" title="CMakeLists.txt 文件解析"></a>CMakeLists.txt 文件解析</h2><p>把常用的语法说明下，关于 <code>CMake</code> 的语法，可以查看 <a href="https://cmake.org/cmake/help/git-master/manual/cmake-commands.7.html" target="_blank" rel="noopener">官方的 API 说明</a></p><ul><li><p><code>cmake_minimum_required(VERSION3.4.1)</code><br>指定 CMake 最低版本 </p></li><li><p><code>add_library(native-lib SHARED src/main/cpp/native-lib.cpp)</code><br>用于向 CMake 添加依赖源文件或库，指令需传入三个参数（函数库名称、库类型、依赖源文件相对路径）</p><ul><li><p>函数库名称：生成函数库的名称，决定了最终生成的共享库的名字，例如我们将共享库的名字定义为 native-lib ，那么最终生成的 so 文件将在前面加上 lib 前缀即 libnative-lib.so 或 libnative-lib.a ，但是我们在代码中加载该共享库的时候，仍然应当使用 native-lib ，也就是像下面这样</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static &#123;</span><br><span class="line"> System.loadLibrary(“native-lib”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>库类型：动态库为 SHARED ，静态库为 STATIC，我们可以指定根据源文件编译出来的是静态库还是共享库，这里简单提一下两者的区别：</p><ul><li>静态库：以.a结尾。静态库在程序链接的时候使用，链接器会将程序中使用到函数的代码从库文件中拷贝到应用程序中。一旦链接完成，在执行程序的时候就不需要静态库了。</li><li>共享库：以.so结尾。在程序的链接时候并不像静态库那样在拷贝使用函数的代码，而只是作些标记。然后在程序开始启动运行的时候，动态地加载所需模块。</li></ul></li><li><p>依赖源文件相对路径，依赖的 c/cpp 文件（相对路径），如果我们有多个源文件，那么就在后面添加文件的路径即可。</p></li></ul></li><li><p><code>find_library(log-lib log)</code></p><p>用于定位 NDK 中的库 ，需传入两个参数(path变量、ndk 库名称) ，具体有哪些 API 查看<a href="https://developer.android.com/ndk/reference/index.html" target="_blank" rel="noopener">官网</a> </p><ul><li>path变量：设置 path 变量的名称，这里为 NDK 中的日志库，文件位于 <code>$NDK/platforms/android-&lt;level&gt;/&lt;abi&gt;/usr/lib</code></li><li>ndk 库名称：指定 cmake 查询库的名称，即在 ndk 开发包中查询 liblog.so 函数库，将其路径赋值给 log-lib</li></ul></li><li><p><code>target_link_libraries(native-lib  source1 source2 ... sourceN)</code></p><p>要将预构建库关联到您自己的原生库，需传入至少两个参数(指定目标库、链接的库) </p><ul><li>指定目标库：与上面 add_library 指定的函数库名一致</li><li>链接的库：可链接 add_library ，find_library 中的库，其中 find_library 的库要填写变量 ${log-lib}</li></ul></li><li><p><code>include_directories(src/main/cpp/include/)</code></p><p>为了确保 CMake 可以在编译时定位您的标头文件，填写头文件路径</p><p>​</p></li></ul><h2 id="使用-Android-NDK-的-API"><a href="#使用-Android-NDK-的-API" class="headerlink" title="使用 Android NDK 的 API"></a>使用 Android NDK 的 API</h2><p>在 Android 系统当中，预制了一些标准的 NDK 库，这些库函数的目的就是让开发者能够在原生方法中实现之前在 Java 层开发的一些功能，我们可以通过 <a href="https://developer.android.google.cn/ndk/reference/index.html" target="_blank" rel="noopener">NDK 库</a> 查找所需要的 API 。</p><p>因为这些库已经预制在系统当中了，所以如果我们要调用这些库中的函数，那么不需要将其打包到 APK 当中，所需要做的就是向 CMake 提供希望使用的库名称，并将其关联到自己的原生库，最后在原生代码中引入相应的头文件，调用方法就可以了。</p><p>下面，我们再来创建一个新项目（Including C++ support），研究 NDK 的 API。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/03/17/5aacb4bb4a226.png" alt="Snipaste_2018-03-17_14-13-23.png" title="">                </div>                <div class="image-caption">Snipaste_2018-03-17_14-13-23.png</div>            </figure><p>创建项目后，打开 CMakeLists.txt ，看到引用了 NDK 的 log 库，并链接到 native-lib</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/03/17/5aacb4bcc7ac1.png" alt="Snipaste_2018-03-17_14-21-21.png" title="">                </div>                <div class="image-caption">Snipaste_2018-03-17_14-21-21.png</div>            </figure><p><img src="https://i.loli.net/2018/03/17/5aacb4bcc4611.png" alt="Snipaste_2018-03-17_14-22-45.png"></p><p>既然引用了 log 库，那我们就在 native-lib 里调用 log 库 </p><p>在 MainActivity 里定义 native 接口，按 ALT+ENTER 自动生成 C 函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public native void printByJNI(String tag, String content);</span><br></pre></td></tr></table></figure><p>编写 printByJNI 函数 </p><p><img src="https://i.loli.net/2018/03/17/5aacb6e3cb410.png" alt="Snipaste_2018-03-17_14-33-19.png"></p><p>最后在 Activity 里调用 <code>printByJNI(TAG, &quot;onCreate()&quot;);</code> ，查看结果。本来打算再引用个 NDK 的 API，但代码很复杂 ，倒不如自己写个简单的 so 库，再玩玩 CMakeLists 的配置 。</p><h2 id="编写-so-库"><a href="#编写-so-库" class="headerlink" title="编写 so 库"></a>编写 so 库</h2><p>观察上面的 log 库，发现引入一个 so 库需要  libxxx.so 文件和 .h 文件。OK，编写一个简单的计算器 so 库。</p><p>在 cpp 目录下创建 calc-lib ，注意要同时生成 .cpp 和 .h 文件</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/03/17/5aacc35b65bab.png" alt="Snipaste_2018-03-17_14-57-20.png" title="">                </div>                <div class="image-caption">Snipaste_2018-03-17_14-57-20.png</div>            </figure><p>在 cpp 目录下创建 include 文件夹，把 .h 文件放进去</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/03/17/5aacc4a11f0be.png" alt="Snipaste_2018-03-17_15-32-42.png" title="">                </div>                <div class="image-caption">Snipaste_2018-03-17_15-32-42.png</div>            </figure><p>编写 calc-lib.h 头文件，定义方法</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CMAKEDEMO2_CALC_LIB_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMAKEDEMO2_CALC_LIB_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>编写 calc-lib.cpp 文件，实现方法</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"include/calc-lib.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写完 calc-lib 库后，要修改 CMakeLists ，然后我们再通过 JNI 测试下我们的库是否能用</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/03/17/5aacc61fb7e55.png" alt="Snipaste_2018-03-17_15-39-06.png" title="">                </div>                <div class="image-caption">Snipaste_2018-03-17_15-39-06.png</div>            </figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. add_library 增加一个库，这个上面已经说过</span><br><span class="line">2. include_directories 为了确保 CMake 可以在编译时定位您的标头文件</span><br><span class="line">3. target_link_libraries 我们想通过 native-lib 调用 calc-lib，所以链接，注意可以同时链接多个库</span><br></pre></td></tr></table></figure><p>每次修改 CMakeLists 都需要执行 <code>Refresh Linked C++ Project</code>  和 <code>Clean Project</code>，等待 gradle 刷新完</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/03/17/5aacd98386bd0.png" alt="Snipaste_2018-03-17_17-01-11.png" title="">                </div>                <div class="image-caption">Snipaste_2018-03-17_17-01-11.png</div>            </figure><p>编写 Java 接口，然后生成 JNI 函数，再调用我们的 calc-lib 库，基本上就这样。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/03/17/5aacc8b62df2c.png" alt="Snipaste_2018-03-17_15-50-04.png" title="">                </div>                <div class="image-caption">Snipaste_2018-03-17_15-50-04.png</div>            </figure><p><img src="https://i.loli.net/2018/03/17/5aacc93187c57.png" alt="Snipaste_2018-03-17_15-52-08.png"></p><p>最后启动 App，查看结果。</p><h2 id="使用-so-库"><a href="#使用-so-库" class="headerlink" title="使用 so 库"></a>使用 so 库</h2><p>经过上面的折腾，我们实现了在同个 App 内调用我们编写的 so 库，那怎么让别人使用我们的 so 库，同时不公开代码呢（主要实现代码在 calc-lib.cpp 内）</p><p>继续折腾，把 so 库提取出来，导入到项目 ，然后删除 calc-lib.cpp，最后通过 native-lib 调用。</p><p>Build APK 后，在 <code>app/build/intermediates/cmake</code> 下会生成 so 库，我们把 libcalc-lib.so 拷贝出来</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/03/17/5aacd0106fade.png" alt="Snipaste_2018-03-17_16-21-13.png" title="">                </div>                <div class="image-caption">Snipaste_2018-03-17_16-21-13.png</div>            </figure><p>在 <code>app/src/main/</code> 下创建 jniLibs 文件夹，把 so 库复制进去</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/03/17/5aacd12decbdb.png" alt="Snipaste_2018-03-17_16-25-47.png" title="">                </div>                <div class="image-caption">Snipaste_2018-03-17_16-25-47.png</div>            </figure><p>删除 <code>app/src/main/cpp/calc-lib.cpp</code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/03/17/5aacda9fe478a.png" alt="Snipaste_2018-03-17_17-06-32.png" title="">                </div>                <div class="image-caption">Snipaste_2018-03-17_17-06-32.png</div>            </figure><p>修改 CMakeLists </p><p><img src="https://i.loli.net/2018/03/17/5aacd82178c4b.png" alt="Snipaste_2018-03-17_16-55-50.png"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. add_library 通过 IMPORTANT 标志告知 CMake 只希望将库导入到项目中</span><br><span class="line">2. set_target_properties $&#123;CMAKE_SOURCE_DIR&#125;表示的是 CMakeLists.txt 所在的路径，我们指定第三方 so 所在路径时，应当以这个常量为起点。</span><br><span class="line">按理来说，我们应当为每种 ABI 接口提供单独的软件包，那么，我们就可以在 jinLibs 下建立多个文件夹，每个文件夹对应一种 ABI 接口类型，之后再通过 $&#123;ANDROID_ABI&#125; 来泛化这一层目录的结构，这样将有助于充分利用特定的CPU架构</span><br></pre></td></tr></table></figure><p>执行 <code>Refresh Linked C++ Project</code>  和 <code>Clean Project</code>，等待 gradle 刷新完，最后启动 App，查看结果。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这篇文章简单的解释 CMakeLists 文件的配置，如何导入 Android NDK 的 API，如何链接 so 库到 JNI，如何编写和使用 so 库，接下来会继续学习 ndk-build 的方式开发 Android NDK，对比两种方式。</p><p>参考：</p><p><a href="https://www.jianshu.com/p/843cf09a1db2" target="_blank" rel="noopener">https://www.jianshu.com/p/843cf09a1db2</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在上一篇文章 &lt;a href=&quot;https://imeiji.github.io/2018/03/15/Android%20NDK%20%E
      
    
    </summary>
    
      <category term="Android" scheme="https://imeiji.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Android Studio 配置 javah 和 ndk-build 快捷编译</title>
    <link href="https://imeiji.github.io/2018/03/16/Android%20Studio%20%E9%85%8D%E7%BD%AE%20javah%20%E5%92%8C%20ndk-build%20%E5%BF%AB%E6%8D%B7%E7%BC%96%E8%AF%91/"/>
    <id>https://imeiji.github.io/2018/03/16/Android Studio 配置 javah 和 ndk-build 快捷编译/</id>
    <published>2018-03-16T12:30:34.000Z</published>
    <updated>2018-03-16T12:33:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在开发 Android NDK 的时候，如果你是用 ndk-build 的方式，当在 Java 文件定义完 native 接口，按 ALT + ENTER 并不支持自动生成 cpp 文件，而手写 cpp 又非常容易写错，所以很有必要借助 javah 自动生成 .h 头文件。然而敲打 javah 命令也不是这么简单（设置 classpath，设置输出路径 等等。。。）</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>在强大的 Android Studio 中 setting 中可以添加一些 extend tool 方便开发，今天就说下怎么配置 javah 和 ndk-build ，实现一键生成 .h 头文件，一键编译  so 库</p><p>setting 中选择 extend tool</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/03/16/5aabb048d3c3a.png" alt="Snipaste_2018-03-16_17-34-47.png" title="">                </div>                <div class="image-caption">Snipaste_2018-03-16_17-34-47.png</div>            </figure><h3 id="javah-配置"><a href="#javah-配置" class="headerlink" title="javah 配置"></a>javah 配置</h3><p>​    <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/03/16/5aabb048dc1d6.png" alt="Snipaste_2018-03-16_17-35-56.png" title="">                </div>                <div class="image-caption">Snipaste_2018-03-16_17-35-56.png</div>            </figure></p><ul><li>Program : <code>$JDKPath$\bin\javah.exe</code> 这里配置的是 javah.exe 的路径（基本一致）<br><code>$JDKPath$</code> 可以从右侧按钮（insert macro）中选择</li><li>Parametes : <code>$FileClass$</code> 这里指的是要编译 .h 文件的 java 类 （注意这里只填写了 FileClass ，其他参数没有导入那么自定义的一些 model ，或者 Android.jar 中的类是不支持的，可以先生成 h 然后手动输入特殊的参数。 比如 Bitmap ，在 native 方法中先不传这个参数，当生成 h 文件后，手动添加一个 jobject 的参数）</li><li>Working : <code>$ModuleFileDir$\src\main\java</code> 工作路径，也是 .h 生成的路径</li></ul><h3 id="ndk-build-配置"><a href="#ndk-build-配置" class="headerlink" title="ndk-build 配置"></a>ndk-build 配置</h3><p>​    <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/03/16/5aabb048dc6f3.png" alt="Snipaste_2018-03-16_17-36-10.png" title="">                </div>                <div class="image-caption">Snipaste_2018-03-16_17-36-10.png</div>            </figure></p><ul><li>Program : <code>C:\Users\xxx\AppData\Local\Android\Sdk\ndk-bundle\ndk-build.cmd</code> 这里配置的是 ndk 下的 ndk-build.cmd 的路径，在你本地的 ndk-bundle 下</li><li>Parametes :  这里不需要参数</li><li>Working : <code>$ModuleFileDir$\src\main</code> 工作路径</li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>Javah : 选中要生成 .h 的文件，右键 -&gt; javah 就会看到有.h文件生成<br><img src="https://i.loli.net/2018/03/16/5aabb048dd9b2.png" alt="Snipaste_2018-03-16_17-46-19.png"></p><p>ndk-build : 选中 jni 文件夹，然后点击 右键 -&gt; ndk-build 会在 main 下生成一个 obj 目录，里面会生成 libxxx.so<br><img src="https://i.loli.net/2018/03/16/5aabb048dd52e.png" alt="Snipaste_2018-03-16_17-47-19.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在开发 Android NDK 的时候，如果你是用 ndk-build 的方式，当在 Java 文件定义完 native 接口，按 ALT 
      
    
    </summary>
    
      <category term="Android" scheme="https://imeiji.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Android NDK 入门 - 初探 CMake</title>
    <link href="https://imeiji.github.io/2018/03/15/Android%20NDK%20%E5%85%A5%E9%97%A8%20-%20%E5%88%9D%E6%8E%A2%20CMake/"/>
    <id>https://imeiji.github.io/2018/03/15/Android NDK 入门 - 初探 CMake/</id>
    <published>2018-03-15T13:16:34.000Z</published>
    <updated>2018-03-15T13:10:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><p>NDK</p><p>Native Development Kit（NDK）是一系列工具的集合。它提供了一系列的工具，帮助开发者快速开发 C/C++ 的动态库，并能自动将 so 和 Java 一起打包成 apk</p></li><li><p>JNI</p><p>Java Native Interface（JNI）标准是 Java 平台的一部分，JNI 是 Java 语言提供的 Java 和 C/C++ 相互沟通的机制，Java可以通过 JNI 调用 C/C++ 代码，C/C++ 的代码也可以调用 Java 代码，JNI 是属于 Java 的，与 Android 无直接关系</p></li><li><p>JNI 与 NDK 的关系</p><p>NDK 可以为我们生成了 C/C++ 的动态链接库，JNI 是 Java 和 C/C++ 沟通的接口，两者与 Android 没有半毛钱关系，只因为安卓是 Java 程序语言开发，然后通过 JNI 又能与 C/C++ 沟通，所以我们可以使用 NDK+JNI 来实现 Java+C 的开发方式</p></li><li><p>为什么要NDK开发</p><p>NDK开发具有以下优点：</p><ol><li>项目需要调用底层的一些 C/C++ 的一些东西（Java无法直接访问到操作系统底层（如系统硬件等）），或者已经在 C/C++ 环境下实现了功能代码（大部分现存的开源库都是用 C/C++ 代码编写的。），直接使用即可。NDK开发常用于驱动开发、无线热点共享、数学运算、实时渲染的游戏、音视频处理、文件压缩、人脸识别、图片处理等。</li><li>为了效率更加高效些。将要求高性能的应用逻辑使用 C/C++ 开发，从而提高应用程序的执行效率。但是 C/C++ 代码虽然是高效的，在 Java 与 C/C++ 相互调用时却增大了开销；</li><li>基于安全性的考虑。防止代码被反编译，为了安全起见，使用 C/C++ 语言来编写重要的部分以增大系统的安全性，最后生成 so 库（用过第三方库的应该都不陌生）便于给人提供方便。（任何有效的代码混淆对于会 smail 语法反编译你 apk 是分分钟的事，即使你加壳也不能幸免高手的攻击）</li><li>便于移植。用 C/C++ 写得库可以方便在其他的嵌入式平台上再次使用。</li></ol></li></ul><h2 id="开发方式"><a href="#开发方式" class="headerlink" title="开发方式"></a>开发方式</h2><p>在<code>Eclipse</code>的时代，我们进行<code>NDK</code>的开发一般需要通过手动执行<code>NDK</code>脚本生成<code>*.so</code>文件，再将<code>.so</code>文件放到对应的目录之后，之后再进行打包。</p><p>而如果使用的是<code>Android Studio</code>进行<code>NDK</code>开发，在<code>2.2</code>的版本以后，我们可以不需要手动地运行<code>NDK</code>脚本来生成<code>*.so</code>文件，而是将这一过程作为<code>Gradle</code>构建过程的依赖项，事先编写好编译的脚本文件，然后在<code>build.gradle</code>中指定编译脚本文件的路径就可以一次性完成生成原生库并打包成<code>APK</code>的过程。</p><p>目前这种<code>AS + Gradle</code>的<code>NDK</code>开发方式又可以分为三种：<code>ndk-build</code>、<code>CMake</code>和<code>Experimental Gradle</code>：</p><ul><li><code>ndk-build</code>：和上面谈到的传统方式相比，它们两个的目录结构相同，<code>Gradle</code>脚本其实最终还是依赖于<code>Android.mk</code>文件，对于使用传统方式的项目来说，比较容易过度。</li><li><code>CMake</code>：<code>Gradle</code>脚本依赖的是<code>CMakeLists.txt</code>文件。</li><li><code>Experimental Gradle</code>：需要引入实验性的<code>gradle</code>插件，全部的配置都可以通过<code>build.gradle</code>来完成，不再需要编写<code>Android.mk</code>或者<code>CMakeLists.txt</code>，可能坑比较多，对于旧的项目来说过度困难。</li></ul><p>目前，<code>Android Studio</code>已经将<code>CMake</code>作为默认的<code>NDK</code>实现方式，并且官网上对于<code>NDK</code>的介绍也是基于<code>CMake</code>，声称要永久支持。按照官方的教程使用下来，感觉这种方式有几点好处：</p><ul><li>不需要再去通过<code>javah</code>根据<code>java</code>文件生成头文件，并根据头文件生成的函数声明编写<code>cpp</code>文件</li><li>当在<code>Java</code>文件中定义完<code>native</code>接口，可以在<code>cpp</code>文件中自动生成对应的<code>native</code>函数，所需要做的只是补全函数体中的内容</li><li>不需要手动执行<code>ndk-build</code>命令得到<code>so</code>，再将<code>so</code>拷贝到对应的目录</li><li>在编写<code>cpp</code>文件的过程中，可以有提示了</li><li><code>CMakeLists.txt</code>要比<code>Android.mk</code>更加容易理解</li></ul><h2 id="搭建-NDK-环境"><a href="#搭建-NDK-环境" class="headerlink" title="搭建 NDK 环境"></a>搭建 NDK 环境</h2><p>在新建项目之前，我们需要通过<code>SDK Manager</code>安装一些必要的组件：</p><ul><li><code>NDK</code></li><li><code>CMake</code></li><li><code>LLDB</code></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/03/15/5aaa18723ce37.png" alt="image_2018-03-15_14-52-36.png" title="">                </div>                <div class="image-caption">image_2018-03-15_14-52-36.png</div>            </figure><h2 id="创建支持-C-C-的新项目"><a href="#创建支持-C-C-的新项目" class="headerlink" title="创建支持 C/C++ 的新项目"></a>创建支持 C/C++ 的新项目</h2><p>在安装完必要的组件之后，我们创建一个全新的工程，这里需要记得勾选<code>include C++ Support</code>选项：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/03/15/5aaa199362e20.png" alt="Snipaste_2018-03-15_14-56-05.png" title="">                </div>                <div class="image-caption">Snipaste_2018-03-15_14-56-05.png</div>            </figure><p>接下来一路<code>Next</code>，在最后一步我们会看见如下的几个选项，它们的含义为：</p><ul><li><code>C++ Standard</code>：选择<code>C++</code>的标准，<code>Toolchain Default</code>表示使用默认的<code>CMake</code>配置，这里我们选择默认。</li><li><code>Excptions Support</code>：如果您希望启用对<code>C++</code>异常处理的支持，请选中此复选框。如果启用此复选框，<code>Android Studio</code>会将<code>-fexceptions</code>标志添加到模块级 <code>build.gradle</code>文件的<code>cppFlags</code>中，<code>Gradle</code>会将其传递到<code>CMake</code>。</li><li><code>Runtime Type information Support</code>：如果您希望支持<code>RTTI</code>，请选中此复选框。如果启用此复选框，<code>Android Studio</code>会将<code>-frtti</code>标志添加到模块级 <code>build.gradle</code>文件的<code>cppFlags</code>中，<code>Gradle</code>会将其传递到<code>CMake</code></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/03/15/5aaa199478cc4.png" alt="Snipaste_2018-03-15_14-57-56.png" title="">                </div>                <div class="image-caption">Snipaste_2018-03-15_14-57-56.png</div>            </figure><p>在新建工程完毕之后，我们得到的工程的结构如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/03/15/5aaa1acf8d950.png" alt="Snipaste_2018-03-15_15-03-32.png" title="">                </div>                <div class="image-caption">Snipaste_2018-03-15_15-03-32.png</div>            </figure><p>与传统的工程相比，它有如下几点区别：</p><p><strong>(1) cpp 文件夹</strong></p><p>用于存放<code>C/C++</code>的源文件，在磁盘上对应于<code>app/src/main/cpp</code>文件夹，当新建工程时，它会生成一个<code>native-lib.cpp</code>的事例文件，其内容如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/03/15/5aaa1f74034fb.png" alt="Snipaste_2018-03-15_15-21-52.png" title="">                </div>                <div class="image-caption">Snipaste_2018-03-15_15-21-52.png</div>            </figure><p><strong>(2) 增加 CMakeList.txt 脚本</strong></p><p>构建脚本，在磁盘上对应于<code>app/</code>目录下的<code>txt</code>文件，其内容为如下图所示，这里面涉及到的<code>CMake</code>语法包括下面四种，关于<code>CMake</code>的语法，可以查看 <a href="https://cmake.org/cmake/help/latest/manual/cmake-commands.7.html" target="_blank" rel="noopener">官方的 API 说明</a></p><ul><li><code>cmake_minimum_required</code></li><li><code>add_library</code></li><li><code>find_library</code></li><li><code>target_link_libraries</code></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设置最低版本</span><br><span class="line">cmake_minimum_required(VERSION 3.4.1)</span><br><span class="line"></span><br><span class="line"># 添加库</span><br><span class="line">add_library( # 库名</span><br><span class="line">             native-lib</span><br><span class="line"></span><br><span class="line">             # 设置 SHARED or STATIC</span><br><span class="line">             SHARED</span><br><span class="line"></span><br><span class="line">             # 库文件</span><br><span class="line">             src/main/cpp/native-lib.cpp )</span><br><span class="line"></span><br><span class="line">find_library( # Sets the name of the path variable.</span><br><span class="line">              log-lib</span><br><span class="line"></span><br><span class="line">              # Specifies the name of the NDK library that</span><br><span class="line">              # you want CMake to locate.</span><br><span class="line">              log )</span><br><span class="line"></span><br><span class="line">target_link_libraries( # Specifies the target library.</span><br><span class="line">                       native-lib</span><br><span class="line"></span><br><span class="line">                       # Links the target library to the log library</span><br><span class="line">                       # included in the NDK.</span><br><span class="line">                       $&#123;log-lib&#125; )</span><br></pre></td></tr></table></figure><p><strong>(3) build.gradle 脚本</strong></p><p>与传统的项目相比，该模块所对应的<code>build.gradle</code>需要在里面指定<code>CMakeList.txt</code>所在的路径，也就是下面<code>externalNativeBuild</code>对应的选项。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/03/15/5aaa1cae004d3.png" alt="Snipaste_2018-03-15_15-07-09.png" title="">                </div>                <div class="image-caption">Snipaste_2018-03-15_15-07-09.png</div>            </figure><p><strong>(4) 打印字符串</strong></p><p>在<code>MainActivity</code>中，我们加载原生库，并调用原生库中的方法获取了一个字符串展示在界面上：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/03/15/5aaa1f76b30f8.png" alt="Snipaste_2018-03-15_15-22-17.png" title="">                </div>                <div class="image-caption">Snipaste_2018-03-15_15-22-17.png</div>            </figure><p><strong>(5) 运行结果</strong></p><p>最后，我们运行一下这个工程，会得到下面的结果：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/03/15/5aaa200d1f5fe.png" alt="Snipaste_2018-03-15_15-25-59.png" title="">                </div>                <div class="image-caption">Snipaste_2018-03-15_15-25-59.png</div>            </figure><p>通过查看 <code>app/build/cmake/debug</code>  路径和 <code>APK Analyzer</code> 工具，我们可以看到在<code>APK</code>当中，增加了<code>libnative-lib.so</code>文件：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2018/03/15/5aaa211f6ea25.png" alt="Snipaste_2018-03-15_15-30-24.png" title="">                </div>                <div class="image-caption">Snipaste_2018-03-15_15-30-24.png</div>            </figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>下面，我们来解释一下这一过程：</p><ul><li>首先，在构建时，通过<code>build.gradle</code>中<code>path</code>所指定的路径，找到<code>CMakeList.txt</code>，解析其中的内容。</li><li>按照脚本中的命令，将<code>src/main/cpp/native-lib.cpp</code>编译到共享的对象库中，并将其命名为<code>libnative-lib.so</code>，随后打包到<code>APK</code>中。</li><li>当应用运行时，首先会执行<code>MainActivity</code>的<code>static</code>代码块的内容，使用<code>System.loadLibrary()</code>加载原生库。</li><li>在<code>onCreate()</code>函数中，调用原生库的函数得到字符串并展示。</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>当通过<code>CMake</code>来对应用程序增加<code>C/C++</code>的支持时，对于应用程序的开发者，只需要关注以下三个方面：</p><ul><li><code>C/C++</code>源文件</li><li><code>CMakeLists.txt</code>脚本</li><li>在模块级别的<code>build.gradle</code>中通过<code>externalNativeBuild/cmake</code>进行配置</li></ul><h2 id="向现有项目添加-C-C-代码"><a href="#向现有项目添加-C-C-代码" class="headerlink" title="向现有项目添加 C/C++ 代码"></a>向现有项目添加 C/C++ 代码</h2><p>  如果您希望向现有项目添加原生代码，请执行以下步骤：</p><ol><li><p>创建新的原生源文件</p><p>在 <code>app/src/</code> 目录下新建个文件夹，为目录输入一个名称（例如 <code>cpp</code>）并点击 OK，</p><p>右键点击您刚刚创建的目录，然后选择 <code>New &gt; C/C++ Source File</code>，为您的源文件输入一个名称，例如 <code>calc-lib</code>，从 Type 下拉菜单中，为您的源文件选择文件扩展名，例如 <code>.cpp</code>，点击 OK 完成。</p><p><img src="https://i.loli.net/2018/03/15/5aaa5f628c608.png" alt="2018-03-15_195552.png"></p><p><img src="https://i.loli.net/2018/03/15/5aaa3bd4c70fc.png" alt="Snipaste_2018-03-15_17-22-02.png"></p><p>​</p></li><li><p>创建 CMake 构建脚本</p><p>在app根目录下新建一个<code>CMakeLists.txt</code>文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.4.1)</span><br><span class="line"># 库名 库类型 源文件</span><br><span class="line">add_library(calc-lib SHARED src/main/cpp/calc-lib.cpp)</span><br><span class="line"></span><br><span class="line"># 为了确保 CMake 可以在编译时定位您的标头文件</span><br><span class="line">include_directories(src/main/cpp/)</span><br></pre></td></tr></table></figure></li><li><p>将 Gradle 关联到您的原生库 </p><p>之后，我们需要让<code>Gradle</code>脚本确定<code>CMakeLists.txt</code>所在的位置，我们可以在<code>CMakeLists.txt</code>上点击右键，之后选择<code>Link C++ Project with Gradle</code>：</p><p><img src="https://i.loli.net/2018/03/15/5aaa3e00955e8.png" alt=""></p><p><img src="https://i.loli.net/2018/03/15/5aaa3e3ed98a1.png" alt="Snipaste_2018-03-15_17-34-44.png"></p><p>那么在该模块下的 build.gradle 就会新增下面这句，在这步完成之后，我们选择 Build -&gt; Clean Project</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">...</span><br><span class="line">externalNativeBuild &#123;</span><br><span class="line">        cmake &#123;</span><br><span class="line">            path &apos;CMakeLists.txt&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等 Gradle 刷新完毕，cpp 文件夹会变蓝色</p><p><img src="https://i.loli.net/2018/03/15/5aaa634a5ce16.png" alt="2018-03-15_201219.png"></p></li></ol><ol><li><p>编写代码</p><p>MainActivity.java</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        ···</span><br><span class="line">        Log.d(TAG, &quot;onCreate: &quot; + sum(1, 2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        System.loadLibrary(&quot;calc-lib&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public native int sum(int x, int y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义 native 接口的地方，多出了一个选项，它可以帮助我们直接在对应的 C++ 文件中生成函数的定义：</p><p><img src="https://i.loli.net/2018/03/15/5aaa41ddc4be1.png" alt="Snipaste_2018-03-15_17-49-30.png"></p><p>点击 Create function 之后，AS 帮我们的生成大部分代码，我们只需要实现函数即可：</p><p><img src="https://i.loli.net/2018/03/15/5aaa41ddc61dc.png" alt="Snipaste_2018-03-15_17-50-09.png"></p><p>如果 AS 帮我们生成的代码不是在你的 cpp 文件夹内（在 /src/main/jni），我们只需要把代码复制到 calc-lib.cpp ，下次再定义 native 接口，点击 Create function 之后，位置就无误了。</p></li></ol><h2 id="控制生成平台-so-库"><a href="#控制生成平台-so-库" class="headerlink" title="控制生成平台 so 库"></a>控制生成平台 so 库</h2><p>默认情况下，Gradle 会针对 <a href="https://developer.android.com/ndk/guides/abis.html#sa" target="_blank" rel="noopener">NDK 支持的 ABI</a> 将您的原生库构建到单独的 <code>.so</code> 文件中，并将其全部打包到您的 APK 中。如果您希望 Gradle 仅构建和打包原生库的特定 ABI 配置，您可以在模块级 <code>build.gradle</code> 文件中使用 <code>ndk.abiFilters</code> 标志指定这些配置，如下所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  ...</span><br><span class="line">  defaultConfig &#123;</span><br><span class="line">    ...</span><br><span class="line">    externalNativeBuild &#123;</span><br><span class="line">      cmake &#123;...&#125;</span><br><span class="line">      // or ndkBuild &#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ndk &#123;</span><br><span class="line">      // Specifies the ABI configurations of your native</span><br><span class="line">      // libraries Gradle should build and package with your APK.</span><br><span class="line">      abiFilters &apos;x86&apos;, &apos;x86_64&apos;, &apos;armeabi&apos;, &apos;armeabi-v7a&apos;,</span><br><span class="line">                   &apos;arm64-v8a&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  buildTypes &#123;...&#125;</span><br><span class="line">  externalNativeBuild &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>以上就是使用<code>Android Studio 3.0</code>版本，通过<code>CMake</code>来进行<code>NDK</code>开发的一个简单例子，主要是学习一下开发的流程，下一篇文章，要学习一下<code>CMakeLists.txt</code>中的语法。</p><p>参考：</p><p><a href="https://www.jianshu.com/p/716641d15ee8" target="_blank" rel="noopener">https://www.jianshu.com/p/716641d15ee8</a></p><p><a href="https://developer.android.com/studio/projects/add-native-code.html" target="_blank" rel="noopener">https://developer.android.com/studio/projects/add-native-code.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;NDK&lt;/p&gt;
&lt;p&gt;Native Development Kit（NDK）是一系列工具的集合。它提供了一系列的工具，帮助
      
    
    </summary>
    
      <category term="Android" scheme="https://imeiji.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>在VPS中利用vlmcsd搭建KMS激活服务器</title>
    <link href="https://imeiji.github.io/2018/02/08/%E5%88%A9%E7%94%A8vlmcsd%E6%90%AD%E5%BB%BAKMS%E6%BF%80%E6%B4%BB%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://imeiji.github.io/2018/02/08/利用vlmcsd搭建KMS激活服务器/</id>
    <published>2018-02-08T13:16:34.000Z</published>
    <updated>2018-02-07T13:19:20.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如今我们经常会使用 KMS 对我们的 Windows/Office 进行激活，不过市面上流通着不少良莠不齐的 KMS 激活软件。其实，我们完全可以利用手中的闲置 VPS 资源，利用 vlmcsd 搭建KMS 激活服务器。声明仅 VOL 版本的 Windows/Office 支持此 KMS 激活，请先确认自己安装的非 Retail 零售版。</p></blockquote><h2 id="搭建服务器"><a href="#搭建服务器" class="headerlink" title="搭建服务器"></a>搭建服务器</h2><p>首先需要一台 VPS，在上面搭建 <a href="https://github.com/Wind4/vlmcsd" target="_blank" rel="noopener">vlmcsd</a> 服务端</p><ol><li><p>下载最新版，查看最新版本 <a href="https://github.com/Wind4/vlmcsd/releases" target="_blank" rel="noopener">https://github.com/Wind4/vlmcsd/releases</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https://github.com/Wind4/vlmcsd/releases/download/svn1111/binaries.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>解压并查看</p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf binaries.tar.gz</span><br><span class="line">cd binaries/Linux/intel/static/</span><br><span class="line">ls</span><br></pre></td></tr></table></figure></li><li><p>挑选适合自己系统的版本，我们能看到适配各个系统的版本，<code>vlmcsd-x64-musl-static</code> 或<code>vlmcsd-x86-musl-static</code>（根据你 VPS 的系统为 x86 或 x64 系统而定）。</p><p>接着以 x64 为例子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod u+x vlmcsd-x64-musl-static</span><br><span class="line">./vlmcsd-x64-musl-static</span><br></pre></td></tr></table></figure><p>至此，已经部署完毕</p></li><li><p>如果你的 VPS 开启了 iptables ，记得开启 1688 端口的 tcp 传输：</p><p><code>iptables -I INPUT 5 -p tcp -m state --state NEW -m tcp --dport 1688 -j ACCEPT</code></p></li><li><p>开机自启</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /etc/rc.local</span><br><span class="line">cd ~/binaries/Linux/intel/static/ &amp;&amp; ./vlmcsd-x64-musl-static</span><br></pre></td></tr></table></figure></li></ol><h2 id="本地测试"><a href="#本地测试" class="headerlink" title="本地测试"></a>本地测试</h2><p>本地测试这里仅以本地为 Windows 环境为例</p><ol><li><p>下载 <a href="https://github.com/Wind4/vlmcsd/releases" target="_blank" rel="noopener">https://github.com/Wind4/vlmcsd/releases</a> ，并解压</p></li><li><p>进入<code>\binaries\Windows\intel</code> 目录，开启 PowerShell 或者其他终端</p></li><li><p>根据你本地的 Windows 为 x86 或 x64，输入如下命令：</p><p><code>./vlmcs-Windows-x86.exe -v -l 3 你的VPS的IP或者绑定的域名</code></p><p>或</p><p><code>./vlmcs-Windows-x64.exe -v -l 3 你的VPS的IP或者绑定的域名</code></p><p>其中 <code>-l 3</code>表示发送  Windows 10 Enterprise 2016 LTSB 的激活请求，具体版本对应列表可以通过 <code>./vlmcs-Windows-x64.exe -x</code> 查看</p><p>如果显示如下，那么就搭建成功了。</p><p><img src="https://i.loli.net/2018/02/07/5a7af53530601.png" alt="kms.png"></p></li></ol><h2 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h2><ul><li><p>激活 Windows</p><p>以管理员身份打开命令提示符，然执行下列命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /d &quot;%SystemRoot%\system32&quot;</span><br><span class="line">slmgr /skms 你的VPS的IP或者绑定的域名</span><br><span class="line">slmgr /ato</span><br><span class="line">slmgr /xpr</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2018/02/07/5a7af6ced8612.png" alt="w.png"></p></li></ul><ul><li><p>激活 Office</p><p>以管理员身份打开命令提示符，进入软件安装目录，然后执行下列命令：</p><p>这里以 Office 2013 为例：</p><p>进入32位版本安装目录：<code>cd /d &quot;%ProgramFiles(x86)%\Microsoft Office\Office15</code></p><p>进入64位版本安装目录：<code>cd /d &quot;%ProgramFiles%\Microsoft Office\Office15</code> </p><p>然后执行下列命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cscript ospp.vbs /sethst:你的VPS的IP或者绑定的域名</span><br><span class="line">cscript ospp.vbs /act</span><br><span class="line">cscript ospp.vbs /dstatus</span><br></pre></td></tr></table></figure></li></ul><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><ol><li><p>Windows VOL 版本可以从 <a href="http://msdn.itellyou.cn/" target="_blank" rel="noopener">http://msdn.itellyou.cn/</a> 这里下载</p></li><li><p>Office VOL 版本可以从 <a href="https://landian.la/click/OfficeToolPlus.html" target="_blank" rel="noopener">https://landian.la/click/OfficeToolPlus.html</a> 这里下载</p></li><li><p>VOL 版本的镜像一般内置 GVLK key，用于 KMS 激活。如果你手动输过其他 key，那么这个内置的 key 就会被替换掉，这个时候如果你想用 KMS，那么就需要把 GVLK key 输回去。首先，<br>到 <a href="https://technet.microsoft.com/en-us/library/jj612867.aspx" target="_blank" rel="noopener">https://technet.microsoft.com/en-us/library/jj612867.aspx</a> 获取你对应版本的 key</p><p>如果不知道自己的系统是什么版本，可以运行以下命令查看系统版本：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wmic os get caption</span><br></pre></td></tr></table></figure><p>得到对应key之后，使用管理员权限运行cmd执行安装key：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slmgr /ipk xxxxx-xxxxx-xxxxx-xxxxx</span><br></pre></td></tr></table></figure><p>然后跟上面说的一样设置 KMS 服务器地址，激活。</p></li></ol><ol><li>KMS 方式激活的有效期只有180天，每隔一段时间系统会自动请求 KMS 服务器续期，只要你的服务器正常，续期就没问题</li></ol><p>参考：</p><ul><li><a href="https://luodaoyi.com/kms.html" target="_blank" rel="noopener">https://luodaoyi.com/kms.html</a></li><li><a href="https://yorkchou.com/vlmcsd.html" target="_blank" rel="noopener">https://yorkchou.com/vlmcsd.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;如今我们经常会使用 KMS 对我们的 Windows/Office 进行激活，不过市面上流通着不少良莠不齐的 KMS 激活软件。其实，我们完全可以利用手中的闲置 VPS 资源，利用 vlmcsd 搭建KMS 激活服务器。声明仅 VOL 版本的 Wi
      
    
    </summary>
    
      <category term="VPS" scheme="https://imeiji.github.io/categories/VPS/"/>
    
    
  </entry>
  
  <entry>
    <title>Git 备忘录</title>
    <link href="https://imeiji.github.io/2018/02/01/Git%20%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    <id>https://imeiji.github.io/2018/02/01/Git 备忘录/</id>
    <published>2018-02-01T11:16:34.000Z</published>
    <updated>2019-09-29T15:30:20.687Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设置用户信息"><a href="#设置用户信息" class="headerlink" title="设置用户信息"></a>设置用户信息</h2><p>Git 要求使用者必须提供自己的身份标识，为此我们需要在 Git bash中执行以下命令（当然不设置也行，每次提交都是 unknown… macOS 貌似会提交系统用户名）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//给自己起个用户名</span><br><span class="line">git config --global user.name &quot;name&quot; </span><br><span class="line">//填写自己的邮箱</span><br><span class="line">git config --global user.email  &quot;abc@gmail.com&quot;</span><br></pre></td></tr></table></figure><h2 id="检查旧密钥"><a href="#检查旧密钥" class="headerlink" title="检查旧密钥"></a>检查旧密钥</h2><p>生成密钥之前先检测是否存在旧密钥</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Windows 目录在 C:\Users\user\.ssh</span><br><span class="line">ls -al ~/.ssh</span><br><span class="line"># Lists the files in your .ssh directory, if they exist</span><br></pre></td></tr></table></figure><p>默认情况下，公钥的文件名是以下之一</p><ul><li><em>id_dsa.pub</em></li><li><em>id_ecdsa.pub</em></li><li><em>id_ed25519.pub</em></li><li><em>id_rsa.pub</em></li></ul><p>如果你没有现有的公钥和私钥对，或者不希望使用任何可用于连接到 Github 的公钥和私钥，请生成一个新的 ssh 密钥</p><p>如果您看到列出的现有公钥和私钥对（例如 id_rsa.pub 和 id_rsa ），那么你可以将 ssh 密钥添加到 ssh-agent 中</p><h2 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h2><p>以下步骤可能会过时，可参考 <a href="https://help.github.com/articles/connecting-to-github-with-ssh/" target="_blank" rel="noopener">https://help.github.com/articles/connecting-to-github-with-ssh/</a> 获取更详细步骤</p><p>GitHub 选择的默认通信方式是 SSH，如果没有配置 SSH key 就只能 clone 代码不能 push 上去（只读），所以要先在 git 里面生成 SHH Key。如果在当前用户的第一级文件夹下有 .ssh 文件夹，说明以前可能使用过 git，把该文件夹删除（或者先备份再删除，防止意外）。</p><p>获得密钥：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C &quot;i@gmail.com&quot;</span><br></pre></td></tr></table></figure><h2 id="添加密钥到-ssh-agent"><a href="#添加密钥到-ssh-agent" class="headerlink" title="添加密钥到 ssh-agent"></a>添加密钥到 ssh-agent</h2><p>添加刚刚生成的证书</p><ol><li><p>确保ssh-agent正在运行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># start the ssh-agent in the background</span><br><span class="line">eval $(ssh-agent -s)</span><br><span class="line">Agent pid 59566</span><br></pre></td></tr></table></figure></li><li><p>添加证书</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure></li></ol><h2 id="添加密钥到-GitHub"><a href="#添加密钥到-GitHub" class="headerlink" title="添加密钥到 GitHub"></a>添加密钥到 GitHub</h2><ol><li><p>将 ssh 密钥复制到剪贴板</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pbcopy &lt; ~/.ssh/id_rsa.pub</span><br><span class="line"># Copies the contents of the id_rsa.pub file to your clipboard</span><br></pre></td></tr></table></figure></li><li><p>打开 <a href="https://github.com/settings/keys" target="_blank" rel="noopener">Settings</a>，在用户设置边栏中，单击 <strong>SSH and GPG keys</strong> ，单击 <strong>New SSH key</strong> or <strong>Add SSH key</strong> ，”Title” 随意填写，如“Personal MacBook Pro”，“Key” 填写刚刚复制过的文本，直接粘贴</p></li><li><p>最后测试下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>提示像我这样：Hi XXX! You’ve successfully authenticated, but GitHub does not provide shell access. 那就说明连接成功了。</p></li></ol><h2 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy &apos;socks5://127.0.0.1:1080&apos;</span><br><span class="line">git config --global https.proxy &apos;socks5://127.0.0.1:1080&apos;</span><br><span class="line"></span><br><span class="line"># 取消代理</span><br><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure><h2 id="隐藏-commits-记录的邮箱地址"><a href="#隐藏-commits-记录的邮箱地址" class="headerlink" title="隐藏 commits 记录的邮箱地址"></a>隐藏 commits 记录的邮箱地址</h2><p>如果你想隐藏你的 git log 中的邮箱，但同时 contributions  也不会消失，那么可以采取以下的方法</p><ol><li><p>去 <a href="https://github.com/settings/emails" target="_blank" rel="noopener">设置页面</a> 勾选 <strong>Keep my email address private</strong></p><p>这时候，会给你一个的电子邮件 <strong>yourusername@users.noreply.github.com</strong> 供你用于你的 Git 提交。</p></li><li><p>更改本地 git config 中的 user.email</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.email  "yourusername@users.noreply.github.com" </span><br><span class="line">git config --global user.email</span><br></pre></td></tr></table></figure></li><li><p>使用脚本更改 Git 仓库的 commits 历史记录</p><ul><li><p>打开 Git Bash</p></li><li><p>克隆你要修改的 repo</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone --bare https://github.com/user/repo.git</span><br><span class="line">cd repo.git</span><br></pre></td></tr></table></figure></li><li><p>复制以下脚本，填写好信息，然后执行脚本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/sh</span><br><span class="line"></span><br><span class="line">git filter-branch --env-filter '</span><br><span class="line">OLD_EMAIL="填写你的旧邮箱"</span><br><span class="line">CORRECT_NAME="填写你的 Github 用户名"</span><br><span class="line">CORRECT_EMAIL="填写新邮箱"</span><br><span class="line">if [ "$GIT_COMMITTER_EMAIL" = "$OLD_EMAIL" ]</span><br><span class="line">then</span><br><span class="line">    export GIT_COMMITTER_NAME="$CORRECT_NAME"</span><br><span class="line">    export GIT_COMMITTER_EMAIL="$CORRECT_EMAIL"</span><br><span class="line">fi</span><br><span class="line">if [ "$GIT_AUTHOR_EMAIL" = "$OLD_EMAIL" ]</span><br><span class="line">then</span><br><span class="line">    export GIT_AUTHOR_NAME="$CORRECT_NAME"</span><br><span class="line">    export GIT_AUTHOR_EMAIL="$CORRECT_EMAIL"</span><br><span class="line">fi</span><br><span class="line">' --tag-name-filter cat -- --branches --tags</span><br></pre></td></tr></table></figure></li><li><p>运行脚本，等待完成</p></li><li><p>提交历史 <code>git push --force --tags origin &#39;refs/heads/*&#39;</code></p></li><li><p>完成，可以删除 repo</p></li></ul></li></ol><p>参考：</p><p><a href="https://help.github.com/articles/connecting-to-github-with-ssh/" target="_blank" rel="noopener">https://help.github.com/articles/connecting-to-github-with-ssh/</a></p><p><a href="https://saraford.net/2017/02/19/how-to-hide-your-email-address-in-your-git-commits-but-still-get-contributions-to-show-up-on-your-github-profile-050/" target="_blank" rel="noopener">https://saraford.net/2017/02/19/how-to-hide-your-email-address-in-your-git-commits-but-still-get-contributions-to-show-up-on-your-github-profile-050/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;设置用户信息&quot;&gt;&lt;a href=&quot;#设置用户信息&quot; class=&quot;headerlink&quot; title=&quot;设置用户信息&quot;&gt;&lt;/a&gt;设置用户信息&lt;/h2&gt;&lt;p&gt;Git 要求使用者必须提供自己的身份标识，为此我们需要在 Git bash中执行以下命令（当然不设置也行，每
      
    
    </summary>
    
      <category term="Git" scheme="https://imeiji.github.io/categories/Git/"/>
    
    
  </entry>
  
  <entry>
    <title>compileSdkVersion、buildToolsVersion、minSdkVersion、targetSdkVersion 的区别</title>
    <link href="https://imeiji.github.io/2017/11/15/compileSdkVersion%E3%80%81buildToolsVersion%E3%80%81minSdkVersion%E3%80%81targetSdkV/"/>
    <id>https://imeiji.github.io/2017/11/15/compileSdkVersion、buildToolsVersion、minSdkVersion、targetSdkV/</id>
    <published>2017-11-15T06:16:34.000Z</published>
    <updated>2017-11-15T06:45:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="compileSdkVersion"><a href="#compileSdkVersion" class="headerlink" title="compileSdkVersion"></a>compileSdkVersion</h2><p>compileSdkVersion 告诉 Gradle 用哪个 Android SDK 版本编译你的应用。使用任何新添加的 API 就需要使用对应 Level 的 Android SDK。</p><p>需要强调的是<strong>修改 compileSdkVersion 不会改变运行时的行为</strong>。当你修改了 compileSdkVersion 的时候，可能会出现新的编译警告、编译错误，但新的 compileSdkVersion 不会被包含到 APK 中：它纯粹只是在编译的时候使用。（你真的应该修复这些警告，他们的出现一定是有原因的）</p><p>因此我们强烈推荐<strong>总是使用最新的 SDK 进行编译</strong>。在现有代码上使用新的编译检查可以获得很多好处，避免新弃用的 API ，并且为使用新的 API 做好准备。</p><p>注意，如果使用 <a href="http://developer.android.com/tools/support-library/index.html?utm_campaign=adp_series_sdkversion_010616&amp;utm_source=medium&amp;utm_medium=blog" target="_blank" rel="noopener">Support Library</a> ，那么使用最新发布的 Support Library 就需要使用最新的 SDK 编译。例如，要使用 23.1.1 版本的 Support Library ，compileSdkVersion 就必需至少是 23 （大版本号要一致！）。通常，新版的 Support Library 随着新的系统版本而发布，它为系统新增加的 API 和新特性提供兼容性支持。</p><h2 id="buildToolsVersion"><a href="#buildToolsVersion" class="headerlink" title="buildToolsVersion"></a>buildToolsVersion</h2><p>表示：构建工具的版本，其中包括了打包工具aapt、dx等等。你应该使用最新版本的来构建。</p><p>这个版本号一般是 API-LEVEL.0.0 。 例如 I/O 2017 大会上发布了 API 26 对应的 build-tool 的版本就是 26.0.0 ，在这之间可能有小版本，例如 26.0.2 等等。</p><h2 id="minSdkVersion"><a href="#minSdkVersion" class="headerlink" title="minSdkVersion"></a>minSdkVersion</h2><p>如果 compileSdkVersion 设置为可用的最新 API，那么 <strong>minSdkVersion 则是应用可以运行的最低要求</strong>。minSdkVersion 是 Google Play 商店用来判断用户设备是否可以安装某个应用的标志之一。</p><p>在开发时 minSdkVersion 也起到一个重要角色：<a href="http://developer.android.com/tools/debugging/improving-w-lint.html?utm_campaign=adp_series_sdkversion_010616&amp;utm_source=medium&amp;utm_medium=blog" target="_blank" rel="noopener">lint</a> 默认会在项目中运行，它在你使用了高于 minSdkVersion  的 API 时会警告你，帮你避免调用不存在的 API 的运行时问题。如果只在较高版本的系统上才使用某些 API，通常使用<a href="http://developer.android.com/training/basics/supporting-devices/platforms.html?utm_campaign=adp_series_sdkversion_010616&amp;utm_source=medium&amp;utm_medium=blog#version-codes" target="_blank" rel="noopener">运行时检查系统版本</a>的方式解决。</p><p>请记住，你所使用的库，如 <a href="http://developer.android.com/tools/support-library/features.html?utm_campaign=adp_series_sdkversion_010616&amp;utm_source=medium&amp;utm_medium=blog" target="_blank" rel="noopener">Support Library</a> 或 <a href="https://developers.google.com/android/guides/overview?utm_campaign=adp_series_sdkversion_010616&amp;utm_source=medium&amp;utm_medium=blog" target="_blank" rel="noopener">Google Play services</a>，可能有他们自己的 minSdkVersion 。你的应用设置的 minSdkVersion 必需大于等于这些库的 minSdkVersion 。例如有三个库，它们的 minSdkVersion 分别是 4, 7 和 9 ，那么你的 minSdkVersion  必需至少是 9 才能使用它们。在少数情况下，你仍然想用一个比你应用的 minSdkVersion 还高的库（处理所有的边缘情况，确保它只在较新的平台上使用），你可以使用 <a href="http://tools.android.com/tech-docs/new-build-system/user-guide/manifest-merger?utm_campaign=adp_series_sdkversion_010616&amp;utm_source=medium&amp;utm_medium=blog#TOC-tools:overrideLibrary-marker" target="_blank" rel="noopener">tools:overrideLibrary 标记</a>，但请做彻底的测试！</p><p>当你决定使用什么 minSdkVersion 时候，你应该<strong>参考当前的 Android 分布统计</strong>，它显示了最近 7 天所有访问 Google Play 的设备信息。他们就是你把应用发布到 Google Play 时的潜在用户。最终这是一个商业决策问题，取决于为了支持额外 3% 的设备，确保最佳体验而付出的开发和测试成本是否值得。</p><p>当然，如果某个新的 API 是你整个应用的关键，那么确定 minSdkVersion 的值就比较容易了。不过要记得 14 亿设备中的 0.7％ 也是个不小的数字。</p><h2 id="targetSdkVersion"><a href="#targetSdkVersion" class="headerlink" title="targetSdkVersion"></a>targetSdkVersion</h2><p>三个版本号中最有趣的就是 targetSdkVersion 了。 <strong>targetSdkVersion 是 Android 提供向前兼容的主要依据</strong>，在应用的 targetSdkVersion 没有更新之前系统不会应用最新的行为变化。这允许你在适应新的行为变化之前就可以使用新的 API （因为你已经更新了 compileSdkVersion 不是吗？）。</p><p>targetSdkVersion 所暗示的许多行为变化都记录在 <a href="http://developer.android.com/reference/android/os/Build.VERSION_CODES.html?utm_campaign=adp_series_sdkversion_010616&amp;utm_source=medium&amp;utm_medium=blog" target="_blank" rel="noopener">VERSION_CODES</a> 文档中了，但是所有恐怖的细节也都列在每次发布的平台亮点中了，在这个 <a href="http://developer.android.com/guide/topics/manifest/uses-sdk-element.html?utm_campaign=adp_series_sdkversion_010616&amp;utm_source=medium&amp;utm_medium=blog#ApiLevels" target="_blank" rel="noopener">API Level 表</a>中可以方便地找到相应的链接。</p><p>例如，<a href="http://developer.android.com/about/versions/marshmallow/android-6.0-changes.html?utm_campaign=adp_series_sdkversion_010616&amp;utm_source=medium&amp;utm_medium=blog" target="_blank" rel="noopener">Android 6.0 变化文档</a>中谈了 target 为 API 23 时会如何把你的应用转换到<a href="http://android-developers.blogspot.com/2015/08/building-better-apps-with-runtime.html?utm_campaign=adp_series_sdkversion_010616&amp;utm_source=medium&amp;utm_medium=blog" target="_blank" rel="noopener">运行时权限模型</a>上，<a href="http://developer.android.com/about/versions/android-4.4.html?utm_campaign=adp_series_sdkversion_010616&amp;utm_source=medium&amp;utm_medium=blog#Behaviors" target="_blank" rel="noopener">Android 4.4 行为变化</a>阐述了 target 为 API 19 及以上时使用 <a href="http://developer.android.com/reference/android/app/AlarmManager.html?utm_campaign=adp_series_sdkversion_010616&amp;utm_source=medium&amp;utm_medium=blog#set%28int,%20long,%20android.app.PendingIntent%29" target="_blank" rel="noopener">set()</a> 和 <a href="http://developer.android.com/reference/android/app/AlarmManager.html?utm_campaign=adp_series_sdkversion_010616&amp;utm_source=medium&amp;utm_medium=blog#setRepeating%28int,%20long,%20long,%20android.app.PendingIntent%29" target="_blank" rel="noopener">setRepeating()</a> 设置 alarm 会有怎样的行为变化。</p><p>由于某些行为的变化对用户是非常明显的（<a href="http://android-developers.blogspot.com/2012/01/say-goodbye-to-menu-button.html?utm_campaign=adp_series_sdkversion_010616&amp;utm_source=medium&amp;utm_medium=blog" target="_blank" rel="noopener">弃用的 menu 按钮</a>，运行时权限等），所以<strong>将 target 更新为最新的 SDK 是所有应用都应该优先处理的事情</strong>。但这不意味着你一定要使用所有新引入的功能，也不意味着你可以不做任何测试就盲目地更新 targetSdkVersion ，<strong>请一定在更新 targetSdkVersion 之前做测试！</strong>你的用户会感谢你的。</p><h2 id="综合来看"><a href="#综合来看" class="headerlink" title="综合来看"></a>综合来看</h2><p>如果你按照上面示例那样配置，你会发现这三个值的关系是：<br><code>minSdkVersion &lt;= targetSdkVersion &lt;= compileSdkVersion</code></p><p>这种直觉是合理的，如果 compileSdkVersion 是你的最大值，minSdkVersion 是最小值，那么最大值必需至少和最小值一样大且 target 必需在二者之间。</p><p>理想上，在稳定状态下三者的关系应该更像这样：<br><code>minSdkVersion (lowest possible) &lt;= targetSdkVersion == compileSdkVersion (latest SDK)</code></p><p>用较低的 minSdkVersion 来覆盖最大的人群，用最新的 SDK 设置 target 和 compile 来获得最好的外观和行为。</p><p>参考</p><p><a href="https://chinagdg.org/2016/01/picking-your-compilesdkversion-minsdkversion-targetsdkversion/" target="_blank" rel="noopener">如何选择 compileSdkVersion, minSdkVersion 和 targetSdkVersion</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;compileSdkVersion&quot;&gt;&lt;a href=&quot;#compileSdkVersion&quot; class=&quot;headerlink&quot; title=&quot;compileSdkVersion&quot;&gt;&lt;/a&gt;compileSdkVersion&lt;/h2&gt;&lt;p&gt;compileSdk
      
    
    </summary>
    
      <category term="Android" scheme="https://imeiji.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Android App 启动页面最佳实现</title>
    <link href="https://imeiji.github.io/2017/11/13/Android%20App%20%E5%90%AF%E5%8A%A8%E9%A1%B5%E9%9D%A2%E6%9C%80%E4%BD%B3%E5%AE%9E%E7%8E%B0/"/>
    <id>https://imeiji.github.io/2017/11/13/Android App 启动页面最佳实现/</id>
    <published>2017-11-13T09:16:34.000Z</published>
    <updated>2017-11-15T06:44:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是App启动屏幕"><a href="#什么是App启动屏幕" class="headerlink" title="什么是App启动屏幕"></a>什么是App启动屏幕</h2><p>App 启动页 (Splash)，最经典的莫过于微信的启动页了</p><ol><li>首次启动出现一个地球界面，然后才进入主界面，这是因为从桌面点击 App 图标启动应用开始，程序会显示一个启动界面等待 Activity 的创建加载完毕再进行显示</li><li>再次启动微信，发现并不会出现地球界面，而是直接进入主界面，这是因为微信并没有完全退出(在后台运行)</li></ol><p>来看一下 Google 官方文档《<a href="https://developer.android.google.cn/topic/performance/launch-time.html" target="_blank" rel="noopener">Launch-Time Performance</a>》对应用启动方式的概述：</p><h2 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h2><h3 id="冷启动"><a href="#冷启动" class="headerlink" title="冷启动"></a>冷启动</h3><p>冷启动指的是应用程序从头开始：系统的进程没有，直到此开始，创建了应用程序的进程。 在应用程序自设备启动以来第一次启动或系统杀死应用程序等情况下会发生冷启动。 这种类型的启动在最小化启动时间方面是最大的挑战，因为系统和应用程序比其他启动状态具有更多的工作。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2017/11/13/5a09453df043a.png" alt="cold-launch.png" title="">                </div>                <div class="image-caption">cold-launch.png</div>            </figure><h3 id="热启动"><a href="#热启动" class="headerlink" title="热启动"></a>热启动</h3><p>与冷启动相比，热启动应用程序要简单得多，开销更低。在热启动，系统会把你活动放到前台，如果所有应用程序的活动仍驻留在内存中，那么应用程序可以避免重复对象初始化，UI的布局和渲染。<br>热启动显示与冷启动场景相同的屏幕行为：系统进程显示空白屏幕，直到应用程序完成呈现活动。</p><h3 id="温启动"><a href="#温启动" class="headerlink" title="温启动"></a>温启动</h3><p>用户退出您的应用，但随后重新启动。该过程可能已继续运行，但应用程序必须通过调用 onCreate() 从头开始重新创建活动。系统从内存中驱逐您的应用程序，然后用户重新启动它。进程和Activity需要重新启动，但任务可以从保存的实例状态包传递到 onCreate() 中。</p><h2 id="为什么出现白屏"><a href="#为什么出现白屏" class="headerlink" title="为什么出现白屏"></a>为什么出现白屏</h2><p>冷启动白屏持续时间可能会很长，这可是个槽糕的体验，它的启动速度是由于以下引起的：<br>1、Application 的 onCreate 流程，对于大型的 App 来说，通常会在这里做大量的通用组件的初始化操作；<br>建议：很多第三方SDK都放在Application初始化，我们可以放到用到的地方才进行初始化操作。</p><p>2、Activity 的 onCreate() 流程，特别是UI的布局与渲染操作，如果布局过于复杂很可能导致严重的启动性能问题；<br>建议：Activity 仅初始化那些立即需要的对象，xml布局减少冗余或嵌套布局。</p><p>优化APP启动速度意义重大，启动时间过长，可能会使用户直接卸载 App 。</p><h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><p>优化方案主要是从主题切换的方向着手：</p><h3 id="直接干掉"><a href="#直接干掉" class="headerlink" title="直接干掉"></a>直接干掉</h3><p>既然有这个 Activity 启动界面，那能不能直接不要这个呢，当然是可以：<br>定义一个 style ：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"SplashTheme"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!--关闭启动窗口--&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowDisablePreview"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 manifest 修改启动页面的主题：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".SplashActivity"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">"@style/SplashTheme"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SplashActivity 代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SplashActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MainActivity.class);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样启动 App，就没有白屏，但会出现点击桌面图标而半天没有反应的现象，显然不好，据我所知 <a href="https://play.google.com/store/apps/details?id=com.innologica.inoreader" target="_blank" rel="noopener">Inoreader (版本5.3)</a> 就是采用这种方法。</p><h3 id="Material-Design"><a href="#Material-Design" class="headerlink" title="Material Design"></a>Material Design</h3><p>其实 Google 针对 App 闪屏，在 Material Design 规范 <a href="https://material.io/guidelines/patterns/launch-screens.html" target="_blank" rel="noopener">Launch screens</a>，也给出了非常详细的设计定义，有两种方案：</p><h4 id="品牌展示"><a href="#品牌展示" class="headerlink" title="品牌展示"></a>品牌展示</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2017/11/13/5a094a6959c30.png" alt="patterns-launch-screens-01.png" title="">                </div>                <div class="image-caption">patterns-launch-screens-01.png</div>            </figure><p>屏幕提供短暂的品牌曝光，来看看如何实现的，定义一个 style ：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"SplashTheme"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowBackground"</span>&gt;</span>@drawable/branded_launch_screens<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>新建 drawable/branded_launch_screens</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">layer-list</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:opacity</span>=<span class="string">"opaque"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--黑色背景颜色--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@android:color/black"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 产品logo--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bitmap</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:gravity</span>=<span class="string">"center"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:src</span>=<span class="string">"@mipmap/empty_image01"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 右上角的图标元素 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bitmap</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:gravity</span>=<span class="string">"top|right"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:src</span>=<span class="string">"@mipmap/github"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--最下面的文字--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:bottom</span>=<span class="string">"50dp"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bitmap</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:gravity</span>=<span class="string">"bottom"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:src</span>=<span class="string">"@mipmap/ic_launcher"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layer-list</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中 android:opacity=”opaque” 参数是为了防止在启动的时候出现背景的闪烁。关于 layer-list 介绍，见博客：用 <a href="http://www.cnblogs.com/tianzhijiexian/p/3889770.html" target="_blank" rel="noopener">layer-list 实现图片旋转叠加、错位叠加、阴影、按钮指示灯</a> 。同样需要在 manifest 修改启动页面的主题。微信、YouTube 就是采用这种方式。</p><h4 id="主页预加载"><a href="#主页预加载" class="headerlink" title="主页预加载"></a>主页预加载</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2017/11/13/5a094b31d202a.png" alt="patterns-launch-screens-03.png" title="">                </div>                <div class="image-caption">patterns-launch-screens-03.png</div>            </figure><p>使用与主界面 UI 一致的占位内容，给用户感觉已经在加载中了，这里模拟了一个高度为 25dp 的状态栏和一个高度为 56dp 的标题栏，定义一个style：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"SplashTheme"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:windowBackground"</span>&gt;</span>@drawable/placeholder_ui<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>新建 drawable/placeholder_ui</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">layer-list</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:opacity</span>=<span class="string">"opaque"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--状态栏颜色--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">"@color/colorPrimaryDark"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--假装这里是个toolbar--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:drawable</span>=<span class="string">"@color/colorPrimary"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:top</span>=<span class="string">"25dp"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--状态栏25+toolbar56=距离top81--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:drawable</span>=<span class="string">"@android:color/white"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:top</span>=<span class="string">"81dp"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layer-list</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同样需要在 manifest 修改启动页面的主题。据我所知，<a href="https://play.google.com/store/apps/details?id=com.czbix.v2ex&amp;hl=zh-CN" target="_blank" rel="noopener">V2EX+</a> 就是采用这种方法。</p><h2 id="注意的问题"><a href="#注意的问题" class="headerlink" title="注意的问题"></a>注意的问题</h2><p>以上的优化方案基本实现了启动页的基本功能，不过还是有一些小的问题需要注意的。</p><ol><li><p>只显示一次启动页（ App 没被 kill 的情况下）</p><p>微信打开之后，按下返回键回到桌面，再打开微信，并不会再看到启动页（除非你手动清了微信的后台或者被系统 kill 了），这个是怎么实现的呢？</p><p>其实很简单，只需要重写一下 <code>MainActivity</code> 的 <code>onBackPressed()</code> 方法就行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBackPressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// super.onBackPressed(); 不要调用父类的方法</span></span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_MAIN);</span><br><span class="line">    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">    intent.addCategory(Intent.CATEGORY_HOME);</span><br><span class="line">    startActivity(intent);</span><br><span class="line">    <span class="comment">// 或者直接使用 moveTaskToBack(true);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就实现了和微信一样的效果，按返回键不关闭 MainActivity（好恶心的做法~~）</p></li></ol><p>参考：</p><p><a href="http://wuxiaolong.me/2017/03/13/appStart/" target="_blank" rel="noopener">Android APP启动优化</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是App启动屏幕&quot;&gt;&lt;a href=&quot;#什么是App启动屏幕&quot; class=&quot;headerlink&quot; title=&quot;什么是App启动屏幕&quot;&gt;&lt;/a&gt;什么是App启动屏幕&lt;/h2&gt;&lt;p&gt;App 启动页 (Splash)，最经典的莫过于微信的启动页了&lt;/p&gt;
&lt;o
      
    
    </summary>
    
      <category term="Android" scheme="https://imeiji.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Android 仿知乎分享控件</title>
    <link href="https://imeiji.github.io/2017/10/02/Android%20%E4%BB%BF%E7%9F%A5%E4%B9%8E%E5%88%86%E4%BA%AB%E6%8E%A7%E4%BB%B6/"/>
    <id>https://imeiji.github.io/2017/10/02/Android 仿知乎分享控件/</id>
    <published>2017-10-02T06:10:54.000Z</published>
    <updated>2017-10-02T10:22:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用 BottomSheetDialog 实现仿知乎分享控件<br>主要步骤：</p><ol><li>首先获取手机内所有支持分享的应用，得到 ResolveInfo 对象，利用反射获取应用图标等信息</li><li>然后用 RecyclerView 的 GridLayoutManager 网格布局展示，自己实现点击事件就差不多完成了</li></ol><h2 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.loli.net/2017/10/02/59d21337b143b.png" alt="1.png" title="">                </div>                <div class="image-caption">1.png</div>            </figure><h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><ul><li><p>写一个分享界面的布局</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:padding</span>=<span class="string">"16dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"我是广告栏"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textAppearance</span>=<span class="string">"@style/TextAppearance.AppCompat"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">"18sp"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">View</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"1px"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"@android:color/darker_gray"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.v7.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/list_view"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在 Activity 里使用 BottomSheetDialog 控件显示</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BottomSheetDialog mBottomSheetDialog = new BottomSheetDialog(this);</span><br><span class="line">mBottomSheetDialog.setContentView(R.layout.dialog_bottom_sheet);</span><br><span class="line">mBottomSheetDialog.show();</span><br></pre></td></tr></table></figure></li><li><p>写一个 RecyclerViewAdapter 和 appinfo_item 布局</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;LinearLayout</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:gravity=&quot;center&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ImageView</span><br><span class="line">        android:id=&quot;@+id/img_list_item&quot;</span><br><span class="line">        android:layout_width=&quot;48dp&quot;</span><br><span class="line">        android:layout_height=&quot;48dp&quot;</span><br><span class="line">        android:scaleType=&quot;centerCrop&quot;</span><br><span class="line">        tools:src=&quot;@mipmap/ic_launcher&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/text_list_item&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_marginTop=&quot;2dp&quot;</span><br><span class="line">        android:ellipsize=&quot;end&quot;</span><br><span class="line">        android:singleLine=&quot;true&quot;</span><br><span class="line">        tools:text=&quot;分享11111111111111&quot;/&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></li><li><p>获取手机内所有支持分享的应用列表</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;ResolveInfo&gt; <span class="title">getShareApps</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        List&lt;ResolveInfo&gt; resolveInfoList;</span><br><span class="line">        PackageManager pm = context.getPackageManager();</span><br><span class="line">        resolveInfoList = pm.queryIntentActivities(intent, PackageManager.COMPONENT_ENABLED_STATE_DEFAULT);</span><br><span class="line">        <span class="keyword">return</span> resolveInfoList;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>返回数据给 Activity，然后设置 Adapter 就差不多完成，详细代码见 <a href="https://github.com/iMeiji/ZhihuShareDialog" target="_blank" rel="noopener">ZhihuShareDialog</a></p></li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li><p>通过 PackageManager 的 queryIntentActivities 方法获取到的应用是按照应用安装的先后顺序，而 Lollipop(5.0) 开始原生分享已支持自动把常用应用排在最顶部。当然也可以自己实现应用的排序，但比较折腾，可参考源码 <a href="https://github.com/android/platform_frameworks_base/blob/lollipop-release/core/java/com/android/internal/app/ResolverActivity.java#L1052" target="_blank" rel="noopener">ResolverActivity</a></p><p>​</p></li></ul><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>可以自定义分享界面，比如像知乎那样添加广告栏，设计一套属于自己的 UI ，设置应用的排列顺序等等</li></ul><hr><p>源码下载地址 ： <a href="https://github.com/iMeiji/ZhihuShareDialog" target="_blank" rel="noopener">https://github.com/iMeiji/ZhihuShareDialog</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用 BottomSheetDialog 实现仿知乎分享控件&lt;br&gt;主要步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先获取手机内所有支持分享的应用，得到 ResolveInfo 对象，利用反射获取应用图标等信息&lt;/li&gt;
&lt;li&gt;然后用 RecyclerView 的 GridLay
      
    
    </summary>
    
      <category term="Android" scheme="https://imeiji.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>OpenConnect VPN server</title>
    <link href="https://imeiji.github.io/2017/09/16/OpenConnect%20VPN%20server/"/>
    <id>https://imeiji.github.io/2017/09/16/OpenConnect VPN server/</id>
    <published>2017-09-16T06:10:54.000Z</published>
    <updated>2017-10-02T10:10:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>OpenConnet Server（ocserv）是通过实现Cisco的AnyConnect协议，用DTLS作为主要的加密传输协议。我认为它的主要好处在于——</p><ul><li>AnyConnect的VPN协议默认使用UDP DTLS作为数据传输，但如果有什么网络问题导致UDP传输出现问题，它会利用最初建立的TCP TLS通道作为备份通道，降低VPN断开的概率。</li><li>AnyConnect作为Cisco新一代的VPN解决方案，被用于许多大型企业，这些企业依赖它提供正常的商业运作，这些正常运作对应的经济效益（读作GDP），是我们最好的伙伴。</li><li>OpenConnet的架设足够麻烦，我的意思是，如果你不是大型企业，你会用AnyConnect的概率无限趋近于零。再者，如果它足够简单，我就不用写这篇文章了。<br>至于它的自定义路由表支持，我觉得都是次要了。</li></ul><p>介绍到此，让我们按步骤干好事情。</p><p>（下文选用 Debian8 和 ocser v0.11.8 作为标准环境）  </p><h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><ol><li><p>安装依赖</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install -y build-essential pkg-config libgnutls28-dev libreadline-dev libseccomp-dev libwrap0-dev libnl-nf-3-dev liblz4-dev libev-dev autogen</span><br></pre></td></tr></table></figure></li><li><p>编译安装</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看最新版本 http://www.infradead.org/ocserv/download.html</span></span><br><span class="line">wget ftp://ftp.infradead.org/pub/ocserv/ocserv-0.11.8.tar.xz</span><br><span class="line">tar xvf ocserv-*.tar.xz &amp;&amp; cd ocserv-*</span><br><span class="line">./configure </span><br><span class="line">make &amp;&amp; make install &amp;&amp; cd ..</span><br></pre></td></tr></table></figure></li></ol><h2 id="配置-OpenConnect-Server"><a href="#配置-OpenConnect-Server" class="headerlink" title="配置 OpenConnect Server"></a>配置 OpenConnect Server</h2><ol><li><p>配置证书</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装证书工具  </span><br><span class="line">apt-get install gnutls-bin</span><br><span class="line">cd ~ &amp;&amp; mkdir certificates &amp;&amp; cd certificates</span><br></pre></td></tr></table></figure><p>在此目录下创建一个名为<code>vi ca.tmpl</code> 的CA证书模板，写入如下语句：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cn = &quot;Your CA name&quot; </span><br><span class="line">organization = &quot;Your fancy name&quot; </span><br><span class="line">serial = 1 </span><br><span class="line">expiration_days = 3650</span><br><span class="line">ca </span><br><span class="line">signing_key </span><br><span class="line">cert_signing_key </span><br><span class="line">crl_signing_key</span><br></pre></td></tr></table></figure><p>生成CA密钥和证书</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">certtool --generate-privkey --outfile ca-key.pem</span><br><span class="line">certtool --generate-self-signed --load-privkey ca-key.pem --template ca.tmpl --outfile ca-cert.pem</span><br></pre></td></tr></table></figure><p>然后我们生成服务器证书<code>vi server.tmpl</code>，这里注意<code>cn</code> 项必须对应你服务器的域名或IP，内容如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cn = &quot;Your hostname or IP&quot; </span><br><span class="line">organization = &quot;Your fancy name&quot; </span><br><span class="line">expiration_days = 3650</span><br><span class="line">signing_key </span><br><span class="line">encryption_key</span><br><span class="line">tls_www_server</span><br></pre></td></tr></table></figure><p>生成Server密钥和证书</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">certtool --generate-privkey --outfile server-key.pem</span><br><span class="line">certtool --generate-certificate --load-privkey server-key.pem --load-ca-certificate ca-cert.pem --load-ca-privkey ca-key.pem --template server.tmpl --outfile server-cert.pem</span><br></pre></td></tr></table></figure><p>把证书移动到合适的地方：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp ca-cert.pem /etc/ssl/private/my-ca-cert.pem</span><br><span class="line">cp server-cert.pem /etc/ssl/private/my-server-cert.pem</span><br><span class="line">cp server-key.pem /etc/ssl/private/my-server-key.pem</span><br></pre></td></tr></table></figure></li><li><p>准备配置文件</p><p>我们把配置文件放到 ocserv 默认读取的位置：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /etc/ocserv</span><br><span class="line">cd ~/ocserv*</span><br><span class="line">cp doc/sample.config /etc/ocserv/ocserv.conf</span><br><span class="line">vi /etc/ocserv/ocserv.conf</span><br></pre></td></tr></table></figure><p>配置文件可以<a href="http://www.infradead.org/ocserv/manual.html" target="_blank" rel="noopener">官方手册</a>手册来写，不过这里我们重点要确保以下条目正确：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 登陆方式，目前先用密码登录</span><br><span class="line">auth = &quot;plain[/etc/ocserv/ocpasswd]&quot;</span><br><span class="line"> </span><br><span class="line"># 允许同时连接的客户端数量</span><br><span class="line">max-clients = 4</span><br><span class="line"> </span><br><span class="line"># 限制同一客户端的并行登陆数量</span><br><span class="line">max-same-clients = 2</span><br><span class="line"> </span><br><span class="line"># 服务监听的IP（服务器IP，可不设置）</span><br><span class="line">listen-host = 1.2.3.4</span><br><span class="line"> </span><br><span class="line"># 服务监听的TCP/UDP端口（选择你喜欢的数字）</span><br><span class="line">tcp-port = 9000</span><br><span class="line">udp-port = 9001</span><br><span class="line"> </span><br><span class="line"># 自动优化VPN的网络性能</span><br><span class="line">try-mtu-discovery = true</span><br><span class="line"> </span><br><span class="line"># 确保服务器正确读取用户证书（后面会用到用户证书）</span><br><span class="line">cert-user-oid = 2.5.4.3</span><br><span class="line"> </span><br><span class="line"># 服务器证书与密钥</span><br><span class="line">ca-cert = /etc/ssl/private/my-ca-cert.pem</span><br><span class="line">server-cert = /etc/ssl/private/my-server-cert.pem</span><br><span class="line">server-key = /etc/ssl/private/my-server-key.pem</span><br><span class="line"> </span><br><span class="line"># 客户端连上vpn后使用的dns</span><br><span class="line">dns = 8.8.8.8</span><br><span class="line">dns = 8.8.4.4</span><br><span class="line"> </span><br><span class="line"># 注释掉所有的route，让服务器成为gateway</span><br><span class="line">#route = 192.168.1.0/255.255.255.0</span><br><span class="line"> </span><br><span class="line"># 启用cisco客户端兼容性支持</span><br><span class="line">cisco-client-compat = true</span><br><span class="line"></span><br><span class="line">#据说可以优化速度</span><br><span class="line">output-buffer = 23000 </span><br><span class="line">try-mtu-discovery = true</span><br></pre></td></tr></table></figure></li><li><p>测试服务器</p><p>创建一个登陆用的用户名与密码<br><code>ocpasswd -c /etc/ocserv/ocpasswd your-username</code>  </p><p>修改内核设置，使得支持转发，<code>vi /etc/sysctl.conf</code>,将<code>net.ipv4.ip_forward=0</code>改为<code>net.ipv4.ip_forward=1</code> , 保存生效<code>sysctl -p</code>  </p><p>查看网卡信息<code>ifconfig</code>用于修改防火墙<br>开启NAT转发, 开启端口(对应上面配置的端口)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -j MASQUERADE</span><br><span class="line">iptables -A INPUT -p tcp --dport 443 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p udp --dport 443 -j ACCEPT</span><br><span class="line"># 规则保存 Ubuntu</span><br><span class="line">iptables-save &gt; /etc/iptables.rules</span><br><span class="line"># 规则保存 Debian</span><br><span class="line">apt-get install iptables-persistent -y</span><br><span class="line">service netfilter-persistent save</span><br></pre></td></tr></table></figure><p>使用<code>iptables -t nat -L</code>来验证转发是否开启成功  </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Chain PREROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line"> </span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line"> </span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line"> </span><br><span class="line">Chain POSTROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br><span class="line">MASQUERADE  all  --  192.168.1.0/24       anywhere</span><br></pre></td></tr></table></figure><p>使用 <code>iptables -L -n</code> 查看端口是否开启</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:443</span><br><span class="line">ACCEPT     udp  --  0.0.0.0/0            0.0.0.0/0            udp dpt:443</span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br></pre></td></tr></table></figure><p>使用<code>ocserv -f -d 1</code>命令来启动下服务啦<br>打开你手机上的 OpenConnect / Cisco Anyconnect 新建一个 VPN, 添加服务器 IP 就是你的 vps的IP:端口,例如<code>X.X.X.X:443</code><br>好了，如果你看到如下信息，那服务器应该已经能够正常运行了：  </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Parsing plain auth method subconfig using legacy format</span><br><span class="line">Setting &apos;plain&apos; as primary authentication method</span><br><span class="line">listening (TCP) on 0.0.0.0:443...</span><br><span class="line">listening (UDP) on 0.0.0.0:443...</span><br><span class="line">ocserv[16104]: main: initialized ocserv 0.11.8</span><br><span class="line">ocserv[16105]: sec-mod: reading supplemental config from files</span><br><span class="line">ocserv[16105]: sec-mod: sec-mod initialized (socket: /var/run/ocserv-socket.16104)</span><br><span class="line">ocserv[16109]: GnuTLS error (at worker-vpn.c:468): A TLS fatal alert has been received.: Unknown certificate</span><br><span class="line">ocserv[16104]: main: 60.0.14.48:9890 user disconnected</span><br><span class="line">ocserv[16105]: sec-mod: using &apos;plain&apos; authentication to authenticate user (session: FXS0l)</span><br><span class="line">ocserv[16104]: main: 60.0.14.48:36627 user disconnected</span><br><span class="line">ocserv[16105]: sec-mod: initiating session for user &apos;test&apos; (session: FXS0l)</span><br><span class="line">ocserv[16104]: main[test]: 60.0.14.48:9663 new user session</span><br><span class="line">ocserv[16104]: main[test]: 60.0.14.48:9663 user logged in</span><br><span class="line">ocserv[16104]: main: 60.0.14.48:46429 user disconnected</span><br><span class="line">ocserv[16104]: main[test]: 60.0.14.48:9663 user disconnected</span><br><span class="line">ocserv[16105]: sec-mod: temporarily closing session for test (session: FXS0l)</span><br><span class="line">ocserv[16105]: sec-mod: initiating session for user &apos;test&apos; (session: FXS0l)ocserv[16104]: main[test]: 60.0.14.48:38135 new user session</span><br><span class="line">ocserv[16104]: main[test]: 60.0.14.48:38135 user logged in</span><br></pre></td></tr></table></figure><p>好了，目前已经搞定了OpenConnect server，下面讲的是一些优化，创建客户端证书，智能分流  </p></li></ol><h2 id="优化OpenConnectServer"><a href="#优化OpenConnectServer" class="headerlink" title="优化OpenConnectServer"></a>优化OpenConnectServer</h2><ol><li><p>制作启动脚本</p><p>首先，来写个启动脚本——毕竟，不能每次都用调试模式启动不是吗？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /etc/init.d/ocserv</span><br></pre></td></tr></table></figure><p>在配置文件中写入如下脚本：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## BEGIN INIT INFO</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Provides:          ocserv</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Required-Start:    <span class="variable">$remote_fs</span> <span class="variable">$syslog</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Required-Stop:     <span class="variable">$remote_fs</span> <span class="variable">$syslog</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Default-Start:     2 3 4 5</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Default-Stop:      0 1 6</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## END INIT INFO</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Copyright Rene Mayrhofer, Gibraltar, 1999</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> This script is distibuted under the GPL</span></span><br><span class="line"></span><br><span class="line">PATH=/bin:/usr/bin:/sbin:/usr/sbin:/usr/local/sbin</span><br><span class="line">DAEMON=/usr/local/sbin/ocserv</span><br><span class="line">PIDFILE=/var/run/ocserv.pid</span><br><span class="line">DAEMON_ARGS="-c /etc/ocserv/ocserv.conf"</span><br><span class="line"></span><br><span class="line">case "$1" in</span><br><span class="line">start)</span><br><span class="line">if [ ! -r $PIDFILE ]; then</span><br><span class="line">echo -n "Starting OpenConnect VPN Server Daemon: "</span><br><span class="line">start-stop-daemon --start --quiet --pidfile $PIDFILE --exec $DAEMON -- \</span><br><span class="line"><span class="meta">$</span><span class="bash">DAEMON_ARGS &gt; /dev/null</span></span><br><span class="line">echo "ocserv."</span><br><span class="line">else</span><br><span class="line">echo -n "OpenConnect VPN Server is already running.\n\r"</span><br><span class="line">exit 0</span><br><span class="line">fi</span><br><span class="line">;;</span><br><span class="line">stop)</span><br><span class="line">echo -n "Stopping OpenConnect VPN Server Daemon: "</span><br><span class="line">start-stop-daemon --stop --quiet --pidfile $PIDFILE --exec $DAEMON</span><br><span class="line">echo "ocserv."</span><br><span class="line">rm -f $PIDFILE</span><br><span class="line">;;</span><br><span class="line">force-reload|restart)</span><br><span class="line">echo "Restarting OpenConnect VPN Server: "</span><br><span class="line"><span class="meta">$</span><span class="bash">0 stop</span></span><br><span class="line">sleep 1</span><br><span class="line"><span class="meta">$</span><span class="bash">0 start</span></span><br><span class="line">;;</span><br><span class="line">status)</span><br><span class="line">if [ ! -r $PIDFILE ]; then</span><br><span class="line"><span class="meta">#</span><span class="bash"> no pid file, process doesn<span class="string">'t seem to be running correctly</span></span></span><br><span class="line">exit 3</span><br><span class="line">fi</span><br><span class="line">PID=`cat $PIDFILE | sed 's/ //g'`</span><br><span class="line">EXE=/proc/$PID/exe</span><br><span class="line">if [ -x "$EXE" ] &amp;&amp;</span><br><span class="line">[ "`ls -l \"$EXE\" | cut -d'&gt;' -f2,2 | cut -d' ' -f2,2`" = \</span><br><span class="line">"$DAEMON" ]; then</span><br><span class="line"><span class="meta">#</span><span class="bash"> ok, process seems to be running</span></span><br><span class="line">exit 0</span><br><span class="line">elif [ -r $PIDFILE ]; then</span><br><span class="line"><span class="meta">#</span><span class="bash"> process not running, but pidfile exists</span></span><br><span class="line">exit 1</span><br><span class="line">else</span><br><span class="line"><span class="meta">#</span><span class="bash"> no lock file to check <span class="keyword">for</span>, so simply <span class="built_in">return</span> the stopped status</span></span><br><span class="line">exit 3</span><br><span class="line">fi</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">echo "Usage: /etc/init.d/ocserv &#123;start|stop|restart|force-reload|status&#125;"</span><br><span class="line">exit 1</span><br><span class="line">;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>赋予其可执行权限</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 755 /etc/init.d/ocserv`</span><br><span class="line">update-rc.d ocserv defaults</span><br></pre></td></tr></table></figure><p>之后就可以使用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/etc/init.d/ocserv start | stop | restart</span><br><span class="line">service ocserv start | stop | restart</span><br></pre></td></tr></table></figure></li><li><p>免密码登录</p><p>创建客户端证书，省的老输入密码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~/certificates/</span><br><span class="line">vi user.tmpl</span><br></pre></td></tr></table></figure><p>写入如下内容：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cn = &quot;some random name&quot;</span><br><span class="line">unit = &quot;some random unit&quot;</span><br><span class="line">expiration_days = 365</span><br><span class="line">signing_key</span><br><span class="line">tls_www_client</span><br></pre></td></tr></table></figure><p>生成User密钥和证书</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">certtool --generate-privkey --outfile user-key.pem</span><br><span class="line">certtool --generate-certificate --load-privkey user-key.pem --load-ca-certificate ca-cert.pem --load-ca-privkey ca-key.pem --template user.tmpl --outfile user-cert.pem</span><br></pre></td></tr></table></figure><p>然后要将证书和密钥转为PKCS12的格式</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">certtool --to-p12 --load-privkey user-key.pem --pkcs-cipher 3des-pkcs12 --load-certificate user-cert.pem --outfile user.p12 --outder</span><br></pre></td></tr></table></figure><p>期间会要求你输入证书名字和密码。</p><p>然后你需要把这个证书放到一个可以被直接访问的地方，然后通过 URL 将 user.p12 文件导入AnyConnect，具体位置在诊断标签页的证书栏目下，导入成功之后，将对应的VPN设置的高级设置部分的证书栏目，改为导入的这张证书。</p><p>现在，为了让服务器能够认得这张证书，我们再来修改一下配置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /etc/ocserv/ocserv.conf</span><br><span class="line"> </span><br><span class="line"># 改为证书登陆，注释掉原来的登陆模式</span><br><span class="line">auth = &quot;certificate&quot;</span><br><span class="line"> </span><br><span class="line"># 证书认证不支持这个选项，注释掉这行</span><br><span class="line">#listen-clear-file = /var/run/ocserv-conn.socket</span><br><span class="line"> </span><br><span class="line"># 启用证书验证</span><br><span class="line">ca-cert = /etc/ssl/private/my-ca-cert.pem</span><br></pre></td></tr></table></figure><p>这样，我们使用<code>service ocserv restart</code>来启动它即可！        </p></li><li><p>智能分流</p><p>编译 ocserv 前需要修改 src/vpn.h 来支持超过 96 行(ocserv默认值)但不超过200行(Cisco AnyConnect最大值)的路由表:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi ~/ocserv*/src/vpn.h</span><br><span class="line">#把96改为200以上</span><br><span class="line">#define DEFAULT_CONFIG_ENTRIES 96</span><br></pre></td></tr></table></figure><p>修改 ocserv 配置文件，添加<a href="https://github.com/CNMan/ocserv-cn-no-route/blob/master/cn-no-route.txt" target="_blank" rel="noopener">这些内容</a></p></li></ol><hr><p>补充:<br>一键脚本(新) <a href="https://moeclub.org/2017/06/22/268/" target="_blank" rel="noopener">https://moeclub.org/2017/06/22/268/</a><br>一键脚本 <a href="https://github.com/fanyueciyuan/eazy-for-ss/tree/master/ocservauto" target="_blank" rel="noopener">https://github.com/fanyueciyuan/eazy-for-ss/tree/master/ocservauto</a><br>注意Anyconnect和速锐一起使用的话,首先要禁止掉udp-port(详细看配置文件) ,接着重启速锐 最后重启Anyconnect    </p><p>参考:<br><a href="http://bitinn.net/11084/" target="_blank" rel="noopener">http://bitinn.net/11084/</a><br><a href="https://www.logcg.com/archives/1343.html" target="_blank" rel="noopener">https://www.logcg.com/archives/1343.html</a><br><a href="http://www.fanyueciyuan.info/fq/ocserv-debian.html" target="_blank" rel="noopener">http://www.fanyueciyuan.info/fq/ocserv-debian.html</a><br><a href="https://github.com/CNMan/ocserv-cn-no-route" target="_blank" rel="noopener">https://github.com/CNMan/ocserv-cn-no-route</a>    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;OpenConnet Server（ocserv）是通过实现Cisco的AnyConnect协议，用DTLS作为主要的加密传输协议。我认为它的主要好处在于——&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AnyConnect的VPN协议默认使用UDP DTLS作为数据传输，但如果有什么网络问
      
    
    </summary>
    
      <category term="GFW" scheme="https://imeiji.github.io/categories/GFW/"/>
    
    
  </entry>
  
  <entry>
    <title>Android Studio设置教程</title>
    <link href="https://imeiji.github.io/2017/08/22/Android%20Studio%E8%AE%BE%E7%BD%AE%E6%95%99%E7%A8%8B/"/>
    <id>https://imeiji.github.io/2017/08/22/Android Studio设置教程/</id>
    <published>2017-08-22T09:16:34.000Z</published>
    <updated>2018-05-31T16:39:55.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章是很久之前就写好了, 一直没有发出来, 这篇教程比较折腾, 好处是你的系统盘不会给塞满, 我把所有配置都转移到非系统盘, 如果你的 AS 用久了可以看看 <code>.AndroidStudio</code> 文件夹有多大, 再考虑转移配置</p></blockquote><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>官网 <a href="http://developer.android.com/sdk/index.html" target="_blank" rel="noopener">http://developer.android.com/sdk/index.html</a><br>各个版本 <a href="http://tools.android.com/download/studio" target="_blank" rel="noopener">http://tools.android.com/download/studio</a> </p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>请按照实际情况进行修改(Android SDK 我就没配置, 反正可以选下载路径)<br>PATH的要特别注意, 要加到原来的后面  </p><ul><li><p>ADB</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Android=D:\Users\XXX\AppData\Local\Android\sdk\platform-tools</span><br><span class="line">Path=;%Android%;</span><br></pre></td></tr></table></figure></li><li><p>Java</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JAVA_HOME=C:\Program Files\Java\jdk1.8.0_66</span><br><span class="line">CLASSPATH=.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar</span><br><span class="line"># 注意，%PATH%为原来的环境变量值，添加&quot;;&quot;和后面的内容到原来值的后面</span><br><span class="line">PATH=%PATH%;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin</span><br></pre></td></tr></table></figure></li><li><p>Gradle</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Android Studio正式版后就内置了一个Gradle，当然你也可以另外去Gradle官网下载一个</span><br><span class="line">GRADLE_HOME=D:\Program Files\android-studio\gradle\gradle-2.10</span><br><span class="line">PATH=%PATH%;%GRADLE_HOME%\bin</span><br><span class="line"># 依赖仓库存放路径，平时构建工程时下载的依赖库都放在这里</span><br><span class="line"># 不配置的话，Windows中默认是在C:\Users\&lt;username&gt;\.gradle的</span><br><span class="line"># 重装系统时忘记备份，又不想重新下载依赖的话，就赶紧把这里改了</span><br><span class="line">GRADLE_USER_HOME=D:\Users\XXX\.gradle</span><br></pre></td></tr></table></figure></li><li><p>Android SDK  </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ANDROID_HOME=E:\DevTools\Android\sdk</span><br><span class="line">PATH=%PATH%;%ANDROID_HOME%\tools;%ANDROID_HOME%\platform-tools</span><br><span class="line"># ADB端口，可以避免国内一堆软件，如酷狗音乐啥的把ADB端口抢占了，值随便改个不常用的就行</span><br><span class="line">ANDROID_ADB_SERVER_PORT=7123</span><br></pre></td></tr></table></figure></li><li><p>Android Studio</p><p>本来是用默认路径也没什么问题，不过在 Windows 环境下，什么东西都往系统盘里塞老是让人觉得不舒服</p><ul><li><p>修改 <code>idea.properties</code> 文件  </p><p>进入 Android Studio 的安装目录, 进入bin文件夹 ,打开 <code>idea.properties</code>  , 修改对应的路径为新路径即可. (PS: 如果你的 <code>idea.properties</code>  文件文件没有以下内容, <a href="http://tools.android.com/tech-docs/configuration" target="_blank" rel="noopener">点这里</a>下载一个, 覆盖到bin文件夹)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">idea.config.path=D:/Users/XXX/.AndroidStudio/config</span><br><span class="line">idea.system.path=D:/Users/XXX/.AndroidStudio/system</span><br><span class="line">idea.plugins.path=$&#123;idea.system.path&#125;/plugins</span><br><span class="line">idea.log.path=$&#123;idea.system.path&#125;/log</span><br></pre></td></tr></table></figure><p>注意<code>plugins</code>和<code>log</code>的路径不要乱改, 不然插件会安装不上<br>这种方式改完之后问题是解决了, 可是之后你在增量升级 AS 的时候就会发现总是失败, 原因就是因为你改了 bin 目录下的 <code>idea.properties</code>  文件, 那么 Google 给出的解决办法就是不要直接改 bin 目录下的 <code>idea.properties</code>  文件, 而是在 <code>%USERPROFILE%\.{FOLDER_NAME}\</code>  目录下创建一个空的<code>idea.properties</code>  文件, 把修改过的 <code>idea.properties</code> 文件复制到这里</p></li><li><p><code>.android</code> 文件夹的修改 </p><p>这个文件夹是由 Android SDK 配置模拟器生成的, 也是最占空间的一个<br>首先, 需要添加一个系统的环境变量<br>变量名<code>ANDROID_SDK_HOME</code><br>变量值<code>D:\Users\XXX</code></p></li></ul></li></ul><h2 id="设置Android-Studio"><a href="#设置Android-Studio" class="headerlink" title="设置Android Studio"></a>设置Android Studio</h2><p>不要急着新建工程,先Configure→Settings去修改设置</p><ul><li><p>修改主题,全局字体</p><p><img src="http://i.imgur.com/TBaBBoL.png" alt=""><br>主题默认就好,个人不喜欢深色主题,字体选<code>Microsoft YaHei UI</code>就不错了</p><p>​</p></li><li><p>禁止自动打开上次的工程</p><p><img src="http://i.imgur.com/hWbUQJw.png" alt="Imgur"></p><p>​</p></li><li><p>设置代理</p><p><img src="http://i.imgur.com/dNkZTxI.png" alt="Imgur"></p><p>​</p></li><li><p>SDK目录</p><p><img src="http://i.imgur.com/Kh2X0VK.png" alt="Imgur"></p></li></ul><ul><li><p>快捷键</p><p>不推荐使用 Eclipse 快捷键了, 很多功能会缺失, 强烈建议使用 IDEA 的快捷键<br><img src="http://i.imgur.com/ISqSFIO.png" alt="Imgur"></p></li></ul><ul><li><p>鼠标悬停显示文档, 格式化&amp;导包提示</p><p><img src="http://i.imgur.com/RuGGzmM.png" alt="Imgur"></p><ul><li>鼠标指针悬停若干时间, 显示文档, 时间自己改</li><li>就是按格式化代码或者导包时, 是否会显示个对话框</li></ul></li></ul><ul><li><p>自动导包</p><p><img src="http://i.imgur.com/YuCVtDI.png" alt="Imgur"></p></li></ul><ul><li><p>显示行号, 显示方法分隔线</p><p><img src="http://i.imgur.com/UWDzVPc.png" alt="Imgur"></p></li></ul><ul><li><p>代码智能提示</p><p><img src="http://i.imgur.com/WQy5bVQ.png" alt="Imgur"></p><ol><li>敲什么字符会提示<ul><li>All 大小写全部符合</li><li>None 不管大小写, 符合就提示</li><li>First letter 第一个字符符合就OK, 其他随意</li></ul></li><li>自动弹出时间自己改下</li></ol><p>​</p></li><li><p>代码样式配置</p><p><img src="http://i.imgur.com/0ZOskTn.png" alt="Imgur"></p></li></ul><ul><li><p>修改注释位置, 禁用“语句堆一行”</p><p><img src="http://i.imgur.com/7z4UgAF.png" alt="Imgur"></p><ul><li>Line breaks: 启用的话, 表示保持断行</li><li>Comment at frist column: 启用的话, 注释符号就会在行首, 否则就按照缩进来注释</li><li>Control statement in one line: 格式化代码的时候, 会把些很短的语句合并成一行. 我觉得这样影响代码可读性, 故取消</li><li>Ensure right margin is not exceeded: 表示代码超过标准线就自动换行</li></ul></li></ul><ul><li><p>修改新建文件文件头</p><p><img src="http://i.imgur.com/HjWR4NW.png" alt="Imgur"></p></li></ul><ul><li><p>修改文件编码为UTF-8</p><p><img src="http://i.imgur.com/Wu7625a.png" alt="Imgur"></p></li></ul><ul><li><p>修改Gradle目录</p><p><img src="http://i.imgur.com/2vYMJBz.png" alt="Imgur"></p></li></ul><ul><li><p>开启Instant Run</p><p><img src="http://i.imgur.com/ynI0US0.png" alt="Imgur"></p></li></ul><hr><p>到此已经配置好 AS , 新建一个工程试试吧<br>为了保险, 打开Android Studio内置的终端, 在输入如下命令查看 gradle 版本:<code>gradlew -v</code><br>配置没问题的话就显示你的 gradle 版本, 如果你配置错误 AS 会自动下载并安装个 gradle</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul><li>Gradle 设置代理</li></ul><ol><li><p>找到 <code>gradle.properties</code> 这个文件，如果你按照我上面的环境变量设置，那么文件在<code>GRADLE_USER_HOME=D:\Users\XXX\.gradle</code> 下，否则在 C 盘</p></li><li><p>修改 <code>gradle.properties</code> 这个文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span># Proxy setup</span><br><span class="line">systemProp.proxySet="true"</span><br><span class="line">systemProp.http.keepAlive="true"</span><br><span class="line">systemProp.http.proxyHost=127.0.0.1</span><br><span class="line">systemProp.http.proxyPort=1080</span><br><span class="line">systemProp.https.keepAlive="true"</span><br><span class="line">systemProp.https.proxyHost=127.0.0.1</span><br><span class="line">systemProp.https.proxyPort=1080</span><br><span class="line"><span class="meta">#</span># 据说只要添加下面这行 https://www.zhihu.com/question/37810416/answer/82464203</span><br><span class="line">org.gradle.jvmargs=-DsocksProxyHost=127.0.0.1 -DsocksProxyPort=1080</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span># 自动删除 30 天前的缓存</span><br><span class="line">buildCache &#123; local &#123; removeUnusedEntriesAfterDays = 30 &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span># 为所有的构建启用构建缓存</span><br><span class="line">org.gradle.caching=true</span><br></pre></td></tr></table></figure></li></ol><ul><li><p><a href="http://color-themes.com/" target="_blank" rel="noopener">IDEA主题</a></p></li><li><p>修改最大堆内存 </p><p>在Help菜单下面，有个Edit Custom VM Option 选项，可以直接打开那个studio(64?).vmoptions文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Xmx4g</span><br></pre></td></tr></table></figure></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhihu.com/question/38604486" target="_blank" rel="noopener">自定义androidstudio的配置文件目录后，无法正常安装和卸载插件，是何原因？ - 知乎</a></p><p><a href="https://www.zhihu.com/question/32282404/answer/55605283" target="_blank" rel="noopener">Android Studio 使用起来很卡，你们是如何解决的？</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;文章是很久之前就写好了, 一直没有发出来, 这篇教程比较折腾, 好处是你的系统盘不会给塞满, 我把所有配置都转移到非系统盘, 如果你的 AS 用久了可以看看 &lt;code&gt;.AndroidStudio&lt;/code&gt; 文件夹有多大, 再考虑转移配置&lt;/
      
    
    </summary>
    
      <category term="Android" scheme="https://imeiji.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Windows 软件清单</title>
    <link href="https://imeiji.github.io/2017/07/10/Windows%20%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95/"/>
    <id>https://imeiji.github.io/2017/07/10/Windows 软件清单/</id>
    <published>2017-07-09T16:22:01.000Z</published>
    <updated>2018-03-30T14:11:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录下自己常用的软件, 整理软件清单, 便于后续持续利用</p><blockquote><p>浏览器</p></blockquote><ul><li>Chrome</li><li>Firefox</li></ul><blockquote><p>编辑器</p></blockquote><ul><li>Notepad++</li><li>Sublime Text</li></ul><blockquote><p>Markdown工具</p></blockquote><ul><li>Typora</li><li>MarkdownPad 2</li></ul><blockquote><p>笔记工具</p></blockquote><ul><li>Evernote</li></ul><blockquote><p>代理工具</p></blockquote><ul><li>SS / SSR</li><li>Proxifier</li><li>SSTap</li><li>SocksCap64</li><li>AnyConnect</li><li>OpenConnect</li></ul><blockquote><p>聊天工具</p></blockquote><ul><li>QQ Lite / TIM</li><li>WeChat</li><li>Telegram</li><li>Discord</li></ul><blockquote><p>系统工具</p></blockquote><ul><li>f.lux</li><li>MacType</li><li>Dism++</li><li>Listary</li><li>uTrun</li><li>Geek Uninstaller</li><li>CCleaner</li><li>VMware</li></ul><blockquote><p>截图工具</p></blockquote><ul><li>FastStone Capture</li><li>Snipaste</li></ul><blockquote><p>下载工具</p></blockquote><ul><li>Thunder</li><li>IDM</li><li>qBittorrent</li></ul><blockquote><p>办公工具</p></blockquote><ul><li>Office / WPS</li><li>PDF-XChange Viewer</li><li>SumatraPDF</li></ul><blockquote><p>远程工具</p></blockquote><ul><li>TeamViewer</li><li>VNC </li></ul><blockquote><p>词典</p></blockquote><ul><li>欧路词典</li></ul><blockquote><p>开发环境</p></blockquote><ul><li>JDK &amp; JRE</li><li>Python</li><li>Node.js</li><li>Git</li><li>MySQL</li></ul><blockquote><p>IDE</p></blockquote><ul><li>Navicat JRE</li><li>Source Insight</li><li>SqliteBrowser</li><li>IntelliJ IDEA</li><li>Android Studio</li></ul><blockquote><p>播放器</p></blockquote><ul><li>网易云音乐</li><li>AIMP</li><li>PotPlayer</li><li>MPC-BE</li></ul><blockquote><p>压缩工具</p></blockquote><ul><li>7zip</li><li>Bandizip</li></ul><blockquote><p>图片浏览器</p></blockquote><ul><li>蜂蜜浏览器</li></ul><blockquote><p>网络抓包</p></blockquote><ul><li>Charles</li><li>Wireshark</li><li>Fiddler</li></ul><blockquote><p>终端工具</p></blockquote><ul><li>Xshell</li><li>Xftp</li></ul><blockquote><p>游戏</p></blockquote><ul><li>Steam</li><li>Origin</li></ul><blockquote><p>其他</p></blockquote><ul><li>Clover 资源管理器多标签拓展</li><li>Ditto 剪切板记录</li><li>Everthing 全盘搜索</li><li>Beyond Compare 文件对比</li><li>WinMTR 路由追踪</li><li>SpaceSniffer 查看硬盘空间占用</li><li>NetLimiter 网速限制</li><li>FxSound Enhancer 音效增强</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录下自己常用的软件, 整理软件清单, 便于后续持续利用&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;浏览器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Chrome&lt;/li&gt;
&lt;li&gt;Firefox&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;编辑器&lt;/p
      
    
    </summary>
    
      <category term="Default" scheme="https://imeiji.github.io/categories/Default/"/>
    
    
  </entry>
  
  <entry>
    <title>搭建 sspanel v3 魔改版记录</title>
    <link href="https://imeiji.github.io/2017/01/09/%E6%90%AD%E5%BB%BA%20sspanel%20v3%20%E9%AD%94%E6%94%B9%E7%89%88%E8%AE%B0%E5%BD%95/"/>
    <id>https://imeiji.github.io/2017/01/09/搭建 sspanel v3 魔改版记录/</id>
    <published>2017-01-09T07:57:01.000Z</published>
    <updated>2017-03-20T11:21:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>前端使用赵大的魔改版 <a href="https://github.com/esdeathlove/ss-panel-v3-mod" target="_blank" rel="noopener">https://github.com/esdeathlove/ss-panel-v3-mod</a></p><p>后端也使用赵大的魔改版 <a href="https://github.com/esdeathlove/shadowsocks" target="_blank" rel="noopener">https://github.com/esdeathlove/shadowsocks</a></p><p>演示环境 : VirMach 512RAM机子 Ubuntu 14 x64</p><h2 id="安装前端"><a href="#安装前端" class="headerlink" title="安装前端"></a>安装前端</h2><p>1.安装 LNMP</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">screen -S lnmp</span><br><span class="line">2G以上内存</span><br><span class="line">wget http://soft.vpser.net/lnmp/lnmp1.3-full.tar.gz &amp;&amp; tar xvzf lnmp1.3-full.tar.gz</span><br><span class="line"><span class="built_in">cd</span> lnmp1.3-full &amp;&amp; ./install.sh</span><br><span class="line">1G以下内存</span><br><span class="line">wget http://soft.vpser.net/lnmp/lnmp1.2-full.tar.gz &amp;&amp; tar xvzf lnmp1.2-full.tar.gz</span><br><span class="line"><span class="built_in">cd</span> lnmp1.2-full &amp;&amp; ./install.sh</span><br></pre></td></tr></table></figure><p>安装过程要求输入MySQL密码, 选择MySQL版本&gt;=5.5, PHP版本&gt;5.6.</p><p>安装大概需要半小时, 如果中途 ssh 断线, 输入 <code>screen -r lnmp</code> </p><p>2.设置虚拟主机</p><p><code>lnmp vhost add</code></p><p>要求输入你的域名, 然后其余项都选 <code>no</code></p><p>接着修改下 nginx</p><p>编辑 <code>/usr/local/nginx/conf/vhost/你的域名.conf</code></p><p>然后添加下面这一段到 server</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">location / </span><br><span class="line">&#123;</span><br><span class="line">try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.php<span class="variable">$is_args</span><span class="variable">$args</span>;                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 root 那一行为</p><p><code>root /home/wwwroot/你的域名/public;</code></p><p>3.下载 sspanel 代码</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/wwwroot/你的域名</span><br><span class="line">apt-get install git -y</span><br><span class="line">git <span class="built_in">clone</span> -b master https://github.com/esdeathlove/ss-panel-v3-mod.git tmp &amp;&amp; mv tmp/.git . &amp;&amp; rm -rf tmp &amp;&amp; git reset --hard</span><br><span class="line">chown -R root:root *</span><br><span class="line">chmod -R 755 *</span><br><span class="line">chown -R www:www storage</span><br><span class="line">chattr -i .user.ini</span><br><span class="line">mv .user.ini public</span><br><span class="line"><span class="built_in">cd</span> public</span><br><span class="line">chattr +i .user.ini</span><br><span class="line">service nginx restart</span><br></pre></td></tr></table></figure><p>4.安装 radius , 不使用VPN的话, 可以不进行这一步</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先安装perl</span></span><br><span class="line">apt-get install perl  </span><br><span class="line"><span class="comment"># 然后需要安装perl的DBI组件</span></span><br><span class="line">perl -MCPAN -e shell</span><br><span class="line">cpan&gt;install DBI</span><br><span class="line"></span><br><span class="line">//安装完成后退出cpan</span><br><span class="line">cpan&gt;quit</span><br><span class="line"><span class="comment"># 再安装其它组件</span></span><br><span class="line">apt install freeradius freeradius-mysql freeradius-utils</span><br></pre></td></tr></table></figure><p>5.配置数据库</p><p>浏览器打开 <code>http://你的vps ip/phpmyadmin</code></p><p>用户 : root</p><p>密码 :安装 lnmp 时设置的</p><p>需要创建一个数据库和一个访问这个数据库的用户</p><p>点击 <code>用户</code> -&gt; <code>新建</code> -&gt; <code>添加用户</code> </p><ul><li><p>登录信息 :</p><p>Username 选择 使用文本域 , 填写你的用户名 如 sspanel   </p><p>Host 选择任意主机  %</p><p>密码 选择使用文本域 填写密码</p></li><li><p>用户数据库 :</p><p>勾选 创建与用户同名的数据库并授予所有权限</p></li><li><p>全局权限 :</p><p>全选</p></li></ul><p>接着按执行 选择刚刚新建的数据库 sspanel 导入程序目录下的 glzjin_all.sql</p><p>不适用 VPN 的话跳下一步</p><p>接着配置 radius , 创建个 radius 数据库和用户 (重复以上步骤)</p><p>选择 radius 数据库 导入 <a href="https://github.com/glzjin/Radius-install/raw/master/all.sql" target="_blank" rel="noopener">https://github.com/glzjin/Radius-install/raw/master/all.sql</a></p><p>回到 ssh 继续设置 radius</p><p>编辑 <code>/etc/freeradius/sql.conf</code></p><p>配置 login(用户名), password(密码), radius_db(数据库名)等字段</p><p>找到 readclients 一行，设为 yes 并去掉注释符号#</p><p>然后下面是几个文件的覆盖</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget https://github.com/glzjin/Radius-install/raw/master/radiusd.conf -O /etc/freeradius/radiusd.conf</span><br><span class="line">wget https://github.com/glzjin/Radius-install/raw/master/default -O /etc/freeradius/sites-enabled/default</span><br><span class="line">wget https://github.com/glzjin/Radius-install/raw/master/dialup.conf -O /etc/freeradius/sql/mysql/dialup.conf</span><br><span class="line">wget https://github.com/glzjin/Radius-install/raw/master/dictionary -O /etc/freeradius/dictionary</span><br><span class="line">wget https://github.com/glzjin/Radius-install/raw/master/counter.conf -O /etc/freeradius/sql/mysql/counter.conf</span><br></pre></td></tr></table></figure><p>Radius 配置完成,</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service freeradius start</span><br></pre></td></tr></table></figure><p>然后你也可以将该 freeradius 设为开机启动项</p><p>6.配置 sspanel</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/wwwroot/你的域名</span><br><span class="line">cp config/.config.php.example config/.config.php</span><br><span class="line"><span class="comment"># 编辑以下文件 建议使用 FTP 下载到本地修改</span></span><br><span class="line">vi config/.config.php</span><br></pre></td></tr></table></figure><p>由于配置太多 这里只说重点</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="variable">$System_Config</span>[<span class="string">'key'</span>] = <span class="string">''</span>;//修改此key为随机字符串确保网站安全</span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'appName'</span>] = <span class="string">''</span>;             //站点名称</span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'baseUrl'</span>] = <span class="string">'https://zhaojin97.cn'</span>;            // 站点地址</span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'timeZone'</span>] = <span class="string">'PRC'</span>;        // RPC 天朝时间  UTC 格林时间</span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'pwdMethod'</span>] = <span class="string">'sha256'</span>;       // 密码加密   可选 md5,sha256</span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'salt'</span>] = <span class="string">''</span>;               // 密码加密用，从旧版升级请留空</span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'authDriver'</span>] = <span class="string">'cookie'</span>;   // 登录验证存储方式,推荐使用Redis   可选: cookie,redis</span><br><span class="line"></span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'mailDriver'</span>] = <span class="string">'mailgun'</span>;   // 邮件 可选 mailgun or smtp 需要支持qq邮箱的选 smtp</span><br><span class="line"></span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'checkinMin'</span>] = <span class="string">'100'</span>;       // 签到最少流量 单位MB</span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'checkinMax'</span>] = <span class="string">'500'</span>;       // 签到最多流量</span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'defaultTraffic'</span>] = <span class="string">'100'</span>;      // 用户初始流量 单位GB</span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'inviteNum'</span>] = <span class="string">'0'</span>;// 注册后获得的邀请码数量</span><br><span class="line"></span><br><span class="line"><span class="comment"># database 数据库配置</span></span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'db_driver'</span>] = <span class="string">'mysql'</span>;</span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'db_host'</span>] = <span class="string">'localhost'</span>;// 数据库地址</span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'db_database'</span>] = <span class="string">''</span>;// 数据库名称 sspanel</span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'db_username'</span>] = <span class="string">''</span>;// 数据库用户 sspanel</span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'db_password'</span>] = <span class="string">''</span>;// sspanel用户的密码</span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'db_charset'</span>] = <span class="string">'utf8'</span>;</span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'db_collation'</span>] = <span class="string">'utf8_general_ci'</span>;</span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'db_prefix'</span>] = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># redis</span></span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'redis_scheme'</span>] = <span class="string">'tcp'</span>;// 登录验证存储方式选了 redis 的话需要配置</span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'redis_host'</span>] = <span class="string">'127.0.0.1'</span>;</span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'redis_port'</span>] = <span class="string">'6379'</span>;</span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'redis_database'</span>] = <span class="string">'0'</span>;</span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'redis_password'</span>]=<span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># smtp</span></span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'smtp_host'</span>] = <span class="string">''</span>;// 例如 smtp.qq.com</span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'smtp_username'</span>] = <span class="string">''</span>;</span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'smtp_port'</span>] = <span class="string">'25'</span>;</span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'smtp_name'</span>] = <span class="string">''</span>;</span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'smtp_sender'</span>] = <span class="string">''</span>;</span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'smtp_passsword'</span>] = <span class="string">''</span>;</span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'smtp_ssl'</span>] = <span class="string">'false'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#功能开关  需要用到的才开 建议先别动</span></span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'enable_wecenter'</span>]=<span class="string">'false'</span>;</span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'enable_radius'</span>]=<span class="string">'false'</span>;// 配置了 radius 的话就开</span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'enable_cloudxns'</span>]=<span class="string">'false'</span>;</span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'enable_duoshuo'</span>]=<span class="string">'false'</span>;</span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'enable_rss'</span>]=<span class="string">'true'</span>;</span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'enable_paymentwall'</span>]=<span class="string">'false'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#Radius数据库设置</span></span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'radius_db_host'</span>]=<span class="string">''</span>;// 跟 上面 database 数据库配置差不多 换成radius即可</span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'radius_db_database'</span>]=<span class="string">''</span>;</span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'radius_db_user'</span>]=<span class="string">''</span>;</span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'radius_db_password'</span>]=<span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#Radius连接密钥</span></span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'radius_secret'</span>]=<span class="string">''</span>;// 这个重要 必须设</span><br><span class="line"></span><br><span class="line"><span class="comment">#端口池</span></span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'min_port'</span>]=<span class="string">'10000'</span>;// SSR 分配端口号范围</span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'max_port'</span>]=<span class="string">'65535'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#两种方式相对于ss端口的偏移</span></span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'pacp_offset'</span>]=<span class="string">'-20000'</span>;// PAC+ 和 PAC++ 用到</span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'pacpp_offset'</span>]=<span class="string">'-20000'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#测速周期/h</span></span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'Speedtest_duration'</span>]=<span class="string">'6'</span>;// 对应后端 SSR 的 userapiconfig.py 里的 SPEEDTEST</span><br><span class="line"></span><br><span class="line"><span class="comment">#随机分组，注册时随机分配到的分组，多个分组请用英文半角逗号分隔。</span></span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'ramdom_group'</span>]=<span class="string">'0'</span>;// 组别用于区分用户组 对应组只能访问对应组和0组的服务器 明白后再修改 </span><br><span class="line"></span><br><span class="line"><span class="comment">#充值返利百分比</span></span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'code_payback'</span>]=<span class="string">'20'</span>;// 用户充值后 给邀请他注册的人返利多少%</span><br><span class="line"></span><br><span class="line"><span class="comment">#注册时的流量重置日以及需要重置的流量,0不重置</span></span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'reg_auto_reset_day'</span>]=<span class="string">'0'</span>;</span><br><span class="line"><span class="variable">$System_Config</span>[<span class="string">'reg_auto_reset_bandwidth'</span>]=<span class="string">'100'</span>;// 单位G</span><br></pre></td></tr></table></figure><p>以上为 config 部分配置 完成后保存并上传到原目录下</p><p>切换到 ssh 窗口, 在你的网站目录下执行以下命令创建管理员</p><p><code>php xcat createAdmin</code>  </p><p>按照提示, 输入管理员邮箱密码等信息, 然后执行以下命令同步用户</p><p><code>php xcat syncusers</code>  </p><p>此时管理员创建完成</p><p>接下来需要对服务器进行计划任务的设置,执行 <code>crontab -e</code> 命令, 添加以下五段</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">30 22 * * * php /home/wwwroot/站点文件夹/xcat sendDiaryMail </span><br><span class="line">*/1 * * * * php /home/wwwroot/站点文件夹/xcat synclogin</span><br><span class="line">*/1 * * * * php /home/wwwroot/站点文件夹/xcat syncvpn</span><br><span class="line">0 0 * * * php /home/wwwroot/站点文件夹/xcat dailyjob</span><br><span class="line">*/1 * * * * php /home/wwwroot/站点文件夹/xcat checkjob    </span><br><span class="line">*/1 * * * * php /home/wwwroot/站点文件夹/xcat syncnas</span><br></pre></td></tr></table></figure><p>重启Crontab<br><code>/etc/init.d/cron restart</code>  </p><p>7.注意事项</p><p>检查时间是否为天朝时间</p><p>如果VPS默认是非中国时区的话, 如下命令可以用来更改为中国时区</p><p><code>cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code>  </p><p>检查防火墙是否屏蔽数据库端口</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 允许本机访问</span></span><br><span class="line">iptables -A INPUT -s 127.0.0.1/32 -p tcp -m tcp --dport 3306 -j ACCEPT</span><br><span class="line"><span class="comment"># 允许节点访问</span></span><br><span class="line">iptables -A INPUT -s 节点IP -p tcp -m tcp --dport 3306 -j ACCEPT</span><br><span class="line"><span class="comment"># 允许所有IP访问</span></span><br><span class="line">iptables -A INPUT -p tcp -m tcp --dport 3306 -j ACCEPT</span><br></pre></td></tr></table></figure><p>查看防火墙规则</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">查看已添加的iptables规则</span><br><span class="line">iptables -L -n --line-numbers</span><br><span class="line">删除已添加的iptables规则</span><br><span class="line">iptables -D INPUT line-numbers</span><br></pre></td></tr></table></figure><p>规则保存</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu</span></span><br><span class="line">iptables-save &gt; /etc/iptables.rules</span><br><span class="line"><span class="comment"># CentOS</span></span><br><span class="line">service iptables save</span><br></pre></td></tr></table></figure><h2 id="安装后端"><a href="#安装后端" class="headerlink" title="安装后端"></a>安装后端</h2><p>1.安装 libsodium</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apt-get install build-essential wget -y</span><br><span class="line">wget https://github.com/jedisct1/libsodium/releases/download/1.0.10/libsodium-1.0.10.tar.gz</span><br><span class="line">tar xf libsodium-1.0.10.tar.gz &amp;&amp; <span class="built_in">cd</span> libsodium-1.0.10</span><br><span class="line">./configure &amp;&amp; make -j2 &amp;&amp; make install</span><br><span class="line">ldconfig</span><br></pre></td></tr></table></figure><p>2.安装SSR</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apt-get install python-pip git -y</span><br><span class="line">pip install cymysql</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">git <span class="built_in">clone</span> -b manyuser https://github.com/glzjin/shadowsocks.git</span><br><span class="line"><span class="built_in">cd</span> shadowsocks</span><br><span class="line">chmod +x *.sh</span><br><span class="line"><span class="comment"># 配置程序</span></span><br><span class="line">cp apiconfig.py userapiconfig.py</span><br><span class="line">cp config.json user-config.json</span><br><span class="line">vi userapiconfig.py</span><br></pre></td></tr></table></figure><p>然后主要编辑 userapiconfig.py, 来解释下里面各项配置的意思</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Config</span></span><br><span class="line"><span class="comment">#节点ID 对应前端节点列表的ID</span></span><br><span class="line">NODE_ID = 1</span><br><span class="line"></span><br><span class="line"><span class="comment">#自动化测速，为0不测试，此处以小时为单位，要和 ss-panel 设置的小时数一致</span></span><br><span class="line">SPEEDTEST = 6</span><br><span class="line"></span><br><span class="line"><span class="comment">#云安全，自动上报与下载封禁IP，1为开启，0为关闭</span></span><br><span class="line">CLOUDSAFE = 1</span><br><span class="line"></span><br><span class="line"><span class="comment">#自动封禁SS密码和加密方式错误的 IP，1为开启，0为关闭</span></span><br><span class="line">ANTISSATTACK = 0</span><br><span class="line"></span><br><span class="line"><span class="comment">#是否接受上级下发的命令，如果你要用这个命令，请参考我之前写的东西，公钥放在目录下的 ssshell.asc</span></span><br><span class="line">AUTOEXEC = 1</span><br><span class="line"></span><br><span class="line"><span class="comment">#是否以多线程模式运行，关闭这个限速就会无效。请优先测试 1 ，开启试试，能运行没。</span></span><br><span class="line">MULTI_THREAD = 0</span><br><span class="line"></span><br><span class="line"><span class="comment">#多端口单用户设置，看重大更新说明。</span></span><br><span class="line">MU_SUFFIX = <span class="string">'zhaoj.in'</span></span><br><span class="line"><span class="comment">#多端口单用户设置，看重大更新说明。</span></span><br><span class="line">MU_REGEX = <span class="string">'%5m%id.%suffix'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#不明觉厉</span></span><br><span class="line">SERVER_PUB_ADDR = <span class="string">'127.0.0.1'</span> <span class="comment"># mujson_mgr need this to generate ssr link</span></span><br><span class="line"><span class="comment">#此处不要修改</span></span><br><span class="line">API_INTERFACE = <span class="string">'glzjinmod'</span> <span class="comment">#mudbjson, sspanelv2, sspanelv3, sspanelv3ssr, muapiv2(not support)</span></span><br><span class="line"><span class="comment">#mudb，不要管</span></span><br><span class="line">MUDB_FILE = <span class="string">'mudb.json'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Mysql 数据库连接信息</span></span><br><span class="line">MYSQL_HOST = <span class="string">'127.0.0.1'</span></span><br><span class="line">MYSQL_PORT = 3306</span><br><span class="line">MYSQL_USER = <span class="string">'ss'</span></span><br><span class="line">MYSQL_PASS = <span class="string">'ss'</span></span><br><span class="line">MYSQL_DB = <span class="string">'shadowsocks'</span></span><br><span class="line">MYSQL_UPDATE_TIME = 60</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否启用SSL连接，0为关，1为开</span></span><br><span class="line">MYSQL_SSL_ENABLE = 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端证书目录，请看 https://github.com/glzjin/shadowsocks/wiki/Mysql-SSL%E9%85%8D%E7%BD%AE</span></span><br><span class="line">MYSQL_SSL_CERT = <span class="string">'/root/shadowsocks/client-cert.pem'</span></span><br><span class="line">MYSQL_SSL_KEY = <span class="string">'/root/shadowsocks/client-key.pem'</span></span><br><span class="line">MYSQL_SSL_CA = <span class="string">'/root/shadowsocks/ca.pem'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># API，不用管</span></span><br><span class="line">API_HOST = <span class="string">'127.0.0.1'</span></span><br><span class="line">API_PORT = 80</span><br><span class="line">API_PATH = <span class="string">'/mu/v2/'</span></span><br><span class="line">API_TOKEN = <span class="string">'abcdef'</span></span><br><span class="line">API_UPDATE_TIME = 60</span><br><span class="line"></span><br><span class="line"><span class="comment"># Manager 不用管</span></span><br><span class="line">MANAGE_PASS = <span class="string">'ss233333333'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#if you want manage in other server you should set this value to global ip</span></span><br><span class="line">MANAGE_BIND_IP = <span class="string">'127.0.0.1'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#make sure this port is idle</span></span><br><span class="line">MANAGE_PORT = 23333</span><br></pre></td></tr></table></figure><p>3.运行SSR</p><p>运行的话, 有几种方式</p><ul><li>python server.py 用于调错的</li><li>./run.sh 无日志后台运行</li><li>./logrun.sh 有日志后台运行</li><li>supervisord</li></ul><p>这里说下 使用Supervisor守护进程启动ssr</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">apt-get install supervisor -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入配置</span></span><br><span class="line">vi /etc/supervisor/conf.d/ssr.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入以下内容</span></span><br><span class="line">[program:ssr]</span><br><span class="line"><span class="built_in">command</span>=python /root/shadowsocks/server.py </span><br><span class="line">autorestart=<span class="literal">true</span></span><br><span class="line">autostart=<span class="literal">true</span></span><br><span class="line">user=root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启Supervisor服务。</span></span><br><span class="line">/etc/init.d/supervisor restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启 ssr</span></span><br><span class="line">supervisorctl restart ssr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看Supervisor服务运行状态。</span></span><br><span class="line">supervisorctl status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果遇到问题，可以检查日志：</span></span><br><span class="line">supervisorctl tail -f ssr stderr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果使用supervisor进程守护，需要修改文件vi /etc/default/supervisor，添加一行：</span></span><br><span class="line"><span class="built_in">ulimit</span> -n 1024000</span><br></pre></td></tr></table></figure><h2 id="强化安全"><a href="#强化安全" class="headerlink" title="强化安全"></a>强化安全</h2><p>1.将网站支持 SSL 强化安全</p><p>需要提前准备好 SSL 证书文件, 没有的话可以使用<a href="https://certbot.eff.org/" target="_blank" rel="noopener">Let’s Encrypt</a> 搞个免费SSL证书, 接着配置 nginx</p><p>编辑 <code>/usr/local/nginx/conf/vhost/域名.conf</code></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">server</span><br><span class="line">&#123;</span><br><span class="line">listen 80;</span><br><span class="line"><span class="comment">#listen [::]:80; #有ipv6的开</span></span><br><span class="line">server_name 域名;</span><br><span class="line">rewrite ^(.*) https://<span class="variable">$server_name</span><span class="variable">$1</span> permanent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server</span><br><span class="line">&#123;</span><br><span class="line">listen 443 ssl;</span><br><span class="line"><span class="comment">#listen [::]:443 ssl; #有ipv6的开</span></span><br><span class="line">ssl_certificate /etc/letsencrypt/live/你的域名/fullchain.pem;</span><br><span class="line">ssl_certificate_key /etc/letsencrypt/live/你的域名/privkey.pem;</span><br><span class="line">ssl_trusted_certificate /etc/letsencrypt/live/你的域名/chain.pem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.禁止 http 的访问请求</p><p>由于 http 仍然可以访问, 所以我们需要将 http 的请求手动转移到 https, 由于 SSpanel 本身使用了重定向, 那么在不使用其他重定向的情况下, 最简单的方法就是用 html 网页的<meta> 参数</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"refresh"</span> <span class="attr">content</span>=<span class="string">"0;url=https://域名"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.转移 phpMyAdmin 目录</p><ul><li><p>转移目录</p><p>LNMP安装完毕以后默认的会在IP地址网站根目录生成一个 phpMyAdmin 的目录, 但是正是因为这个原因, 暴露了该目录, 我一般都会直接把这个文件夹转移到新的网站目录下, 比如转移到其他二级域名下的某个目录, 只需要在LNMP中新建一个二级域名而已, 然后把 phpMyAdmin 这个目录再转移到这个二级域名的网站目录下</p></li><li><p>限制IP</p><p>在 phpMyAdmin 的目录下新增 <code>.htaccess</code> 写入以下</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">allow from 59.168.1.0/24</span><br><span class="line">allow from 59.168.2.50</span><br><span class="line">deny from all</span><br></pre></td></tr></table></figure><p>除了 59.168.1.1 至 59.168.1.254 的区间IP 与 59.168.2.50 可以进入后台其于IP都封锁, 就算对方知道路径, IP不允许也是无法进入</p></li></ul><hr><p>参考</p><p><a href="https://github.com/esdeathlove/ss-panel-v3-mod/wiki/%E5%AE%89%E8%A3%85%E8%AF%B4%E6%98%8E" target="_blank" rel="noopener"><strong>ss-panel-v3-mod</strong>安装说明</a> </p><p><a href="https://github.com/esdeathlove/shadowsocks/wiki/%E8%AF%B4%E6%98%8E%E4%BB%A5%E5%8F%8A%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">说明以及安装方法</a></p><p><a href="https://www.vpser.net/security/linux-iptables.html" target="_blank" rel="noopener">Linux上iptables防火墙的基本应用教程</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前端使用赵大的魔改版 &lt;a href=&quot;https://github.com/esdeathlove/ss-panel-v3-mod&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/esdeathlove/ss-pane
      
    
    </summary>
    
      <category term="VPS" scheme="https://imeiji.github.io/categories/VPS/"/>
    
    
  </entry>
  
  <entry>
    <title>自动备份 VPS 数据到 email 和 Dropbox</title>
    <link href="https://imeiji.github.io/2017/01/08/%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD%20VPS%20%E6%95%B0%E6%8D%AE%E5%88%B0%20email%20%E5%92%8C%20Dropbox/"/>
    <id>https://imeiji.github.io/2017/01/08/自动备份 VPS 数据到 email 和 Dropbox/</id>
    <published>2017-01-07T16:00:00.000Z</published>
    <updated>2017-12-18T07:53:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dropbox-准备"><a href="#Dropbox-准备" class="headerlink" title="Dropbox 准备"></a>Dropbox 准备</h2><ol><li><p>登录 Dropbox，打开 <a href="https://www.dropbox.com/developers/apps" target="_blank" rel="noopener">Apps</a> 页面，点击 Create App 按钮，创建一个 App</p><p><img src="https://i.loli.net/2017/12/18/5a376c923ca03.png" alt="dropbox-app.png"></p></li><li><p>获取 Access token，点击 Generate 获取备用。</p><p><img src="https://i.loli.net/2017/12/18/5a376c923c928.png" alt="dropbox-app-token.png"></p></li><li><p>接着 SSH 登录 VPS 获取最新的 <a href="https://github.com/andreafabrizi/Dropbox-Uploader" target="_blank" rel="noopener">Dropbox Uploader</a> 脚本</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/andreafabrizi/Dropbox-Uploader.git</span><br><span class="line">chmod +x dropbox_uploader.sh</span><br><span class="line">./dropbox_uploader.sh info</span><br></pre></td></tr></table></figure><p>根据提示输入 Access token，Dropbox 绑定成功。再次运行 <code>./dropbox_uploader.sh info</code> 可以看到绑定的 Dropbox 账户信息。</p></li></ol><h2 id="Email-准备"><a href="#Email-准备" class="headerlink" title="Email 准备"></a>Email 准备</h2><ol><li><p>安装Email组件，以保证数据库文件可以发送到您的邮箱</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install sendmail mutt</span><br></pre></td></tr></table></figure></li></ol><h2 id="创建备份脚本"><a href="#创建备份脚本" class="headerlink" title="创建备份脚本"></a>创建备份脚本</h2><ol><li><p>请确保有以下目录，如果没有请执行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p /root/backups/sql</span><br></pre></td></tr></table></figure></li><li><p>脚本开始<br><code>vi backup.sh</code>  </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">你要修改的地方从这里开始</span></span><br><span class="line">MYSQL_USER=#数据库用户</span><br><span class="line">MYSQL_PASS=#数据库密码</span><br><span class="line">MAIL_TO=#发送邮箱</span><br><span class="line">WEB_DATA=/home/wwwroot#本地网站路径</span><br><span class="line">DOMAIN=#域名</span><br><span class="line"><span class="meta">#</span><span class="bash">你要修改的地方从这里结束</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">定义备份的名字</span></span><br><span class="line">DBName=Data_$(date +"%Y%m%d%H").tar.gz</span><br><span class="line">WebName=Web_$(date +%Y%m%d).tar.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">定义旧数据名字 这里删除60天前的数据</span></span><br><span class="line">OldDBName=Data_$(date -d -60day +"%Y%m%d").tar.gz</span><br><span class="line">OldWebName=Web_$(date -d -60day +"%Y%m%d").tar.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#备份目录</span></span></span><br><span class="line">cd /root/backups/sql</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">导出数据库,一个数据库一个压缩文件</span></span><br><span class="line">for db in `/usr/bin/mysql -u$MYSQL_USER -p$MYSQL_PASS -B -N -e 'SHOW DATABASES' | xargs`; do</span><br><span class="line">    (/usr/bin/mysqldump -u$MYSQL_USER -p$MYSQL_PASS $&#123;db&#125; | gzip -9 - &gt; $&#123;db&#125;.sql.gz)</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">压缩数据库文件为一个文件</span></span><br><span class="line">tar zcf $DBName *.sql.gz</span><br><span class="line">rm -rf *.sql.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">将文件上传到 Dropbox</span></span><br><span class="line">/root/dropbox_uploader.sh upload "$DBName" "/"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">删除旧的数据</span></span><br><span class="line">rm -rf OldDBName OldWebName</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">开始删除远程旧的文件</span></span><br><span class="line">/root/dropbox_uploader.sh delete $OldDBName</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">以下内容需要根据实际环境修改</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">发送数据库到Email</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">echo</span> <span class="string">"主题:数据库备份"</span> | mutt -e <span class="string">"my_hdr from:<span class="variable">$DOMAIN</span>&lt;root@<span class="variable">$DOMAIN</span>&gt;"</span> -a /root/backups/sql/<span class="variable">$DBName</span> -s <span class="string">"内容:数据库备份"</span> -- <span class="variable">$MAIL_TO</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">压缩网站数据</span></span><br><span class="line"><span class="meta">#</span><span class="bash">tar zcf /root/backups/<span class="variable">$WebName</span> <span class="variable">$WEB_DATA</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">将文件上传到 Dropbox</span></span><br><span class="line"><span class="meta">#</span><span class="bash">/root/dropbox_uploader.sh upload <span class="string">"<span class="variable">$WebName</span>"</span> <span class="string">"/"</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">/root/dropbox_uploader.sh delete <span class="variable">$OldWebName</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">发送网站数据到Email</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">echo</span> <span class="string">"主题:网站备份"</span> | mutt -e <span class="string">"my_hdr from:<span class="variable">$DOMAIN</span>&lt;root@<span class="variable">$DOMAIN</span>&gt;"</span> -a /root/backups/<span class="variable">$DBName</span> /root/backups/<span class="variable">$DBName</span> -s <span class="string">"内容:网站备份"</span> -- <span class="variable">$MAIL_TO</span></span></span><br></pre></td></tr></table></figure></li><li><p>脚本修改完，上传至 /root/ 目录下，并赋予执行权限<br><code>chmod +x /root/backup.sh</code> </p></li><li><p>准备添加定时设置，每2小时备份数据</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">0 */2 * * * bash /root/backupsql.sh</span><br></pre></td></tr></table></figure><p>重启Crontab<br><code>/etc/init.d/cron restart</code>  </p></li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://www.laozuo.org/4560.html" target="_blank" rel="noopener">http://www.laozuo.org/4560.html</a></p><p><a href="https://cyhour.com/549/" target="_blank" rel="noopener">https://cyhour.com/549/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Dropbox-准备&quot;&gt;&lt;a href=&quot;#Dropbox-准备&quot; class=&quot;headerlink&quot; title=&quot;Dropbox 准备&quot;&gt;&lt;/a&gt;Dropbox 准备&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;登录 Dropbox，打开 &lt;a href=&quot;https:
      
    
    </summary>
    
      <category term="VPS" scheme="https://imeiji.github.io/categories/VPS/"/>
    
    
  </entry>
  
  <entry>
    <title>今日头条Api分析</title>
    <link href="https://imeiji.github.io/2017/01/05/%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1Api%E5%88%86%E6%9E%90/"/>
    <id>https://imeiji.github.io/2017/01/05/今日头条Api分析/</id>
    <published>2017-01-04T16:00:00.000Z</published>
    <updated>2017-01-09T10:17:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="获取新闻标题"><a href="#获取新闻标题" class="headerlink" title="获取新闻标题"></a>获取新闻标题</h2><h3 id="普通用法"><a href="#普通用法" class="headerlink" title="普通用法"></a>普通用法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://toutiao.com/api/article/recent/?source=2&amp;category=类型&amp;as=A1D5D87595C3287</span><br></pre></td></tr></table></figure><p>例如获取热点新闻<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://toutiao.com/api/article/recent/?source=2&amp;category=news_hot&amp;as=A1D5D87595C3287</span><br></pre></td></tr></table></figure></p><p>其中 <code>category</code> 指类型 <code>as</code> 值随机生成 感兴趣的自己去抓取<br>得到的信息为<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"has_more"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"message"</span>: <span class="string">"success"</span>,</span><br><span class="line">  <span class="attr">"data"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"media_name"</span>: <span class="string">"侠客岛"</span>,</span><br><span class="line">      <span class="attr">"abstract"</span>: <span class="string">"今天又有大新闻啦。据美国多家媒体的消息， 12月15日，中国海军在南海趁美国一艘无人水下潜航器（UUV）故障之机，抢在美军打捞人员之前将其捞走。"</span>,</span><br><span class="line">      <span class="attr">"impression_count"</span>: <span class="number">7433280</span>,</span><br><span class="line">      <span class="attr">"image_list"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"url"</span>: <span class="string">"http://p1.pstatp.com/list/134b00048dd993d77429"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"url"</span>: <span class="string">"http://p3.pstatp.com/list/1349000017bb1b3c7366"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"url"</span>: <span class="string">"http://p3.pstatp.com/list/134c0003788b24d74346"</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"media_avatar_url"</span>: <span class="string">"http://p3.pstatp.com/large/1731/4112623237"</span>,</span><br><span class="line">      <span class="attr">"external_visit_count"</span>: <span class="number">14999</span>,</span><br><span class="line">      <span class="attr">"article_type"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"more_mode"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">"tag"</span>: <span class="string">"news_military"</span>,</span><br><span class="line">      <span class="attr">"is_favorite"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"has_m3u8_video"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"keywords"</span>: <span class="string">"南海诸岛,南海,美国,专属经济区,公约,国际法"</span>,</span><br><span class="line">      <span class="attr">"has_mp4_video"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"favorite_count"</span>: <span class="number">1059</span>,</span><br><span class="line">      <span class="attr">"display_url"</span>: <span class="string">"http://toutiao.com/group/6365056560833659137/"</span>,</span><br><span class="line">      <span class="attr">"article_sub_type"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"bury_count"</span>: <span class="number">9</span>,</span><br><span class="line">      <span class="attr">"title"</span>: <span class="string">"美国想在南海下黑手，结果被中国抓个正着！这下送礼了"</span>,</span><br><span class="line">      <span class="attr">"datetime"</span>: <span class="string">"2016-12-17 22:27"</span>,</span><br><span class="line">      <span class="attr">"has_video"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">"share_url"</span>: <span class="string">"http://toutiao.com/group/6365056560833659137/?iid=41507200127&amp;app=news_article"</span>,</span><br><span class="line">      <span class="attr">"id"</span>: <span class="number">6365056560833659000</span>,</span><br><span class="line">      <span class="attr">"source"</span>: <span class="string">"侠客岛"</span>,</span><br><span class="line">      <span class="attr">"comment_count"</span>: <span class="number">17</span>,</span><br><span class="line">      <span class="attr">"article_url"</span>: <span class="string">"http://toutiao.com/group/6365056560833659137/"</span>,</span><br><span class="line">      <span class="attr">"create_time"</span>: <span class="number">1481980801</span>,</span><br><span class="line">      <span class="attr">"recommend"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"tips"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"aggr_type"</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">"item_source_url"</span>: <span class="string">"/item/6365059050404577794/"</span>,</span><br><span class="line">      <span class="attr">"media_url"</span>: <span class="string">"http://toutiao.com/m3741758306/"</span>,</span><br><span class="line">      <span class="attr">"display_time"</span>: <span class="number">1481980795</span>,</span><br><span class="line">      <span class="attr">"publish_time"</span>: <span class="number">1481980795</span>,</span><br><span class="line">      <span class="attr">"go_detail_count"</span>: <span class="number">504591</span>,</span><br><span class="line">      <span class="attr">"group_flags"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"middle_mode"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">"display_title"</span>: <span class="string">" "</span>,</span><br><span class="line">      <span class="attr">"gallary_image_count"</span>: <span class="number">3</span>,</span><br><span class="line">      <span class="attr">"item_seo_url"</span>: <span class="string">"/item/6365059050404577794/"</span>,</span><br><span class="line">      <span class="attr">"tag_id"</span>: <span class="number">6365056560833659000</span>,</span><br><span class="line">      <span class="attr">"source_url"</span>: <span class="string">"/group/6365056560833659137/"</span>,</span><br><span class="line">      <span class="attr">"article_genre"</span>: <span class="string">"article"</span>,</span><br><span class="line">      <span class="attr">"large_mode"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">"item_id"</span>: <span class="number">6365059050404578000</span>,</span><br><span class="line">      <span class="attr">"natant_level"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"is_digg"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"seo_url"</span>: <span class="string">"/group/6365056560833659137/"</span>,</span><br><span class="line">      <span class="attr">"repin_count"</span>: <span class="number">1059</span>,</span><br><span class="line">      <span class="attr">"url"</span>: <span class="string">"http://toutiao.com/group/6365056560833659137/"</span>,</span><br><span class="line">      <span class="attr">"level"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"digg_count"</span>: <span class="number">55</span>,</span><br><span class="line">      <span class="attr">"behot_time"</span>: <span class="number">1481984828</span>,</span><br><span class="line">      <span class="attr">"hot"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"preload_web"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"comments_count"</span>: <span class="number">17</span>,</span><br><span class="line">      <span class="attr">"has_image"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">"is_bury"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"group_id"</span>: <span class="number">6365056560833659000</span>,</span><br><span class="line">      <span class="attr">"middle_image"</span>: &#123;</span><br><span class="line">        <span class="attr">"url"</span>: <span class="string">"http://p1.pstatp.com/list/134b00048dd993d77429"</span>,</span><br><span class="line">        <span class="attr">"width"</span>: <span class="number">415</span>,</span><br><span class="line">        <span class="attr">"url_list"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"url"</span>: <span class="string">"http://p1.pstatp.com/list/134b00048dd993d77429"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"url"</span>: <span class="string">"http://pb3.pstatp.com/list/134b00048dd993d77429"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"url"</span>: <span class="string">"http://pb3.pstatp.com/list/134b00048dd993d77429"</span></span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"uri"</span>: <span class="string">"list/134b00048dd993d77429"</span>,</span><br><span class="line">        <span class="attr">"height"</span>: <span class="number">536</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"next"</span>: &#123;</span><br><span class="line">    <span class="attr">"max_behot_time"</span>: <span class="number">1481984828</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们要获取的新闻都在 <code>data</code> 数组里, 这里我只罗列了部分  </p><p>以下给出部分类型 仅供参考<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;推荐&apos;: &apos;__all__&apos;,</span><br><span class="line">&apos;热点&apos;: &apos;news_hot&apos;,</span><br><span class="line">&apos;社会&apos;: &apos;news_society&apos;,</span><br><span class="line">&apos;娱乐&apos;: &apos;news_entertainment&apos;,</span><br><span class="line">&apos;科技&apos;: &apos;news_tech&apos;,</span><br><span class="line">&apos;军事&apos;: &apos;news_military&apos;,</span><br><span class="line">&apos;体育&apos;: &apos;news_sports&apos;</span><br><span class="line">&apos;汽车&apos;: &apos;news_car&apos;,</span><br><span class="line">&apos;财经&apos;: &apos;news_finance&apos;,</span><br><span class="line">&apos;国际&apos;: &apos;news_world&apos;,</span><br><span class="line">&apos;时尚&apos;: &apos;news_fashion&apos;,</span><br><span class="line">&apos;旅游&apos;: &apos;news_travel&apos;,</span><br><span class="line">&apos;探索&apos;: &apos;news_discovery&apos;,</span><br><span class="line">&apos;育儿&apos;: &apos;news_baby&apos;,</span><br><span class="line">&apos;养生&apos;: &apos;news_regimen&apos;,</span><br><span class="line">&apos;故事&apos;: &apos;news_story&apos;,</span><br><span class="line">&apos;美文&apos;: &apos;news_essay&apos;,</span><br><span class="line">&apos;游戏&apos;: &apos;news_game&apos;,</span><br><span class="line">&apos;历史&apos;: &apos;news_history&apos;,</span><br><span class="line">&apos;美食&apos;: &apos;news_food&apos;,</span><br></pre></td></tr></table></figure></p><h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://toutiao.com/api/article/recent/?source=2&amp;category=news_hot&amp;as=A105177907376A5&amp;cp=5797C7865AD54E1&amp;count=20&amp;offset=0&amp;_=1481986412</span><br></pre></td></tr></table></figure><ul><li><code>category</code> 指类型  </li><li><code>as</code> 随机生成  </li><li><code>cp</code> 随机生成  </li><li><code>count</code> 获取文章数量  </li><li><code>offset</code> 偏移量  </li><li><code>_=</code> 指 <code>max_behot_time</code> </li></ul><p>补充一个Api, 从手机版获取到的<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://m.toutiao.com/list/?tag=__all__&amp;ac=wap&amp;count=20&amp;format=json_raw&amp;as=A17538D54D106FF&amp;cp=585DF0A65F0F1E1&amp;min_behot_time=1482491618</span><br></pre></td></tr></table></figure></p><h2 id="获取新闻"><a href="#获取新闻" class="headerlink" title="获取新闻"></a>获取新闻</h2><h3 id="获取新闻内容"><a href="#获取新闻内容" class="headerlink" title="获取新闻内容"></a>获取新闻内容</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://m.toutiao.com/item_seo_url值/info/</span><br></pre></td></tr></table></figure><p>例如获取 <a href="http://www.toutiao.com/i6364969235889783298/" target="_blank" rel="noopener">美国无人潜航器被中国抓获引爆网络</a> 这篇新闻的内容<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://m.toutiao.com/i6364969235889783298/info/</span><br></pre></td></tr></table></figure></p><p>其中 <code>i6364969235889783298</code> 值为 <code>item_seo_url</code> 可从上面的Api获取<br>得到的信息为<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"_ck"</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">        <span class="attr">"detail_source"</span>: <span class="string">"诤闻军事"</span>,</span><br><span class="line">        <span class="attr">"media_user"</span>: &#123;</span><br><span class="line">            <span class="attr">"avatar_url"</span>: <span class="string">"http://p2.pstatp.com/large/11543/4356023632"</span>,</span><br><span class="line">            <span class="attr">"id"</span>: <span class="number">5866716857</span>,</span><br><span class="line">            <span class="attr">"screen_name"</span>: <span class="string">"诤闻军事"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"publish_time"</span>: <span class="number">1481959884</span>,</span><br><span class="line">        <span class="attr">"title"</span>: <span class="string">"美国无人潜航器被中国抓获引爆网络，一中国网友外媒舌战群儒"</span>,</span><br><span class="line">        <span class="attr">"url"</span>: <span class="string">"http://toutiao.com/group/6364965628189327618/"</span>,</span><br><span class="line">        <span class="attr">"is_original"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"is_pgc_article"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"content"</span>: <span class="string">"&lt;div&gt;&lt;p&gt;据外媒报道，12月15日中国海军一艘南救510打捞救生船，在靠近菲律宾的海域持续跟踪美军海洋测量船鲍迪奇号之后，当着美军的面，将其放出的两艘水下无人航行器之一打捞带走。目前美方已经向中国提起抗议，要求归还无人航行器。&lt;strong&gt;据CNN报道，当时美军鲍迪奇号立刻使用无线电呼叫中国舰艇，但是却没有应答，过了很久之后中国军舰突然回应：有什么事要帮忙吗？我们正在附近巡逻。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=\"http://p3.pstatp.com/large/12db0007c12ad2732220\" img_width=\"938\" img_height=\"732\" alt=\"美国无人潜航器被中国抓获引爆网络，一中国网友外媒舌战群儒\" onerror=\"javascript:errorimg.call(this);\"&gt;&lt;/p&gt;&lt;p class=\"pgc-img-caption\"&gt;鲍迪奇号&lt;/p&gt;&lt;p&gt;类似《华尔街日报》、CNN等媒体，对这一事件都冠以“Breaking News”（重大新闻）的标题，迅速进行了报道，因此也引发了国外网友的讨论。特别有趣的是，在《华尔街日报》网站上，一位网友“&lt;strong&gt;adam w”却独自在外媒网站和拥护美国的外国网友进行了一场激烈的辩论&lt;/strong&gt;。从名字和用语来开，这位网友很可能来自中国。&lt;/p&gt;&lt;p&gt;例如网名“Bryan Jaeck”用户认为，如果中国不归还无人航行器，过一段时间中国就能山寨所有的美国技术来建造自己的无人航行器。美国舰长应该把手放到扳机上发出警告：要么归还要么就去死！“adam w”则回答说：一名间谍被抓获了，现在暴徒说了：如果不交出间谍他们就开战！&lt;/p&gt;&lt;p&gt;网名“Christopher Holland”表示，中国的法律认为：我的是我的，你的也是我的。这就是中国人的想法。偷窃美国政府财产对于中国人来说小菜一碟。&lt;strong&gt;“adam w”则回答说：美国拥有世界上最庞大的间谍网络，不断从中国、俄罗斯窃取机密，甚至连德国、法国这样的盟友都不放过&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;img src=\"http://p3.pstatp.com/large/134d0000fb0668a5844f\" img_width=\"634\" img_height=\"439\" alt=\"美国无人潜航器被中国抓获引爆网络，一中国网友外媒舌战群儒\" onerror=\"javascript:errorimg.call(this);\"&gt;&lt;/p&gt;&lt;p class=\"pgc-img-caption\"&gt;无人潜航器&lt;/p&gt;&lt;p&gt;网名“Timothy corrigan”称：下次中国如果还要这么干，美国就应该把他们都赶出这片水域。应该让附近的潜艇发射战斧导弹到中国的岛礁上去“参观”。中国已经看穿了奥巴马是一个弱者，特朗普应该给中国一个教训。“adam w”回答说：&lt;strong&gt;美国人当着中国舰艇的面释放间谍无人器。中国抓获了它，美国却要以此为借口发动战争。美国暴徒终于显露了自己的本色&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;“Timothy corrigan”回应说：国际海域意味着你不能碰其他人的东西。中国的所作所为是盗窃，应该被严厉惩罚。&lt;strong&gt;美国应该击沉中国舰艇，派遣两个航母编队到南海，如果不够就派三个&lt;/strong&gt;。“adam w”则回答；&lt;strong&gt;真的吗？美国就没有在国际海域抓获其他人的舰艇吗（应该是意指银河号事件）？&lt;/strong&gt;在你谴责其他人搞间谍的时候，其他国家的所有计算机又在被谁监控？美国CIA一直在干这事，你这个伪君子。&lt;/p&gt;&lt;p&gt;网名“michael de martine”认为。为什么美国海军会派遣一艘小型没有武装的测量船到“敌军海域”？这不是成心让中国这个坏人来来搞事吗？“adam w”回应说：派没有武装的测量船到“敌军海域”，还来到中国舰艇的旁边。这件事美国才是事实上的挑衅者。&lt;/p&gt;&lt;p&gt;&lt;img src=\"http://p1.pstatp.com/large/134c0002f256279ce44d\" img_width=\"634\" img_height=\"444\" alt=\"美国无人潜航器被中国抓获引爆网络，一中国网友外媒舌战群儒\" onerror=\"javascript:errorimg.call(this);\"&gt;&lt;/p&gt;&lt;p class=\"pgc-img-caption\"&gt;特朗普的某些举动激怒了中国&lt;br&gt;&lt;/p&gt;&lt;p&gt;网友“WILLIAM A TAYLOR”说，这并不是“敌军海域”而是国际公海。而中国声称对这片国际海域拥有主权。美国有义务保持这一海域的航行自由，但中国去想把其他人排除在外。权利如果没有武力维护就没有任何意义，这就是为什么那么多人要带枪。“adam w”则问道：义务？到底是什么义务？菲律宾已经告诉美国离开他们的海域，不想当美国人对抗中国的马前卒。所以现在是美国打算单枪匹马挑衅中国。到底谁才是恶人？&lt;/p&gt;&lt;p&gt;除了那些为美国鼓噪的人之外，其实还是有清醒者。一位Gioklie Tanthe说到：&lt;strong&gt;美国必须懂得尊重其他国家，才能够得到其他国家的尊重。&lt;/strong&gt;&lt;/p&gt;&lt;/div&gt;&lt;p class=\"footnote\"&gt;本文为头条号作者原创，未经授权，不得转载。&lt;/p&gt;"</span>,</span><br><span class="line">        <span class="attr">"source"</span>: <span class="string">"诤闻军事"</span>,</span><br><span class="line">        <span class="attr">"video_play_count"</span>: <span class="number">6</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"success"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="获取新闻评论"><a href="#获取新闻评论" class="headerlink" title="获取新闻评论"></a>获取新闻评论</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://www.toutiao.com/api/comment/list/?group_id=头条号&amp;item_id=文章号&amp;offset=偏移量&amp;count=数量</span><br></pre></td></tr></table></figure><p>例如获取 <a href="http://www.toutiao.com/i6364969235889783298/" target="_blank" rel="noopener">美国无人潜航器被中国抓获引爆网络</a> 这篇新闻的评论</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://www.toutiao.com/api/comment/list/?group_id=6364965628189327618&amp;item_id=6364969235889783298&amp;offset=0&amp;count=10</span><br></pre></td></tr></table></figure><p>其中 <code>group_id</code> 和 <code>item_id</code> 可从上面的Api获取<br>得到的信息为<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"message"</span>: <span class="string">"success"</span>,</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">        <span class="attr">"has_more"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"total"</span>: <span class="number">2410</span>,</span><br><span class="line">        <span class="attr">"comments"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"text"</span>: <span class="string">"中国是一个负责任的大国，只要美方提供证据证明这东西是美国的，中国可以归还。流程是:美方提供生产厂家原始记录、生产编号，该型号潜航器的设计图纸，以及该次海洋调查任务的详细说明、行动计划等等。中方需要半年左右的调查就可以了。"</span>,</span><br><span class="line">                <span class="attr">"digg_count"</span>: <span class="number">4351</span>,</span><br><span class="line">                <span class="attr">"reply_data"</span>: &#123;</span><br><span class="line">                    <span class="attr">"reply_list"</span>: []</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">"reply_count"</span>: <span class="number">176</span>,</span><br><span class="line">                <span class="attr">"create_time"</span>: <span class="number">1481964505</span>,</span><br><span class="line">                <span class="attr">"user"</span>: &#123;</span><br><span class="line">                    <span class="attr">"avatar_url"</span>: <span class="string">"http://p0.pstatp.com/origin/3793/3131589739"</span>,</span><br><span class="line">                    <span class="attr">"user_id"</span>: <span class="number">6180186929</span>,</span><br><span class="line">                    <span class="attr">"name"</span>: <span class="string">"hanxinping1969"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">"dongtai_id"</span>: <span class="number">7105200091</span>,</span><br><span class="line">                <span class="attr">"user_digg"</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">"id"</span>: <span class="number">52960355361</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="获取头条号文章"><a href="#获取头条号文章" class="headerlink" title="获取头条号文章"></a>获取头条号文章</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://www.toutiao.com/pgc/ma/?media_id=头条号&amp;page_type=1&amp;count=10&amp;version=2&amp;platform=pc&amp;as=A1C548D5FDB17E6&amp;cp=585DB1871ED64E1&amp;max_behot_time=偏移量</span><br></pre></td></tr></table></figure><p>例如获取 <a href="http://www.toutiao.com/m3232597584/" target="_blank" rel="noopener">国际在线</a> 的文章<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://www.toutiao.com/pgc/ma/?media_id=3232597584&amp;page_type=1&amp;max_behot_time=0&amp;count=10&amp;version=2&amp;platform=pc&amp;as=A1C548D5FDB17E6&amp;cp=585DB1871ED64E1</span><br></pre></td></tr></table></figure></p><p>其中 <code>media_id</code> 可从上面的Api获取<br>得到的信息为<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"media_id"</span>: <span class="number">3232597584</span>,</span><br><span class="line">    <span class="attr">"has_more"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"next"</span>: &#123;</span><br><span class="line">        <span class="attr">"max_behot_time"</span>: <span class="number">1482474718</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"page_type"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"message"</span>: <span class="string">"success"</span>,</span><br><span class="line">    <span class="attr">"data"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"play_effective_count"</span>: <span class="string">"0"</span>,</span><br><span class="line">            <span class="attr">"gallery_pic_count"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">"go_detail_count"</span>: <span class="string">"62"</span>,</span><br><span class="line">            <span class="attr">"title"</span>: <span class="string">"【老外谈】巴基斯坦专家：中央经济工作会议为2017年中国发展奠定基础"</span>,</span><br><span class="line">            <span class="attr">"image_list"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"url"</span>: <span class="string">"http://p2.pstatp.com/list/13c5000a0fe801679b19"</span>,</span><br><span class="line">                    <span class="attr">"pc_url"</span>: <span class="string">"http://p2.pstatp.com/list/194x108/13c5000a0fe801679b19"</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"abstract"</span>: <span class="string">"莎菲·哈里（巴基斯坦）一年一度的中央经济工作会议日前在北京召开。与会的领导人们总结中国在2016年的经济工作，并着眼于2017年的经济战略。"</span>,</span><br><span class="line">            <span class="attr">"show_play_effective_count"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">"middle_mode"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">"has_video"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"source_url"</span>: <span class="string">"http://www.toutiao.com/item/6367207970920464898/"</span>,</span><br><span class="line">            <span class="attr">"datetime"</span>: <span class="string">"2016-12-23 16:06"</span>,</span><br><span class="line">            <span class="attr">"live_status"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="attr">"more_mode"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"comments_count"</span>: <span class="string">"0"</span>,</span><br><span class="line">            <span class="attr">"video_duration_str"</span>: <span class="string">"00:00"</span>,</span><br><span class="line">            <span class="attr">"has_gallery"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"pc_image_url"</span>: <span class="string">"http://p2.pstatp.com/list/126x82/13c5000a0fe801679b19"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="获取段子"><a href="#获取段子" class="headerlink" title="获取段子"></a>获取段子</h2><h2 id="获取段子内容"><a href="#获取段子内容" class="headerlink" title="获取段子内容"></a>获取段子内容</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://www.toutiao.com/api/article/feed/?category=essay_joke&amp;as=A115C8457F69B85&amp;cp=585F294B8845EE1</span><br></pre></td></tr></table></figure><p>得到的信息为<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"has_more"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"message"</span>: <span class="string">"success"</span>,</span><br><span class="line">  <span class="attr">"data"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"group"</span>: &#123;</span><br><span class="line">        <span class="attr">"text"</span>: <span class="string">"地铁上，一个怂孩子在那一直打他妈妈的手。然后他妈妈把手放在了小孩儿的脸上，怂孩子又使劲要打过去，结果他妈妈突然把手给撤开了。就听啪的一声然后就没有然后了。"</span>,</span><br><span class="line">        <span class="attr">"create_time"</span>: <span class="number">1483004786</span>,</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">53368972910</span>,</span><br><span class="line">        <span class="attr">"favorite_count"</span>: <span class="number">78</span>,</span><br><span class="line">        <span class="attr">"go_detail_count"</span>: <span class="number">43711</span>,</span><br><span class="line">        <span class="attr">"user_favorite"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"share_type"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"is_can_share"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"comment_count"</span>: <span class="number">81</span>,</span><br><span class="line">        <span class="attr">"share_url"</span>: <span class="string">"http://m.neihanshequ.com/share/group/53368972910/?iid=0&amp;amp;app=joke_essay"</span>,</span><br><span class="line">        <span class="attr">"label"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"content"</span>: <span class="string">"地铁上，一个怂孩子在那一直打他妈妈的手。然后他妈妈把手放在了小孩儿的脸上，怂孩子又使劲要打过去，结果他妈妈突然把手给撤开了。就听啪的一声然后就没有然后了。"</span>,</span><br><span class="line">        <span class="attr">"category_type"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"id_str"</span>: <span class="string">"53368972910"</span>,</span><br><span class="line">        <span class="attr">"media_type"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"share_count"</span>: <span class="number">119</span>,</span><br><span class="line">        <span class="attr">"type"</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">"status"</span>: <span class="number">112</span>,</span><br><span class="line">        <span class="attr">"has_comments"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"user_bury"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"status_desc"</span>: <span class="string">"热门投稿"</span>,</span><br><span class="line">        <span class="attr">"user"</span>: &#123;</span><br><span class="line">          <span class="attr">"is_following"</span>: <span class="literal">false</span>,</span><br><span class="line">          <span class="attr">"avatar_url"</span>: <span class="string">"http://p3.pstatp.com/thumb/1353000081efff334e3e"</span>,</span><br><span class="line">          <span class="attr">"user_id"</span>: <span class="number">6088312852</span>,</span><br><span class="line">          <span class="attr">"name"</span>: <span class="string">"蓝筱蝶"</span>,</span><br><span class="line">          <span class="attr">"user_verified"</span>: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"user_digg"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"online_time"</span>: <span class="number">1483004786</span>,</span><br><span class="line">        <span class="attr">"category_name"</span>: <span class="string">"内涵段子"</span>,</span><br><span class="line">        <span class="attr">"category_visible"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"bury_count"</span>: <span class="number">248</span>,</span><br><span class="line">        <span class="attr">"is_anonymous"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"repin_count"</span>: <span class="number">78</span>,</span><br><span class="line">        <span class="attr">"digg_count"</span>: <span class="number">7537</span>,</span><br><span class="line">        <span class="attr">"has_hot_comments"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"user_repin"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"activity"</span>: &#123;&#125;,</span><br><span class="line">        <span class="attr">"group_id"</span>: <span class="number">53368972910</span>,</span><br><span class="line">        <span class="attr">"category_id"</span>: <span class="number">1</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"comments"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"status"</span>: <span class="number">5</span>,</span><br><span class="line">          <span class="attr">"user_profile_url"</span>: <span class="string">""</span>,</span><br><span class="line">          <span class="attr">"is_digg"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"user_id"</span>: <span class="number">3126306787</span>,</span><br><span class="line">          <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">          <span class="attr">"bury_count"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"avatar_url"</span>: <span class="string">"http://p3.pstatp.com/thumb/1354000a27104141c471"</span>,</span><br><span class="line">          <span class="attr">"text"</span>: <span class="string">"这个故事，告诉了我们，不要坐地铁"</span>,</span><br><span class="line">          <span class="attr">"comment_id"</span>: <span class="number">53372167364</span>,</span><br><span class="line">          <span class="attr">"user_verified"</span>: <span class="literal">false</span>,</span><br><span class="line">          <span class="attr">"digg_count"</span>: <span class="number">11343</span>,</span><br><span class="line">          <span class="attr">"user_profile_image_url"</span>: <span class="string">"http://p3.pstatp.com/thumb/1354000a27104141c471"</span>,</span><br><span class="line">          <span class="attr">"platform_id"</span>: <span class="string">"feifei"</span>,</span><br><span class="line">          <span class="attr">"platform"</span>: <span class="string">"feifei"</span>,</span><br><span class="line">          <span class="attr">"create_time"</span>: <span class="number">1483011406</span>,</span><br><span class="line">          <span class="attr">"user_digg"</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">"group_id"</span>: <span class="number">53368972910</span>,</span><br><span class="line">          <span class="attr">"user_name"</span>: <span class="string">"哈哈1个大开心"</span>,</span><br><span class="line">          <span class="attr">"id"</span>: <span class="number">53372167364</span>,</span><br><span class="line">          <span class="attr">"user_bury"</span>: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"type"</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">"display_time"</span>: <span class="number">1483101547</span>,</span><br><span class="line">      <span class="attr">"online_time"</span>: <span class="number">1483101547</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"next"</span>: &#123;</span><br><span class="line">    <span class="attr">"max_behot_time"</span>: <span class="number">1483101547</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="获取段子评论"><a href="#获取段子评论" class="headerlink" title="获取段子评论"></a>获取段子评论</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://www.toutiao.com/group/段子ID/comments/?count=总数&amp;offset=偏移量&amp;item_id=0&amp;format=json</span><br></pre></td></tr></table></figure><p>例如<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://www.toutiao.com/group/53404620593/comments/?count=20&amp;offset=0&amp;item_id=0&amp;format=json</span><br></pre></td></tr></table></figure></p><p>其中 <code>段子ID</code> 可从上面的Api获取<br>得到的信息为<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"message"</span>: <span class="string">"success"</span>,</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">        <span class="attr">"comment_pagination"</span>: &#123;</span><br><span class="line">            <span class="attr">"count"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"total_count"</span>: <span class="number">75</span>,</span><br><span class="line">            <span class="attr">"url_fmt"</span>: <span class="string">"?offset=%s&amp;amp;count=%s"</span>,</span><br><span class="line">            <span class="attr">"offset"</span>: <span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"group"</span>: &#123;</span><br><span class="line">            <span class="attr">"status"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="attr">"id"</span>: <span class="number">53404620593</span>,</span><br><span class="line">            <span class="attr">"_id"</span>: <span class="number">892139876</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"comments"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"status"</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="attr">"user_uid"</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">"description"</span>: <span class="string">"这个用户很懒，神马都木有写"</span>,</span><br><span class="line">                <span class="attr">"reply_to_user_name"</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">"reply_to_user_verified"</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">"text"</span>: <span class="string">"抽烟害人害己"</span>,</span><br><span class="line">                <span class="attr">"target_id"</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">"forum_id"</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">"reply_count"</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="attr">"reply_to_user_id"</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">"is_blocked"</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">"user_verified"</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">"user_followers_count"</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">"is_blocking"</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">"user_id"</span>: <span class="number">5874570453</span>,</span><br><span class="line">                <span class="attr">"bury_count"</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">"type"</span>: <span class="number">2</span>,</span><br><span class="line">                <span class="attr">"digg_count"</span>: <span class="number">405</span>,</span><br><span class="line">                <span class="attr">"id"</span>: <span class="number">53409568162</span>,</span><br><span class="line">                <span class="attr">"platform_id"</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">"rate_score"</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">"create_time"</span>: <span class="number">1483093293</span>,</span><br><span class="line">                <span class="attr">"user_name"</span>: <span class="string">"今天回家吃晚饭"</span>,</span><br><span class="line">                <span class="attr">"user_profile_image_url"</span>: <span class="string">"http://p9.pstatp.com/thumb/bc3000463d913c1744c"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"page_display_range"</span>: [</span><br><span class="line">            <span class="number">1</span>,</span><br><span class="line">            <span class="number">2</span>,</span><br><span class="line">            <span class="number">3</span>,</span><br><span class="line">            <span class="number">4</span>,</span><br><span class="line">            <span class="number">5</span>,</span><br><span class="line">            <span class="number">6</span>,</span><br><span class="line">            <span class="number">7</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"page"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"page_size"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"page_last"</span>: <span class="number">75</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;获取新闻标题&quot;&gt;&lt;a href=&quot;#获取新闻标题&quot; class=&quot;headerlink&quot; title=&quot;获取新闻标题&quot;&gt;&lt;/a&gt;获取新闻标题&lt;/h2&gt;&lt;h3 id=&quot;普通用法&quot;&gt;&lt;a href=&quot;#普通用法&quot; class=&quot;headerlink&quot; title=&quot;普
      
    
    </summary>
    
      <category term="Default" scheme="https://imeiji.github.io/categories/Default/"/>
    
    
  </entry>
  
  <entry>
    <title>eBesucher挂机赚钱教程(LXDE+VNC+restarter)</title>
    <link href="https://imeiji.github.io/2016/04/03/eBesucher%E6%8C%82%E6%9C%BA%E8%B5%9A%E9%92%B1%E6%95%99%E7%A8%8B(LXDE+VNC+restarter)/"/>
    <id>https://imeiji.github.io/2016/04/03/eBesucher挂机赚钱教程(LXDE+VNC+restarter)/</id>
    <published>2016-04-03T08:15:07.000Z</published>
    <updated>2017-03-20T12:03:12.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ebesucher是德国目前最著名的自动冲浪赚钱站，该站最低提现金额PAYPAL2欧元，此站除了可以通过自动冲浪来赚钱之外，还可以通过邮件交换的方式来赚钱</p><p>关于收益也不好说，各个地区的IP不一样，德国IP最值钱，但是德国IP比较贵；其他欧美地区的IP差不多，收益不多，但是好在可以多台VPS同时挂机，要做到支付还是相当轻松的（100000积分=2.1欧元，2欧元起付，Paypal支付）。</p></blockquote><p>挂机条件</p><ul><li>VPS内存在512M以上</li><li>一个欧洲的IP的VPS</li></ul><p>挂机准备</p><ul><li>ebesucher注册地址: <a href="http://www.ebesucher.com/?ref=MeijiLee" target="_blank" rel="noopener">https://www.ebesucher.com</a><br>尽量还是要填写真实信息，收款时会验证手机号，请务必国籍填写中国。</li><li>必须安装 VNC, 浏览器</li><li>可选安装 Java, restarter</li></ul><h2 id="安装轻量级桌面LXDE-VNC"><a href="#安装轻量级桌面LXDE-VNC" class="headerlink" title="安装轻量级桌面LXDE+VNC"></a>安装轻量级桌面LXDE+VNC</h2><blockquote><p>LXDE，全名为Lightweight X11 Desktop Environment，是一个自由桌面环境，可在Unix以及如Linux、BSD等POSIX相容平台上执行。廉价迷你Linux机器Raspberry Pi安装的就是这个桌面，LXDE支持debian及ubuntu环境。</p></blockquote><p><strong>LXDE桌面安装方法</strong></p><ol><li>首先运行update<br><code>apt-get update</code>  </li><li>安装LXDE环境<br><code>apt-get install xorg lxde-core tightvncserver</code><br>其中xorg为x window，tightvncserver为vnc server<br>在过程中有一个机器地区选择，我们默认回车就可以。</li><li>启动VNC/输入密码<br><code>tightvncserver :1</code><br>需要输入vnc密码，提示”Would you like to enter a view-only password (y/n)?”时回车即可</li><li><p>配置xstartup系统文件<br>首先要暂停vnc，可以使用如下代码：<br><code>tightvncserver -kill :1</code><br>编辑xstartup文件：<br><code>vi ~/.vnc/xstartup</code><br>然后在文件的最后添加下面的脚本代码  </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lxterminal &amp;</span><br><span class="line">/usr/bin/lxsession -s LXDE &amp;</span><br></pre></td></tr></table></figure></li><li><p>重启VNC<br><code>tightvncserver :1</code></p></li></ol><p><strong>LXDE桌面使用方法</strong>  </p><ol><li>使用vnc viewer登陆<br>在这里下载: <a href="http://www.realvnc.com/download/viewer/" target="_blank" rel="noopener">http://www.realvnc.com/download/viewer/</a><br>打开客户端，输入IP:590x，这里x是x桌面的编号:<br>连接后输入密码，就可以进入桌面了。</li></ol><h2 id="安装浏览器和Flash"><a href="#安装浏览器和Flash" class="headerlink" title="安装浏览器和Flash"></a>安装浏览器和Flash</h2><blockquote><p>建议安装两个浏览器,方便随时切换  </p></blockquote><ul><li><p>安装Firefox</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># debian</span><br><span class="line">apt-get install iceweasel</span><br><span class="line"># Ubuntu</span><br><span class="line">apt-get install firefox</span><br></pre></td></tr></table></figure></li><li><p>安装chrome(可选)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 32位</span><br><span class="line">wget https://dl.google.com/linux/direct/google-chrome-stable_current_i386.deb</span><br><span class="line">dpkg -i google-chrome-stable_current_i386.deb</span><br><span class="line"># 64位</span><br><span class="line">wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb</span><br><span class="line">dpkg -i google-chrome-stable_current_amd64.deb</span><br></pre></td></tr></table></figure></li><li><p>安装Flash<br>方法一:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /etc/apt/sources.list</span><br><span class="line"># 添加如下源</span><br><span class="line">deb ftp://ftp.debian.org/debian stable main contrib non-free</span><br><span class="line"># 更新源</span><br><span class="line">apt-get update</span><br><span class="line"># 安装flashplugin-nonfree</span><br><span class="line">apt-get install flashplugin-nonfree</span><br><span class="line"># 安装成功后重启firefox，进入firefox的插件设置页面,看看是否成功</span><br></pre></td></tr></table></figure></li></ul><p>​    方法二:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://fpdownload.adobe.com/get/flashplayer/pdc/24.0.0.221/flash_player_npapi_linux.x86_64.tar.gz</span><br><span class="line">tar -zxf flash_player_*_linux.x86_64.tar.gz</span><br><span class="line">cp libflashplayer.so /usr/lib/mozilla/plugins/</span><br><span class="line">cp -r usr /usr</span><br><span class="line"><span class="meta">#</span><span class="bash"> 最新下载地址 https://get.adobe.com/cn/flashplayer/otherversions/</span></span><br></pre></td></tr></table></figure><h2 id="安装Java-可选"><a href="#安装Java-可选" class="headerlink" title="安装Java(可选)"></a>安装Java(可选)</h2><ul><li><p>Debian</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"deb http://ppa.launchpad.net/webupd8team/java/ubuntu xenial main"</span> | tee /etc/apt/sources.list.d/webupd8team-java.list</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"deb-src http://ppa.launchpad.net/webupd8team/java/ubuntu xenial main"</span> | tee -a /etc/apt/sources.list.d/webupd8team-java.list</span><br><span class="line">apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys EEA14886</span><br><span class="line">apt-get update</span><br><span class="line">apt-get install oracle-java8-installer</span><br></pre></td></tr></table></figure></li><li><p>Ubuntu</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install python-software-propertie  software-properties-common</span><br><span class="line">add-apt-repository ppa:webupd8team/java</span><br><span class="line">apt-get update</span><br><span class="line">apt-get install oracle-java8-installer</span><br><span class="line"><span class="comment"># 选择Java版本(可选)</span></span><br><span class="line">update-alternatives --config java</span><br></pre></td></tr></table></figure></li></ul><h2 id="安装restarter-可选"><a href="#安装restarter-可选" class="headerlink" title="安装restarter(可选)"></a>安装restarter(可选)</h2><blockquote><p>restarter是ebesucher提供的挂机辅助工具，可以在浏览器出现错误（冲浪的网站弹窗，卡死，崩溃等）时自动重启浏览器，这样极大的方便了我们挂机，避免手动维护。</p></blockquote><ul><li><p>下载restarter</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https://www.ebesucher.com/data/restarter-setup-others.v1.2.03.zip</span><br><span class="line">apt-get install unzip</span><br><span class="line">unzip restarter-setup-others.v1.2.03.zip</span><br></pre></td></tr></table></figure></li><li><p>安装好java及restarter之后，通过vnc viewer进入桌面，启动终端界面root Terminal<br>输入以下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /root</span><br><span class="line">java -jar restarter.jar</span><br></pre></td></tr></table></figure></li></ul><p>这样就已启动restarter</p><h2 id="设置restarter-可选"><a href="#设置restarter-可选" class="headerlink" title="设置restarter(可选)"></a>设置restarter(可选)</h2><blockquote><p>启动restarter之后需要对restarter进行设置</p></blockquote><ol><li>输入username和CODE。<br>CODE可以在 <a href="http://www.ebesucher.com/restarter.html" target="_blank" rel="noopener">http://www.ebesucher.com/restarter.html</a> 中找到</li><li>选择语言language<br>有三个选项，到这里查看你的地址 <a href="https://www.ebesucher.com/punkteverdienen.html" target="_blank" rel="noopener">https://www.ebesucher.com/punkteverdienen.html</a><br>一般我们选择ebesucher.de</li><li>选择浏览器<br>优先选择Firefox<br>chrome需要手动设置路径 <code>/opt/google/chrome/chrome --user-data-dir</code>  </li></ol><p>点击start surfbar即可启动firefox开始冲浪</p><h2 id="开始冲浪"><a href="#开始冲浪" class="headerlink" title="开始冲浪"></a>开始冲浪</h2><ol><li><p>安装 Firefox 插件并设置好你的 username</p><p><a href="https://www.ebesucher.com/addon.html" target="_blank" rel="noopener">https://www.ebesucher.com/addon.html</a></p></li><li><p>检查 flash 是否安装成功</p></li><li><p>点击插件, 开始挂机</p></li><li><p>选择一个积分最多的地区</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://www.ebesucher.de/surfbar/username</span><br><span class="line">http://www.ebesucher.com/surfbar/username</span><br><span class="line">http://www.ebesucher.ru/surfbar/username</span><br><span class="line">http://www.ebesucher.es/surfbar/username</span><br><span class="line">http://www.ebesucher.fr/surfbar/username</span><br></pre></td></tr></table></figure><p>​</p></li></ol><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ol><li><p>浏览器不保存历史记录<br>这一点比较重要，因为你一直在冲浪如果保存历史记录，会导致大量的记录文件。<br>进入firefox的preferences-privacy-history，设置为never remember history</p></li><li><p>制作脚本,定时重启浏览器及restarter</p></li></ol><ul><li><p>Firefox</p><p><code>vi /root/Desktop/restart_ff.sh</code><br>写入以下内容</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">export</span> DISPLAY=localhost:1.0</span><br><span class="line"><span class="built_in">cd</span> /root</span><br><span class="line">rm -rf ~/.vnc/*.<span class="built_in">log</span> /tmp/plugtmp* &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">killall firefox &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">killall java &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">/usr/bin/firefox --new-tab http://www.ebesucher.com/surfbar/username &gt; /dev/null 2&gt;&amp;1 </span><br><span class="line">/usr/bin/java -jar /root/restarter.jar &gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>  其中，<a href="http://www.ebesucher.com/surfbar/username中的username改为你的用户名" target="_blank" rel="noopener">http://www.ebesucher.com/surfbar/username中的username改为你的用户名</a><br>  给脚本添加可执行权限<br>  <code>chmod a+x /root/Desktop/restart_ff.sh</code><br>  编辑cron<br>  <code>vi /etc/crontab</code><br>  设置每小时执行一次该脚本<br>  <code>0 * * * * root /root/Desktop/restart_ff.sh</code><br>  重启cron<br>  <code>service cron restart</code></p></li><li><p>chrome<br> <code>vi /root/Desktop/restart_ch.sh</code><br>  写入以下内容  </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">export</span> DISPLAY=localhost:1.0</span><br><span class="line"><span class="built_in">cd</span> /root</span><br><span class="line">rm -rf ~/.vnc/*.<span class="built_in">log</span> /tmp/plugtmp* &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">killall java &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">killall chrome &gt; /dev/null 2&gt;&amp;1</span><br><span class="line">/opt/google/chrome/chrome --new-tab http://www.ebesucher.com/surfbar/username --user-data-dir  &gt; /dev/null 2&gt;&amp;1 </span><br><span class="line">/usr/bin/java -jar /root/restarter.jar &gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>  其中，<a href="http://www.ebesucher.com/surfbar/username中的username改为你的用户名" target="_blank" rel="noopener">http://www.ebesucher.com/surfbar/username中的username改为你的用户名</a><br>  给脚本添加可执行权限<br>  <code>chmod a+x /root/Desktop/restart_ch.sh</code><br>  编辑cron<br>  <code>vi /etc/crontab</code><br>  设置每小时执行一次该脚本<br>  <code>0 * * * * root /root/Desktop/restart_ch.sh</code><br>  重启cron<br>  <code>service cron restart</code>    </p><p>  3.使用 cpulimit 限制 firefox 的使用, 防止卡死</p>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install cpulimit</span><br><span class="line"><span class="meta">#</span><span class="bash"> 限制firefox使用50% cpu 利用率</span></span><br><span class="line">cpulimit -e firefox -l 50 &gt; /dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用docker"><a href="#使用docker" class="headerlink" title="使用docker"></a>使用docker</h2><p>使用docker挂机 详细教程查看 <a href="https://github.com/iMeiji/arukas-docker" target="_blank" rel="noopener">https://github.com/iMeiji/arukas-docker</a></p><hr><p>参考<br><a href="http://www.tennfy.com/2761.html" target="_blank" rel="noopener">TENNFY WU » Ebesucher debian vps挂机教程之restarter篇</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;ebesucher是德国目前最著名的自动冲浪赚钱站，该站最低提现金额PAYPAL2欧元，此站除了可以通过自动冲浪来赚钱之外，还可以通过邮件交换的方式来赚钱&lt;/p&gt;
&lt;p&gt;关于收益也不好说，各个地区的IP不一样，德国IP最值钱，但是德国IP比较贵；其
      
    
    </summary>
    
      <category term="VPS" scheme="https://imeiji.github.io/categories/VPS/"/>
    
    
  </entry>
  
</feed>
